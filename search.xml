<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringCloudZuul]]></title>
    <url>%2F2019%2F01%2F21%2FSpringCloudZuul%2F</url>
    <content type="text"><![CDATA[1. 简介在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服务，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理，配置服务的配置文件放在git仓库，方便开发人员随时改配置。 一、Zuul简介Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。 zuul有以下功能： Authentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management spring cloud zuul的架构图如下： 在Zuul中一次http请求的生命周期如下： 2. Zuul的路由创建项目： 配置 12345678910111213spring: application: name: api-gateway cloud: config: discovery: enabled: true service-id: CONFIG profile: testeureka: client: service-url: defaultZone: http://eureka1:8761/eureka/ 路由转发功能： 123456789@SpringBootApplication@EnableZuulProxypublic class ApiGatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ApiGatewayApplication.class, args); &#125;&#125; 然后假如你想访问的微服务的id是product，然后访问的页面是微服务下的product/list页面，则启动应用之后你只需要访问localhost:8080/product/product/list既可以了。只要是你注册在服务中心的应用都可以路由访问到。 自定义路由： 添加配置 12345zuul: routes: myProduct: path: /myProduct/** serviceId: product myProduct:是你自己定义的名称（可以随便定义），path是你自己定义的路径， serviceId: 是你要访问的服务的ID，访问localhost:8080/myProduct/product/list就可以访问了。 禁止掉某一些路由：ignored-patterns:下面配置你想要禁止访问的路由即可，下面配置的是set类型的数据 12345678zuul: routes: myProduct: path: /myProduct/** serviceId: product ignored-patterns: - /product/product/listForOrder - /myProduct/product/listForOrder 还能写成 12ignored-patterns: - /**/product/listForOrder 然后在配置里面添加sensitiveHeaders:并置为空，这样子就可以从前端获取到cokkie了。 123456zuul: routes: myProduct: path: /myProduct/** serviceId: product sensitiveHeaders: 3. Zuul的过滤功能要想过滤的话继承ZuulFilter类并实现其中的方法即可，这里实现的是过滤掉URL后没有token后缀的url地址。pre过滤器。 pre 过滤器的话默认放在PRE_DECORATION_FILTER_ORDER 前面 1234567891011121314151617181920212223242526272829303132@Componentpublic class TokenFilter extends ZuulFilter &#123; @Override public String filterType() &#123; return PRE_TYPE; &#125; @Override public int filterOrder() &#123; return PRE_DECORATION_FILTER_ORDER - 1; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; RequestContext requestContext = RequestContext.getCurrentContext(); HttpServletRequest request = requestContext.getRequest(); //从url参数获取,也可以从cookie, header里获取 String token = request.getParameter("token"); if (StringUtils.isEmpty(token))&#123; requestContext.setSendZuulResponse(false); requestContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED); //没有认证权限，报错401 &#125; return null; &#125;&#125; post过滤器：类型POST_TYPE，优先级默认在SEND_RESPONSE_FILTER_ORDER前面 12345678910111213141516171819202122232425@Componentpublic class addResponseHeaderFilter extends ZuulFilter &#123; @Override public String filterType() &#123; return POST_TYPE; &#125; @Override public int filterOrder() &#123; return SEND_RESPONSE_FILTER_ORDER - 1 ; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; RequestContext requestContext = RequestContext.getCurrentContext(); HttpServletResponse response = requestContext.getResponse(); response.setHeader("X-Foo", UUID.randomUUID().toString()); return null; &#125;&#125; 4. Zuul限流限流放在pre过滤器中使用，在请求被转发之前调用。并且限流是最高的，因为限流的话是要要放在最前面实现的。 令牌桶限流。 具体实现如下： 1234567891011121314151617181920212223242526272829@Componentpublic class RateFilter extends ZuulFilter &#123; private static final RateLimiter RATE_LIMITER = RateLimiter.create(100); //google开源的令牌桶算法 @Override public String filterType() &#123; return PRE_TYPE; //在pre之前做的，所以过滤器是pre类型的 &#125; @Override public int filterOrder() &#123; return SERVLET_DETECTION_FILTER_ORDER -1; //SERVLET_DETECTION_FILTER_ORDER优先级最小，优先级越小越早执行 &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; if (!RATE_LIMITER.tryAcquire())&#123; //就是没有拿到令牌的话 throw new RateLimmitException(); &#125; return null; &#125;&#125; 5. Zuul鉴权12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Componentpublic class AuthFilter extends ZuulFilter &#123; @Autowired StringRedisTemplate stringRedisTemplate; @Override public String filterType() &#123; return PRE_TYPE; &#125; @Override public int filterOrder() &#123; return PRE_DECORATION_FILTER_ORDER - 1; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; RequestContext requestContext = RequestContext.getCurrentContext(); HttpServletRequest request = requestContext.getRequest(); //从url参数获取,也可以从cookie, header里获取 String token = request.getParameter("token"); if (StringUtils.isEmpty(token))&#123; /** * /order/create 只能买家访问（cookie中有openid） * /order/finish 只能卖家访问(cookie中有token,并且对应Redis中的值) * /product/list 都能访问 */ if ("/order/order/create".equals(request.getRequestURI()))&#123; Cookie cookie = CookieUtil.get(request, "openid"); if (cookie == null || StringUtils.isEmpty(cookie.getValue()))&#123; requestContext.setSendZuulResponse(false); requestContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED); &#125; &#125; if ("/order/order/create".equals(request.getRequestURI()))&#123; Cookie cookie = CookieUtil.get(request, "token"); if (cookie == null || StringUtils.isEmpty(cookie.getValue()) || StringUtils.isEmpty(stringRedisTemplate.opsForValue().get(String.format(RedisConstant.TOKEN_TEMPLATE, cookie.getValue()))))&#123; requestContext.setSendZuulResponse(false); requestContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED); &#125; &#125; &#125; return null; &#125;&#125; 5. Zuul跨域访问首先在springboot中要想对某一个接口跨域访问的话，直接在该方法或者是类上添加 @CrossOrigin的注解，表明可以支持跨域访问。 1234567891011121314151617@Configurationpublic class CorsConfig &#123; @Bean public CorsFilter corsFilter()&#123; final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); final CorsConfiguration config = new CorsConfiguration(); config.setAllowedOrigins(Arrays.asList("*")); //哪些原始域的cookie可以跨域访问 config.setAllowedHeaders(Arrays.asList("*")); //头 config.setAllowedMethods(Arrays.asList("*")); //方法 config.setMaxAge(300l); //缓存时间，在设置的时间段内对于相同的跨域请求不再检查 source.registerCorsConfiguration("/**", config); return new CorsFilter(source); &#125;&#125;]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud异步消息]]></title>
    <url>%2F2019%2F01%2F19%2FSpringCloudQueue%2F</url>
    <content type="text"><![CDATA[1. Docker Quickstart Terminal 该快捷方式所指向的项目“bash.exe”已经更改或移动出现这个问题是由于之前装过Git，安装Docker默认生成的快捷方式中，Git的路径是C:\Program Files\Git\bin\bash.exe。而之前安装的Git并不是这个路径，所以就会报找不到应用程序的问题。此时只要把Git的路径改为自己之前安装的路径即可，比如我的就在D:\Program Files\Git\bin\bash.exe，修改后的Target为如图所示（后面的路径不用修改）： 在docker下安装rabbitmq：https://hub.docker.com/_/rabbitmq/ –hostname必填， -p 15672:15672是管理员登录端口（将端口映射为本机端口），默认的用户名和密码均为guest。 然后登录你的docker的地址+ 15672就可以进入到rabbitmq的管理员界面了。（192.168.99.100：15672） 2.使用spring cloud stream在springcloud中可以使用rabbitmq实现异步消息对列。springcloud中提供了一个spring cloud stream的组件实现异步消息对列的操作。但是spring cloud stream只支持rabbitmq和kafka. spring cloud stream是对中间件的进一步封装，可以更加方便灵活的使用中间件，甚至可以做到对中间件代码层的无感知，和中间件的切换。 首先还是引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;&lt;/dependency&gt; 定义一个stream的发送接口： 123456789101112public interface StreamClient &#123; String INPUT = "myMessage"; String INPUT2 = "myMessage2"; @Input(StreamClient.INPUT) SubscribableChannel input(); @Output(StreamClient.INPUT2) MessageChannel output();&#125; 定义一个stream的接收类 123456789101112131415161718192021@Component@EnableBinding(StreamClient.class) //定义的发送的接口类@Slf4jpublic class StreamReceiver &#123; /** * 接收orderDTO对象 消息 * @param message */ @StreamListener(value = StreamClient.INPUT) @SendTo(StreamClient.INPUT2) //这个注解其实是消息处理完之后再返回给消息对列一个消息 public String process(OrderDTO message) &#123; log.info("StreamReceiver: &#123;&#125;", message); return "received."; &#125; @StreamListener(value = StreamClient.INPUT2) public void process2(String message) &#123; log.info("StreamReceiver2: &#123;&#125;", message); &#125;&#125; 测试一下： 1234567891011121314151617181920212223@RestControllerpublic class SendMessageController &#123; @Autowired private StreamClient streamClient; //发送消息 @GetMapping("/sendMessage") public void process() &#123; String message = "now " + new Date(); streamClient.output().send(MessageBuilder.withPayload(message).build()); &#125; /** * 发送 orderDTO对象 */ @GetMapping("/sendMessage") public void process() &#123; OrderDTO orderDTO = new OrderDTO(); orderDTO.setOrderId("123456"); streamClient.output().send(MessageBuilder.withPayload(orderDTO).build()); &#125;&#125; 这样就实现了消息的发送和接收，但是还有一个问题就是当你的启动多个实例的时候，每个实例中的对列都会收到消息，其实只需要需要的那个对列获取到消息即可。要实现这样的话其实就是需要在配置文件中配置一下分组的信息。 1234567891011121314spring: application: name: order cloud: config: discovery: enabled: true service-id: CONFIG profile: test stream: bindings: myMessage: group: order content-type: application/json 其实就是给bindings分组命名就可以了。就是把所有启动的实例分到一个组里面，这样的话一个组里的所有实例只会有一个接收到消息，其余的不会接收到消息。content-type: application/json的注解其实就是使得rabbitmq中拿到的消息是json。 消息处理完成之后返回给对列一个消息的时候怎么处理呢？ StreamReceiver端添加注解：@SendTo(StreamClient.INPUT2) //这个注解其实是消息处理完之后再返回给消息对列一个消息]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud统一配置中心]]></title>
    <url>%2F2019%2F01%2F18%2FSpringCloudConfig%2F</url>
    <content type="text"><![CDATA[1.config server创建的过程和正常的springcloud工程是一样的，只是因为这里是config的应用，需要勾选cloud config —&gt; config server的选项。同时config也是一个微服务，所以同样需要向Euerka server注册，所以同时需要勾选 cloud discovery —&gt; eureka discovery。 在启动应用上添加注解,表示该应用既是config sever又是eureka client 12@EnableDiscoveryClient@EnableConfigServer 其实在创建应用的时候已经是勾选了config server，所以pom文件中已经是有config的依赖了。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt; 然后启动会报错，因为config统一配置中心是需要不断的从仓库中拉取配置文件的信息的，这里其实到现在还没有配置仓库，所以在你的GitHub上配置一个存储库，然后在application中配置你的仓库信息如下： 1234567891011121314eureka: client: service-url: defaultZone: http://localhost:8761/eureka/spring: application: name: config cloud: config: server: git: uri: https://github.com/songwell1024/config-repo #仓库地址 username: xxxxxxx #你的GitHub的用户名 password: ******* #你的GitHub的密码 这时候启动，然后访问localhost:8080/order-a.yml就可以读取到配置文件的信息。（order）是你的配置文件名，其实说是项目名也可以。-a的后缀的命名方式： 其实应用启动之后有很多的命名，如： 12/&#123;name&#125;-&#123;profiles&#125;.yml/&#123;label&#125;/&#123;name&#125;-&#123;profiles&#125;.yml name是你的配置文件的名字，Profiles是环境，label是你的仓库的分支，默认是master。 然后拉取下来的配置文件config其实生成了一个存储路径，但是这个路径是可以指定的，只需要加一个basedir的配置即可。 2.config client既然配置文件已经放在存储库中了，那么其实微服务是不需要在配置这些信息了，直接从配置中心取就可以了。怎么做呢？ 在你的微服务中引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;&lt;/dependency&gt; 不需要添加注解。 配置文件中添加如下配置： 123456789spring: application: name: order cloud: config: discovery: enabled: true service-id: CONFIG profile: test service-id是你的配置中心的名字，然后profile就是访问时候的后缀环境。最终访问的时候就是localhost：8080/order-test. 启动会报如下错误： Cannot determine embedded database driver class for database type NONE. 其实就是找不到数据库。 因为你的配置是写在application.yml下的，当微服务启动的时候，你不知道他会不会先加载这里面的配置信息，如果还没有加载而去配置数据库的信息，导致了报错。 在springboot中有一个文件叫bootstrap.yml的配置文件，他是先加载先启动的，这样的话就可以先把配置信息启动了，然后就可以正常启动了。 然后上面的配置的eureka的地址是8761，然后当你该为8762 的时候，同时把config server和config client 还有你的配置的仓库中配置全部改为8762，然后再启动才可以，注意只要改配置的端口的话就要都改。 然后我的配置仓库中有一个order.yml 还有一个order-test的yml文件，上面的配置我们看到profile: test，也就是应该加载order-test.yml文件，但是其实启动的时候order也会加载，并且会把两个配置信息进行合并，这里会导致错误，一定要注意。这里默认的可能是order是微服务的名字，把这些一order有关的配置都会加载进来 spring cloud bus 实现配置自动刷新我们每次修改配置之后不能总是重新启动然后实现更新吧，可不可以实现配置中心修改完配置之后通知到微服务（微服务之间的消息的传递最好是使用消息对队列的方式），然后微服务读取到这个更新呢？ 系统的架构如下所示： spring cloud bus会暴露出/bus-refresh的接口，config访问就可以读取到配置文件的更新。 config配置中心引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 同时你的微服务也需要添加依赖，因为都需要使用。 然后在你的config server的yml文件中配置如下：也就是要把这个接口暴露出来，然后访问才不会报错。”*”就是把所有的接口都暴露出来。 12345management: endpoints: web: exposure: include: "*" 然后在你的读取配置的地方还需要添加注解:@RefreshScope 12345678910111213@RestController@RequestMapping("/test")@RefreshScopepublic class EnvController &#123; @Value("$&#123;test&#125;") private String test; @GetMapping("/print") public String print() &#123; return test; &#125;&#125; 集成WebHooks实现配置自动刷新：GitHub配置仓库添加WebHooks，spring cloud config提供了一个叫monitor的路由来访问/bus-refresh。所以你的URL后面是monitor，然后前面是将本机地址随机映射成为的外网地址。]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud微服务之间的通信]]></title>
    <url>%2F2019%2F01%2F17%2FSpringCloudCommunition%2F</url>
    <content type="text"><![CDATA[1. 服务之间的通信应用之间通信的常见的两种方式是http和RPC方式。典型的代表框架就是SpringCloud和Dubbo SpringCloud中使用RestTemplate实现应用间的通信。举一个简单的例子来实现下。 现在有订单和商品两个服务，现在要时候订单服务去调用商品服务。 商品服务端 12345678@RestControllerpublic class ServerController &#123; @GetMapping("/msg") public String msg()&#123; return "this is product msg"; &#125;&#125; 订单服务端 12345678910111213@Slf4jpublic class ClientController &#123; @GetMapping("/getProductMsg") public String getProductMsg()&#123; //1.第一种方式 RestTemplate restTemplate = new RestTemplate(); String response = restTemplate.getForObject("http://localhost:8080/msg",String.class); log.info("response=&#123;&#125;", response); return response; &#125;&#125; 访问可以得到商品服务端返回的信息。 上面的方式要访问固定的URL,这样就肯定是不方便的，假如上面的应用我有多个地址，或者当你根本不知道地址的时候怎么办？ 第二种方式使用LoadBalancerClient通过应用名获取URL等信息。 123456789@Autowiredprivate LoadBalancerClient loadBalancerClient;RestTemplate restTemplate = new RestTemplate(); ServiceInstance serviceInstance = loadBalancerClient.choose("PRODUCT"); String url = String.format("http://%s:%s",serviceInstance.getHost(), serviceInstance.getPort()) + "/msg"; String response = restTemplate.getForObject(url,String.class); log.info("response=&#123;&#125;", response); return response; loadBalancerClient.choose(“PRODUCT”);中的PRODUCT是你的服务注册在server端的名字 第三种方式使用注解的方式 首先配置一个类 123456789@Componentpublic class RestTemplateConfig &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 在controller中配置如下：PRODUCT为微服务的应用名 1234RestTemplate restTemplate = new RestTemplate();String response = restTemplate.getForObject("http://PRODUCT/msg",String.class);log.info("response=&#123;&#125;", response);return response; 2. 客户端的负载均衡器-RibbonSpringCloud是客户端发现，他的负载均衡是软负载均衡，也就是eureka通过拉取已经注册的服务，然后通过负载均衡策略直接命中相应的服务。SpringCloud中的客户端的负载均衡器是Ribbon Ribbon下的组件主要有：ServerList，IRule，ServerListFilter等，主要流程是通过serverlist获取所有可用的服务列表，然后ServerListFilter会过滤掉一部分的地址，最后使用IRule从剩下的服务列表中选择一个实例作为最后的目标。 Ribbon中的负载均衡的策略是通过轮询的方式实现的。要是想改变负载均衡的策略的话可以在yml文件中配置如下： 1234users: ribbon: NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule 不同的版本的配置可能不同我这里的版本是Greenwich.RC2。具体的可以去官网查看Reference Doc.users是你的微服务的名字 3. Spring Cloud 声明式服务调用 Feign上面说到Ribbon做的负载均衡是用的Spring提供RestTemple来做的请求。 Springcloud的Fegin组件，这个组件是Spring提供的封装好的跨服调用组建可以使服务之间的调用更为便捷。 官网有介绍是怎么使用的：https://cloud.spring.io/spring-cloud-static/Greenwich.RC2/multi/multi_spring-cloud-feign.html#netflix-feign-starter 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 在启动应用中添加注解 123456789101112import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125;&#125; 声明你要调用的是那些服务的那些接口 123456@FeignClient(name = "product") public interface ProductClient &#123; @GetMapping("/msg") String productMsg();&#125; name属性是你的服务名，@GetMapping(“/msg”)下的地址是你要调用的接口。也就是你的服务下要有这个接口，要不然你调用的是个锤子。 在客户端调用的时候直接使用上面的类实现调用即可，注意的是对应好返回类型。 12345678910public class ClientController &#123; @Autowired ProductClient productClient; @GetMapping("/getProductMsg") public String getProductMsg()&#123; String response = productClient.productMsg(); return response; &#125;&#125; 通过上面我们发现它使用的是基于接口的注解的方式实现服务之间的调用。 当你的方法中有@RequestBody时，请使用@PostMapping的注解，因为你传入的不止一个参数。但是当你使用@PathVarible，@ReauestParam或者是无参数传入的时候可以使用@GetMapping的注解，其实最主要的是看你的前端请求是post方式还是get方式。 注意： Optional 类主要解决的问题是臭名昭著的空指针异常（NullPointerException） 4. 多服务拆分使用上面的ribbon的方式实现了应用间的调用，但是发现每个应用之间是存在冗余的部分的，可以把这些东西抽取出来做成公共的模块，然后有一些互相调用的东西也可以做成公共的接口去实现。]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloudEureka]]></title>
    <url>%2F2019%2F01%2F16%2FSpringCloudEureka%2F</url>
    <content type="text"><![CDATA[SpringCloud（1）Eureka—服务注册与发现1 创建服务注册中心在这里，我们需要用的的组件上Spring Cloud Netflix的Eureka ,Eureka 是一个服务注册和发现模块。 1.1 创建maven工程 这样工程就创建完成了。 1.2 启动服务注册中心在启动程序出加上@EnableEurekaServer注解即可 123456789@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 这时候启动程序会报错 这是因为eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server既是一个server也是一个eureka client ,对于一个client来说必须要指定一个 server。 配置application.yml文件，把自己注册到自己上就可以（应用刚启动可能注册不上，注册的过程是一个发送心跳的过程，隔一段时间就会进行注册，这时候就会注册成功） 再启动还是有错误的，因为在默认设置下，Eureka服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为。使用 register-with-eureka: false 和 fetch-registry: false禁止掉即可 1234567891011eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ register-with-eureka: false fetch-registry: falsespring: application: name: eurekaserver: port: 8761 1.3 创建服务提供者–eureka client创建工程的过程与上面类似，选择Cloud Discovery—&gt;Eureka Discovery即可 加@EnableDiscoveryClient注解声明这是一个client 123456789@SpringBootApplication@EnableDiscoveryClientpublic class EurekaclientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaclientApplication.class, args); &#125;&#125; application.yml中的配置 1234567eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ #这是你的server的地址spring: application: name: client 启动服务（确保你上面的配置的server是启动中的，要不然找不到注册服务的服务中心），发现服务启动完成立即终止，也不会去向服务端注册 需要添加如下的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 再启动服务，发现在server端已经注册完成了 当你频繁启动的时候，会发现包如下的提示： 这是因为client与server端使用的是心跳机制，server端会不断的去检测client是否存活，会统计一个上线率，当低于某个值时就会出现上面的提示。开发环境下可以把他关掉，但是生产环境下务必保持开启。 在server端的yml添加如下配置： 12server: enable-self-preservation: false 1.4 Eureka的高可用其实上面的配置是单体的，就是一个client向一个server注册，当这个server崩溃时服务补救挂掉了吗。怎么解决？可以多建立几台服务器，部署多个Eureka，然后向多个Eureka server之间互相注册。 配置两个服务，然后设置不同的端口。 然后启动的时候把server-port注释掉，启动EurekaApplication1,EurekaApplication1的配置如下： 1234567891011eureka: client: service-url: defaultZone: http://localhost:8762/eureka/ #这里就是把Eureka1注册到Eureka2上 register-with-eureka: false fetch-registry: false server: enable-self-preservation: falsespring: application: name: eureka 启动EurekaApplication2,EurekaApplication2的配置如下： 1234567891011eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ #这里就是把Eureka2注册到Eureka1上 register-with-eureka: false fetch-registry: false server: enable-self-preservation: falsespring: application: name: eureka 启动客户端，客户端的注册地址只有 http://localhost:8761/eureka/，但是分别打开 http://localhost:8761和 http://localhost:8762我们发现client在两个server端都注册了，这是因为两个Eureka的server互相注册，当client注册到Eureka-server1时会同时同步到Eureka-server2上。这个时候Eureka-server1挂掉也是没关系的。 但是Eureka-server1挂掉之后，在重新注册client是注册不上的，因为一开始的时候注册地址只有Eureka-server1，所以要想Eureka-server1挂掉之后，重新注册client，只要注册地址多加一个Eureka-server2的地址即可。 1234567eureka: client: service-url: defaultZone: http://localhost:8761/eureka/,http://localhost:8762/eureka/spring: application: name: client 要是有更多个server时，server之间两两注册即可。]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot（21） 基于阿里大于的短信验证微服务]]></title>
    <url>%2F2019%2F01%2F06%2FCheckSmsCode%2F</url>
    <content type="text"><![CDATA[SpringBoot（21） 基于阿里大于的短信验证微服务阿里大于其实就是阿里云下提供的一个服务，有开放API及SDK，用起来很方便，至于怎么去注册，开启服务，申请签名，生成短信模板，获取AccessKey，下载SDK和Demo等等操作就不详细介绍了，网上有很多的教程很详细，可以参考这篇博客： https://blog.csdn.net/qq1031893936/article/details/81173878 其中下载SDK地址： https://help.aliyun.com/document_detail/55359.html?spm=5176.doc55284.2.6.iRVRZy 这里主要是写短信验证功能是怎么实现的。并把它做成一个微服务的这样通用框架，然后通过这个短信上的微服务框架，使得用户服务可以通过rabbitMQ（正好项目中也用到了rabbitMQ）调用短信微服务实现与阿里大于的交换，实现短信的发送和验证。 SDK下载之后解压目录如下，api_demo是官方例程,api_sdk中包含了两个jar包 在项目中添加两个jar包(aliyun-java-sdk-core-3.3.1.jar和aliyun-java-sdk-dysmsapi-1.0.0.jar)，并在Maven（pom.xml文件）中添加依赖 12345678910111213141516&lt;!--阿里大于--&gt; &lt;dependency&gt; &lt;groupId&gt;aliyun-java-sdk-core&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib/aliyun-java-sdk-core-3.3.1.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aliyun-java-sdk-dysmsapi&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib/aliyun-java-sdk-dysmsapi-1.0.0.jar&lt;/systemPath&gt; &lt;/dependency&gt; 这样的话其实就已经完成了基础的配置。 然后api_demo下有官方给出的demo具体代码如下，其实就是两个核心函数，sendSms()实现的是发短信的功能，querySendDetails（）实现查询发送短信的详细信息. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.springboot.SecKill.SMSVerification;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.IAcsClient;import com.aliyuncs.dysmsapi.model.v20170525.QuerySendDetailsRequest;import com.aliyuncs.dysmsapi.model.v20170525.QuerySendDetailsResponse;import com.aliyuncs.dysmsapi.model.v20170525.SendSmsRequest;import com.aliyuncs.dysmsapi.model.v20170525.SendSmsResponse;import com.aliyuncs.dysmsapi.transform.v20170525.SendSmsResponseUnmarshaller;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.http.FormatType;import com.aliyuncs.http.HttpResponse;import com.aliyuncs.profile.DefaultProfile;import com.aliyuncs.profile.IClientProfile;import java.nio.charset.Charset;import java.text.SimpleDateFormat;import java.util.Date;import java.util.UUID;/** * Created on 17/6/7. * 短信API产品的DEMO程序,工程中包含了一个SmsDemo类，直接通过 * 执行main函数即可体验短信产品API功能(只需要将AK替换成开通了云通信-短信产品功能的AK即可) * 工程依赖了2个jar包(存放在工程的libs目录下) * 1:aliyun-java-sdk-core.jar * 2:aliyun-java-sdk-dysmsapi.jar * * 备注:Demo工程编码采用UTF-8 * 国际短信发送请勿参照此DEMO */public class SmsDemo &#123; //产品名称:云通信短信API产品,开发者无需替换 static final String product = "Dysmsapi"; //产品域名,开发者无需替换 static final String domain = "dysmsapi.aliyuncs.com"; // TODO 此处需要替换成开发者自己的AK(在阿里云访问控制台寻找) static final String accessKeyId = "yourAccessKeyId"; static final String accessKeySecret = "yourAccessKeySecret"; public static SendSmsResponse sendSms() throws ClientException &#123; //可自助调整超时时间 System.setProperty("sun.net.client.defaultConnectTimeout", "10000"); System.setProperty("sun.net.client.defaultReadTimeout", "10000"); //初始化acsClient,暂不支持region化 IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", accessKeyId, accessKeySecret); DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain); IAcsClient acsClient = new DefaultAcsClient(profile); //组装请求对象-具体描述见控制台-文档部分内容 SendSmsRequest request = new SendSmsRequest(); //必填:待发送手机号 request.setPhoneNumbers("15000000000"); //必填:短信签名-可在短信控制台中找到 request.setSignName("云通信"); //必填:短信模板-可在短信控制台中找到 request.setTemplateCode("SMS_1000000"); //可选:模板中的变量替换JSON串,如模板内容为"亲爱的$&#123;name&#125;,您的验证码为$&#123;code&#125;"时,此处的值为 request.setTemplateParam("&#123;\"name\":\"Tom\", \"code\":\"123\"&#125;"); //选填-上行短信扩展码(无特殊需求用户请忽略此字段) //request.setSmsUpExtendCode("90997"); //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者 request.setOutId("yourOutId"); //hint 此处可能会抛出异常，注意catch SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request); return sendSmsResponse; &#125; public static QuerySendDetailsResponse querySendDetails(String bizId) throws ClientException &#123; //可自助调整超时时间 System.setProperty("sun.net.client.defaultConnectTimeout", "10000"); System.setProperty("sun.net.client.defaultReadTimeout", "10000"); //初始化acsClient,暂不支持region化 IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", accessKeyId, accessKeySecret); DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain); IAcsClient acsClient = new DefaultAcsClient(profile); //组装请求对象 QuerySendDetailsRequest request = new QuerySendDetailsRequest(); //必填-号码 request.setPhoneNumber("15000000000"); //可选-流水号 request.setBizId(bizId); //必填-发送日期 支持30天内记录查询，格式yyyyMMdd SimpleDateFormat ft = new SimpleDateFormat("yyyyMMdd"); request.setSendDate(ft.format(new Date())); //必填-页大小 request.setPageSize(10L); //必填-当前页码从1开始计数 request.setCurrentPage(1L); //hint 此处可能会抛出异常，注意catch QuerySendDetailsResponse querySendDetailsResponse = acsClient.getAcsResponse(request); return querySendDetailsResponse; &#125; public static void main(String[] args) throws ClientException, InterruptedException &#123; //发短信 SendSmsResponse response = sendSms(); System.out.println("短信接口返回的数据----------------"); System.out.println("Code=" + response.getCode()); System.out.println("Message=" + response.getMessage()); System.out.println("RequestId=" + response.getRequestId()); System.out.println("BizId=" + response.getBizId()); Thread.sleep(3000L); //查明细 if(response.getCode() != null &amp;&amp; response.getCode().equals("OK")) &#123; QuerySendDetailsResponse querySendDetailsResponse = querySendDetails(response.getBizId()); System.out.println("短信明细查询接口返回数据----------------"); System.out.println("Code=" + querySendDetailsResponse.getCode()); System.out.println("Message=" + querySendDetailsResponse.getMessage()); int i = 0; for(QuerySendDetailsResponse.SmsSendDetailDTO smsSendDetailDTO : querySendDetailsResponse.getSmsSendDetailDTOs()) &#123; System.out.println("SmsSendDetailDTO["+i+"]:"); System.out.println("Content=" + smsSendDetailDTO.getContent()); System.out.println("ErrCode=" + smsSendDetailDTO.getErrCode()); System.out.println("OutId=" + smsSendDetailDTO.getOutId()); System.out.println("PhoneNum=" + smsSendDetailDTO.getPhoneNum()); System.out.println("ReceiveDate=" + smsSendDetailDTO.getReceiveDate()); System.out.println("SendDate=" + smsSendDetailDTO.getSendDate()); System.out.println("SendStatus=" + smsSendDetailDTO.getSendStatus()); System.out.println("Template=" + smsSendDetailDTO.getTemplateCode()); &#125; System.out.println("TotalCount=" + querySendDetailsResponse.getTotalCount()); System.out.println("RequestId=" + querySendDetailsResponse.getRequestId()); &#125; &#125;&#125; 然后在SpringBoot中具体的使用阿里大于来实现短信验证,注册登录功能. 1. 在application.properties文件中添加配置12accessKeyId = xxxxx;accessKeySecret = xxxxx; 2. 短信发送类其实就是吧官方的demo修改一下，把其中的一些参数改变成为传入参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.springboot.SecKill.SMSVerification;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.IAcsClient;import com.aliyuncs.dysmsapi.model.v20170525.QuerySendDetailsRequest;import com.aliyuncs.dysmsapi.model.v20170525.QuerySendDetailsResponse;import com.aliyuncs.dysmsapi.model.v20170525.SendSmsRequest;import com.aliyuncs.dysmsapi.model.v20170525.SendSmsResponse;import com.aliyuncs.dysmsapi.transform.v20170525.SendSmsResponseUnmarshaller;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.http.FormatType;import com.aliyuncs.http.HttpResponse;import com.aliyuncs.profile.DefaultProfile;import com.aliyuncs.profile.IClientProfile;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.env.Environment;import java.nio.charset.Charset;import java.text.SimpleDateFormat;import java.util.Date;import java.util.UUID;@Componentpublic class SMSUtil &#123; //产品名称:云通信短信API产品,开发者无需替换 static final String product = "Dysmsapi"; //产品域名,开发者无需替换 static final String domain = "dysmsapi.aliyuncs.com"; @Autowired private Environment environment; public SendSmsResponse sendSms(String mobile,String template_code,String sign_name,String param) throws ClientException &#123; //可自助调整超时时间 System.setProperty("sun.net.client.defaultConnectTimeout", "10000"); System.setProperty("sun.net.client.defaultReadTimeout", "10000"); //读取配置文件中的这两个配置变量 String accessKeyId = environment.getProperty("accessKeyId"); String accessKeySecret = environment.getProperty("accessKeySecret"); //初始化acsClient,暂不支持region化 IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", accessKeyId, accessKeySecret); DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain); IAcsClient acsClient = new DefaultAcsClient(profile); //组装请求对象-具体描述见控制台-文档部分内容 SendSmsRequest request = new SendSmsRequest(); //必填:待发送手机号 request.setPhoneNumbers(mobile); //你要发送的手机号 //必填:短信签名-可在短信控制台中找到 request.setSignName(sign_name); //必须是你自己的已经审核通过的签名 //必填:短信模板-可在短信控制台中找到 request.setTemplateCode(template_code); //模板CODE //可选:模板中的变量替换JSON串,如模板内容为"亲爱的$&#123;name&#125;,您的验证码为$&#123;code&#125;"时,此处的值为 request.setTemplateParam(param); //选填-上行短信扩展码(无特殊需求用户请忽略此字段) //request.setSmsUpExtendCode("90997"); //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者 request.setOutId("yourOutId"); //hint 此处可能会抛出异常，注意catch SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request); return sendSmsResponse; &#125; public QuerySendDetailsResponse querySendDetails(String mobile,String bizId) throws ClientException &#123; //可自助调整超时时间 System.setProperty("sun.net.client.defaultConnectTimeout", "10000"); System.setProperty("sun.net.client.defaultReadTimeout", "10000"); //读取配置文件中的这两个配置变量 String accessKeyId = environment.getProperty("accessKeyId"); String accessKeySecret = environment.getProperty("accessKeySecret"); //初始化acsClient,暂不支持region化 IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", accessKeyId, accessKeySecret); DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain); IAcsClient acsClient = new DefaultAcsClient(profile); //组装请求对象 QuerySendDetailsRequest request = new QuerySendDetailsRequest(); //必填-号码 request.setPhoneNumber(mobile); //可选-流水号 request.setBizId(bizId); //必填-发送日期 支持30天内记录查询，格式yyyyMMdd SimpleDateFormat ft = new SimpleDateFormat("yyyyMMdd"); request.setSendDate(ft.format(new Date())); //必填-页大小 request.setPageSize(10L); //必填-当前页码从1开始计数 request.setCurrentPage(1L); //hint 此处可能会抛出异常，注意catch QuerySendDetailsResponse querySendDetailsResponse = acsClient.getAcsResponse(request); return querySendDetailsResponse; &#125;&#125; 3. rabbitMQ实现短信接收rabbitMQ中显定义一个队列，并初始化(下面就是简要的把要添加的内容写出来了，项目中使用了不止这一个对列) 12345678910111213@Configurationpublic class MQConfig &#123; public static final String SMS_QUEUE = "Sms.QUEUE"; /** * Direct 交换机模式 */ //队列 @Bean public Queue Sms_QUEUE() &#123; return new Queue(SECKILL_QUEUE,true); &#125; 然后接收类 1234567891011121314151617181920212223242526272829303132333435363738package com.springboot.SecKill.SMSVerification;import com.aliyuncs.dysmsapi.model.v20170525.SendSmsResponse;import com.aliyuncs.exceptions.ClientException;import com.springboot.SecKill.rabbitmq.MQConfig;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.util.Map;/** * @author WilsonSong * @date 2019/1/6/006 */@Componentpublic class SMSListener &#123; @Autowired private SMSUtil smsUtil; @RabbitListener(queues = MQConfig.SMS_QUEUE) public void sendSms(Map&lt;String,String&gt; map)&#123; try &#123; SendSmsResponse response = smsUtil.sendSms(map.get("mobile"), map.get("template_code") , map.get("sign_name") , map.get("param") ); System.out.println("code:"+response.getCode()); System.out.println("message:"+response.getMessage()); &#125; catch (ClientException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 其实到这里就形成了一个通用的短信发送服务，用户在注册或登录的时候只需要通过RabbitMQ读取MQConfig.SMS_QUEUE对列中的短信即可。 4. 写一个网页测试123456789101112131415161718@Controllerpublic class QueueController &#123; @Autowired AmqpTemplate amqpTemplate; @RequestMapping("/sendmap") public void sendMap()&#123; Map map=new HashMap&lt;&gt;(); map.put("mobile", "xxxxxx"); //手机号 map.put("template_code", "SMS_xxxxxxx"); //短信模板，模板CODE map.put("sign_name","xxxxxx"); //申请的短信签名 map.put("param", "&#123;\"name\":\"xxxx\"&#125;"); //你自己定义的短线模板的格式和参数 amqpTemplate.convertAndSend(MQConfig.Sms_QUEUE, map); &#125;&#125; 到这里其实就完成了，接下来就是把这个整合到登陆注册页面上去，实现短信的发送，验证功能,其实具体的流程是很简单的，就是生成-RabbitMQ-后端检验，具体的就有些繁琐，就不具体详细写了，完整的代码可以去我的github上下载，右侧有链接。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文献阅读整理 20181013]]></title>
    <url>%2F2018%2F10%2F21%2FPaperRead3%2F</url>
    <content type="text"><![CDATA[文献阅读整理 201810131. SPRD：基于应用UI 和程序依赖图的Android 重打包应用快速检测方法1.1 文章的内容这篇文章中说研究发现重打包应用通常不修改应用用户交互界面（UI, user interface）的结构，提出一种基于应用UI和程序代码的两阶段检测方法。首先，设计了一种基于UI 抽象表示的散列快速相似性检测方法，识别UI 相似的可疑重打包应用；然后，使用程序依赖图作为应用特征表示，实现细粒度、精准的代码克隆检测。 重打包静态检测一般会遇到的问题：在Android 应用程序静态分析中，通常会受到第三方的库文件和代码混淆的影响。 本文的研究的框架： 检测的过程： 第一阶段应用UI 的快速相似性比较步骤主要分为预处理和相似性检测这2 个部分，在预处理中，首先抽取Android 应用的UI，将UI 中每一个视图（view）生成一种抽象化的表示，并使用散列算法生成view 的唯一指纹值；在相似性检测部分将每一个应用的view 指纹值进行比对，并将指纹值相同的view 做聚类处理，找出UI 相似的应用，输出可疑的重打包应用集合。 在第二阶段程序代码的细粒度克隆检测中，首先，反编译在第一阶段中输出的可疑重打包应用，生成每一个应用的PDG 作为其特征表示，利用图的相似性比较算法实现程序代码的克隆检测。最后，根据上述2 个阶段计算得出的相似值进行综合判定完成重打包应用的检测。 映射的具体规则： 表示为A=(I, D)，I表示UI，D表示code。 其中Android 应用UI 表示为$$I=\{V_{i}\},i=1,2,3,…,n$$其中$$V = &lt;L,C, \Phi &gt;$$L 和C 分别表示布局和组件集合，Φ 表示布局和组件之间的包含关系。 应用程序依赖图表示为$$G=＜S, E＞$$其中，S 表示函数的语句集，E 表示边集，当语句之间有数据或控制依赖时，语句之间存在有向边连接。 提取UI应用的过程：UI 的基本组成单元是view，抽取了view的结构，然后进行的映射 抽象表示： 其指纹的三元组表示为＜length,hash_value, app_id＞。其中，length 为线性抽象表示字符串的长度， hash_value 表示字符串的散列值,app_id 表示为应用程序的ID。 UI的相似性检测： 将上面的三元组存放在字典中，key为length 。 依次遍历字典DIC 的键，针对DIC 中相同键值的列表，将列表中抽象表示字符串的散列值进行两两相似性比较。如果值相同，则检测出相似的应用view。在得到存在view 相似的应用后，通过分析2 个应用中所有的view 相似比例来度量应用UI 的相似性，从而判定其是否为一对可疑的重打包应用。 代码相似性检测： PDG 主要用于表示程序函数体中语句之间的依赖关系，包括数据依赖和控制依赖等。 2. Effective and Scalable Repackaged Application Detection based on User Interface在本文中，我们提出了一种基于静态UI特征的大规模检测的高效简单方法。所提出的方法包括粗粒度检测以通过比较图像哈希来选择可疑的重新包装的应用，以及细粒度检测以执行更详细的UI比较以通过使用熵比较布局来细化结果。此外，我们提出了一种动态选择方法来选择可疑应用程序，这比固定阈值更准确和有效。 粗粒度分析： 我们直接从文件MANIFEST.MF中提取它们，这样更简单，更快捷。（在apk签名过程中生成MANIFEST.MF并存储所有资源文件的摘要哈希值）。 通过比较图像哈希值的相似性先找到可疑的相似应用，然后在进行细粒度的分析。 动态阈值的选择过程： 首先统计我们获得相似值分布为0.1,0.3和0.8，最大间隙位于0.3和0.8之间。其次，大多数重新包装的应用程序对的相似度值分布在最大差距之上，并且大多数非重新打包应用程序对的相似度值低于它。对于相似度大于这些值的就直接不考虑他们之间的相似性了。 细粒度分析： 我们需要首先将所有引用的布局文件合并到一个文件（怎么合的也不说，感觉用程序来合并的话有一定的难度，暂时没啥想法，遍历嘛？？？？？，手动的话就滑稽了！！！），然后提取UI的树形结构，形成特征值。其实和第一篇文章应该差不多，但是这里面没有具体说。 然后使用基于熵的相似度算法来进行相似性的比较。 说实话这篇文章还是挺有意思的，因为这里把UI作为了细粒度的分析特征，但是上面的文章就把UI特征提取作为粗粒度的特征。 3. A Deep Learning Approach to Android Malware Feature Learning and Detection这篇文章是恶意软件检测方法 在本文中，我们介绍了DroidDeep，这是一种针对Android恶意软件检测的深度学习方法，它考虑了多个级别的功能，以解决上述研究工作的局限性。DroidDeep首先考虑静态信息，包括权限，API调用和组件部署，以表征Android应用程序的行为模式，并从Android应用程序中提取包含超过30,000个功能的多级功能集。然后，我们将这些提取的特征提供给深度学习模型，以学习分类的典型特征。最后，我们将学到的特征放入基于支持向量机算法（SVM）的检测器中，用于检测Android恶意软件。 对于这里面选择的特征集太多了导致计算资源的开销，为了解决这个问题，我们使用深度信念网（DBN），这是一种快速，贪婪的学习算法，能够学习典型特征并减少提取特征的数量以节省计算资源。 文章中说几乎没有误报，我觉得嗯，吹牛，机器学习的方的通病就是在自己收集的数据集上效果非常好，但是换一个数据集的话效果就不可能那么好了。 还有就是浅层的网络结构（少于两层的网络）解决约束良好的简单问题时很好，但是复杂问题的时候就不能够有很好的代表性。 框架： 然后深度学习的框架如下图所示： 训练完成之后使用SVM分类算法对收集到的数据集进行分类，最后在这一组数据集上的分类准确率为97.5%。 在一组未知的数据集上准确率为92.2％（这种数据集是由VirusTotal来评估的）。 4. DAPASA: Detecting Android Piggybacked Apps Through Sensitive Subgraph Analysis4.1 文章内容这一篇文章也是恶意软件检测方法，因为文章写的很详细，而且有些可以可以借鉴的地方，所以看一下。但是比较难。 本文成立的两个假设： 恶意应用会请求更加敏感的权限。 Generally, in the rider, the cohesion of sensitive APIs, which is measured by calling distances, is higher than that in the carrier 为了区分敏感API的恶意程度，使用类似于TF-IDF来定义API的敏感性。它可以减少在良性和恶意应用程序中经常出现的敏感API的干扰因素。因为良性的应用有的时候也会请求一些敏感的权限。所以避免这些对于检测的干扰还是很重要的。 我们构造了一个敏感的子图来表示整个调用图并描述给定应用程序的最可疑行为。并从子图中提取了5个特征。这个敏感子图是可以代表整个函数调用图的。因为直接比较图的相似性需要很高的开销。子图的话就好一些。而且他从子图中再寻找API灵敏度最高的最高的子图作为分析的特征。 DAPASA架构： 计算灵敏度系数以表示敏感API在执行恶意行为时的恶意程度。敏感API的灵敏系数是基于统计意义的，就是统计API在恶意应用中和良性应用中出现和使用的次数然后使用一个公式来度量这个敏感系数。而且并不是使用的频率越高灵敏度越高，他是恶性和良性中都使用的很高的时候比那个恶性中使用高而在良性中使用低的API的灵敏度要低。 然后就是从应用依赖图中构建子图，构建子图的过程中其实就是计算节点之间的距离，然后生成子图，。对于每个敏感API节点，将在SFCG中构建其子节点及其相邻节点。在计算两个节点之间的距离时，SFCG被视为无向图。在我们的工作中，SFCG的平均最短路径长度通常为3到5.构建子图时，正常节点到敏感API节点的距离小于或等于2。 不知道距离是怎么来的，可能生成SFCG的时候就有？？？？？ 然后从子图中找灵敏系数最高的子图的时候，使用了类似于最小生成树的算法，因为就是已经给他计算出了每个节点的灵敏度系数，然后你就找到哪些子图的包含的节点是具有最高的灵敏度系数。（一个特征） 然后为了证明这个敏感系数和敏感距离是可以使用的区分特征，使用统计的方法分析了恶意应用中的敏感系数是大于良性应用的。（一个特征） 对于灵敏度最高的子图中他以三节点为单位统计三节点出现的频率，敏感图案在本文中被定义为包含至少一个敏感API节点的重要图案。这样就又把一些没有用的去除了，为了验证正确性买还是基于统计的方法来验证是不是就是在搭载应用中这种结构出现的频率比良性应用中出现的高。（三种视图三个特征） 在最后就是使用分类器来对应用进行分类。 数据集：Android Malware Genome Project（一般是作为基准来做的） 4.2文章中提到的值得注意的方法、RepDetector的基于语义的方法，它首先在应用程序中提取核心功能的输入输出状态，然后比较功能和应用程序之间的相似性。RepDetector对依赖于每个应用程序的语义分析而不是语法特征的混淆攻击具有很强的鲁棒性。 动态方法的缺陷：但是，大多数动态分析方法需要一组有代表性的执行路径，并且很难确保可以覆盖应用程序的所有执行路径。 5. Semantics-Based Repackaging Detection for Mobile Apps 值得仔细看下细粒度分析本文的方法是提出了一种基于语义的检测方法，通过捕获函数的输入 - 输出关系以表达其语义。只要重新打包的应用程序保留了原始应用程序的关键语义，相似性就会很高。 本文的研究框架： RepDetector由四个主要模块组成：核心类和功能提取，功能输出状态构造，功能相似性测量和应用程序相似性测量。核心功能以及重要的类将根据应用程序的字节码和清单文件提取。然后，我们为这些核心函数构造状态流图，并计算每个函数的输出状态。使用可满足模数理论（SMT）求解器，然后我们根据它们的输出状态检查两个核心函数的语义等价性。最后，我们使用Mahalanobis距离量化两个应用程序（每个应用程序由一些核心功能组成）之间的相似性。我们的方法使用符号执行，但通过合并流状态可以简化计算。 并非所有类都与应用程序的核心功能相关，而重新打包则保留了应用程序的核心功能。因此，对于重新打包检测，我们只考虑与功能相关的类。 核心类和函数提取：清单文件（AndroidManifest.xml）向Android系统提供有关应用程序的基本信息。功能相关的类包括一个应用程序的主要组成部分： activities(&lt; activity &gt;) services (&lt; service &gt;) broadcast receivers (&lt; receiver &gt;) content providers (&lt; provider &gt;). 提取的时候只需要提取这些类和功能函数就可以了。减少工作量并且相当于变相去噪声。 通过解析AndroidManifest.xml文件直接检索这些类的列表。然后为类列表构造类调用图（CIG）。 在CIG中，每个节点表示一个类，两个节点之间的有向边表示它们之间存在函数（即方法）调用关系。我们的CIG通过静态分析考虑了类关系和函数调用。此外，我们根据几个属性（例如，CIG中类节点的扇入和扇出）计算CIG中每个类的权重。通过设置权重阈值，我们可以过滤掉权重低于阈值的类。其余的类称为核心类. 然后找输出语义的结构：通过状态流程图（SFC）分析这些核心功能的结构，一个SFC的结构如下图所示： 包括一个初始化块(变量初始化)，两个约束（if），5组语句 定义的输入输出就和右边的图所示： 在文章中举了一个例子，就是实现相同功能的两个函数，一个有噪声，一个没有噪声，最后的输出是相同的。 两个函数的等价性测量具体的实现： 在其核心功能之间执行成对相似性度量,由于不知道是怎么实现的，所以就需要成对的去比较。对于上面的图输入输出的等价关系是： 匹配输入的时候是通过将输入抽象成为整数或者是布尔变量，这样容易导致误报。但是这样的处理也简化了使用SMT检查相似性的准确度和速度。 最后是综合所有的核心函数的相似性得分形成一个矩阵，利用矩阵的相似性给出一个判定的标准。 缺点： 这篇文章分析的足够细粒度，但是缺点就是太细了，计算复杂度非常高。应用之间需要相互比较，然后比较的还是成对比较核心函数的功能，就是两组的成对比较，太费资源了。而且他的通过这种语义的比较在语义的生成过程中还有粗粒度的一些做法，感觉不太好。还有就是我添加一些仿照函数，还有把几个函数合并到一起他都不能解决。 最后分析了自己的执行效率，比Androguard这个方法要快。 6. 一种静态Android重打包恶意应用检测方法（大体看了看）这篇文章对应用之间相似性检测使用了1种基于质心的检测算法，把函数的控制流程图都映射成为一种质心，然后比较质心的相似性。 把二维的程序控制流程图先映射成为3D的，求出一个质心来， 然后通过API（就是语句里面有没有invoke语句）来给每个边赋值权重，再重新求一个质心，通过这两个质心的相似性来确定重打包的恶意应用。加权的方法是通过层次分析法来实现的。加权之后那些数量少但是更加敏感的API就能够更加的突出。 本文的框架如下： 7. DeepRD：基于Siamese LSTM 网络的Android 重打包应用检测方法本文提出一种基于深度学习的Android 重打包应用检测方法，借助于深度学习强大的特征学习能力[19]，自动地学习应用的程序代码特征，通过程序代码的相似性度量实现重打包应用的检测. 本文提出将应用函数作为分析与检测的基本单元，应用函数被表示成序列特征形式并进行向量化处理，然后输入具有LSTM的Siamese 网络中学习程序代码的语义特征，最后通过应用程序代码的相似性度量判断是否为重打包应用。 特征的选取：本文中应用函数的序列特征及特征向量表示方法如下：首先，获取应用函数中API 的调用序列以及与API 存在数据依赖关系的上下文信息形成应用函数的序列特征；然后，将应用函数的序列特征表示成抽象字符串形式；最后，使用词向量嵌入模型将抽象字符串表示成向量形式输入深度学习模型Siamese LSTM 网络中训练。 在程序代码的相似性度量中，本文使用2个LSTM 网络自动地学习程序代码的序列特征表示，利用Siamese 网络度量程序代码的相似性。Siamese 网络是一种应用广泛的特征相似性度量方法。Siamese 网络常用于解决标签样本缺乏情况下的模型训练问题，它通过从数据中学习样本的相似性度量，然后与未知的标签样本进行比较。 数据集：公开数据集AndroZoo。 ZHOU W, ZHOU Y J, GRACE M, et al. Fast, scalable detection ofpiggybacked mobile applications[C]//The Third ACM Conference onData and Application Security and Privacy. 2013: 185-196. 文献中发现重打包应用中加载的恶意组件不是应用的核心代码，使用基于PDG 的模块解耦技术将应用程序代码分为核心模块和非核心代码，设计了一种特征指纹技术抽取核心模块的语义特征，实现重打包应用的检测。现在一般的使用程序依赖图的都是不管核心不核心的，全部要用来生成PDG。 本文的检测框架如下图示： 本文API 的上下文信息是指与API 在函数体中存在数据依赖的语句，这里的数据依赖包括前向数据依赖和后向数据依赖这2 种。本文平台API 及其上下文信息表示为一个三元组的形式，即V=&lt;S_prior, S, S_post&gt;。特征集F=(V1,V2,…,Vi,…,Vt) 特征向量化： 每个函数的特征向量长度不同，本文使用MaLSTM 模型处理变长的序列特征数据。 训练模型的输入是将生成的特征向量及其对应的标签作为模型的输入。其中，标签是指一对特征向量的相似度。 本文基于应用函数相似性度量的重打包应用检测中，需要考虑以下2 个因素：①应用中相似函数的个数或比例；②相似应用函数的规模。给出了度量公式。 最后通过实验与SPRD进行了检测性能的比较，然后就是对自己定义的特征的有效性进行了比较。 8. Fast, Scalable Detection of “Piggybacked” Mobile Applications（可以返回来再仔细看看）本文 的研究方法是研究的是Piggybacked这一种重打包的应用，搭载应用程序是重新打包的应用程序的一个子集。 本文中提出线性搜索算法（具有O（n log n）时间复杂度）以有效且可扩展地检测搭载的应用程序。 我们的方法基于两个主要观察。首先，在搭载应用程序中，注入代码相对独立，并且不与主机应用程序的主要功能紧密交织（如果有的话）。因此，我们提出了一种称为模块解耦的技术，以将应用程序代码有效地划分为主要和非主要模块。每个应用程序都有一个唯一的主模块，主要实现广告功能。同时，它可能有许多相对独立的非主要模块。各种支持例程或库，广告包和移动支付框架 - 以及嵌入式注入代码 - 都属于这一类。 其次搭载应用程序通常与原始运营商应用程序共享相同的主要模块。因此，我们提出另一种称为特征指纹识别的技术来提取主要模块中包含的某些语义特征（例如，所请求的许可和使用的Android API）。我们将它们表示为特征向量，将这些特征向量组织到度量空间中，然后提出线性搜索算法（具有O（n log n）时间复杂度 - 与之前的O（ n2）成对比较的复杂性相比）来检测搭载的应用程序。O(n2)是指映射完特征之后按照最近邻进行比较。但是我觉得要搜索最近邻的话也是需要n！次比较。 本文的框架： 本文成立的假设：我们假设捎带主要通过将Java代码添加到合法应用程序而不是本机代码来实现。考虑到本研究中使用的数据集，我们发现只有5％的应用程序包含本机代码。此外，我们假设合法的应用开发者不会向他人透露他们的私钥（用于app签名）。因此，搭载的应用程序将不会与原始应用程序共享相同的证书。 首先，基于Dalvik字节码，我们构建了一个程序依赖图（PDG），然后根据类的继承关系，函数调用关系，package homogeny和数据依赖关系来对PDG的每条边分配权重。(在生成图形时，我们将权重10,10,2,1分别分配给表示类继承，包同质，方法调用和成员字段引用的边。)两个类包之间的权重很高的话就合并成一个模块。这样程序的模块就分析完成。我们利用AndroidManifest.xml文件中的信息来声明应用程序的各种组件，包括其活动，服务，接收器和内容提供程序。具体来说，它指定将被调用以处理某些事件或操作的具体类。一个特殊的ACTION.MAIN代表应用程序的主要入口点。因此，我们选择包含此类的模块作为主模块的候选者。请注意主模块倾向于为用户提供与之交互的主界面。因此，我们还选择具有处理大多数活动的类的模块作为主要模块候选。候选者很多的时候，我们通过计算清单文件中模块名称与应用程序名称的相似性来选择最相似的候选者。 找到主模块之后，为了使主模块能够将代表APP，并且找到特征指纹将一个主模块的功能与另一个主模块的功能区分开，提取语义功能作为特征也就是权限API这些东西。我们然后将它们表示为向量，其中0和1分别表示主模块中某些特征的缺失和存在。之后，我们将这些特征向量（每个代表一个应用程序）组织到度量空间中，并将检测到搭载应用程序的问题转换为最近邻居搜索问题。用于最近邻居搜索的简单方法是执行成对比较并选择具有最小距离的比较。通过利用其三角不等式属性[43]，我们可以在搜索期间有效地修剪不相关的部分并实现O（n log n）时间复杂度。使用三角形不等式属性在构造的VPT树（表征特征向量的）中实现有效的搜索修剪。关于这一部分没太看懂。 关于查看哪些是搭载了应用的应用，文章中说如果应用程序A的非主要模块是B的严格子集，则B中的任何非主要模块（但不是A中的非主要模块）将被视为搭载代码的一部分。因此，我们将应用程序标记为搭载应用程序的应用程序。 想法 恶意软件的范围大还是重打包范围大？我感觉重打包的话不一定是恶意的，恶意的也不一定是重打包。应该是有交叉的。恶意应用的话是可以通过机器学习分类的方法解决的，因为只需要分类就可以了，两个类别，恶意和非恶意的，恶意的一般是有特点的，比如获取敏感的权限这样子的。但是重打包的话不是这样子的，重打包的话一般是没有很好的特征，一般是基于两个应用之间的相似程度来分析的。相似的话就定义为重打包的，一般是需要两两比对的 一个框架，首先执行大致的聚类分析，相似的应用分为一类（关于具体的特征提取，提取的过多的话额外开销，然后特征过少的话就分类的效果很差，取几个重要的特征如API，权限和组件，然后就是向量化的表示的过程，这个过程是有问题的，怎么样将特征抽象成向量然后向量需要保持特征的语义和信息，相似的很相似，不相似的就差别较大，。这个地方可以参考文章8），而且这个也不是一个学习的过程，然后对聚为一类的执行细粒度分析。通过这种方案的话能够减少两两比较的数量，因为两两比较的话只需要比较聚为一类的应用，大大减少了比较的数量。关于细粒度的比较的话还是需要再看看文章，有什么好的方案。最后的效果怎么样就得看实现之后的效果了，关键的问题在于分类边界的问题。怎么去处理分类边界的问题。就是说两个边界上的点也有可能是重打包的应用（就是说要不要处理边界问题就是看分类的效果了。）还有就是初始聚类种类的设计，实在不行的话可以讨论一下聚类的类别对于检测的影响程度。 对于上面的想法，就是使用类似于最近邻的搜索方法，就是画一个圆，只比较每一个特征圆内的所有的APP，比较次数也减少了。对于23这两种是以后看文章的重点，并且关键和重点也是难点在于向量的抽象怎么抽象？关系到检测的准确性。这样的话其实还是和两两比较是一样的。可以看看近似最近邻检索这种方式，这个方法就是在牺牲精度的基础上去返回所有可能是最近邻的点。或者是先分区在搜索。就是把所有的特征分区。分完区之后呢，搜索一个点的近邻，就是如果一个点到一个分区的核心点的距离减去半径大于你所定义的阈值的时候这个分区可以直接不用计算。这两个分区可以直接忽略比较了。还是再想想，这个想法太多漏洞了。 如果上面的方法要是不好用，还可以提取出特征来之后使用深度学习的方式去训练模型，通过机器学习的分类只是来分析恶意软件和良性软件的，能够将良性软件和恶意软件分类，但是对于重打包来说，重打包的程序不一定是恶意的，而且通机器学习的分类能够分类出重打包和非重打包的嘛？感觉机器学习和深度学习的方式都是用来分类恶意软件得，因为恶意的软件一定会添加恶意的组件或者是调用恶意的权限。 对权限进行排名也是一种很好的方式，这样的话可以避免某些请求频率低的权限的影响，因为要是重打包的应用程序可能会添加更多的权限调用，但是这个权限的调用只用了一两次。 参考文章：W. Wang, X. Wang, D. Feng, J. Liu, Z. Han, and X. Zhang, “Exploring permission-induced risk in Android applications for malicious application detection,” IEEE Trans. Inf. Forensics Security, vol. 9, no. 11,pp. 1869–1882, Nov. 2014. 程序依赖图中能不能去燥，比如某些个只调用了一次或者是只出现了一次的调用？或者是类的调用也可以啊，就是每一个对象会new很多次的，只实例化了一次的那种直接给他去除，认定为是噪声代码。？？？？？关于去噪声的方法我觉得可以参考下文章4，他里面就是寻找了最主要的特征。 设计一个系统先粗粒度，然后细粒度检测，细粒度检测一般比较耗时间，粗粒度检测完成之后只需要检测粗粒度判定为可疑的应用即可。这样的话其实就是减少了一部分的细粒度的检测时间。具体粗粒度的检测方法是用什么还有细粒度用什么还得具体去考虑。 程序依赖图的话可以只分析某一些函数，比如说使用了API的，使用了组件的，使用了权限的，使用了其他的一些，因为他添加噪声代码的话一般是添加无用的代码，因为要是添加一些组件什么的肯定会导致成本增加，而且会导致程序运行的问题和程序的不相似性。还有就是可以分析UI函数的依赖关系图，因为要是为了保持重打包的吸引性，外观一般不会改变很大。其实也就是说分析其核心函数的调用依赖，核心函数怎么定义的呢，就是系统关键部分的东西，同时去除第三方库和Android库。这个第三方库影响很大的，因为有一些很小的软件自己的代码可能很少，绝大部分都是第三方库的，这样的话太容易误判了。罗宾的那篇文章中的第一个基于目录的方式就是那样子的，没有过滤第三方库。 分析完成之后，看一下漏报的应用的特征，是不是都是具有一类或几类典型特征的应用被漏报或者是误报了，然后返回来优化自己的模型。 工具 Pscout：敏感权限获取 LibD第三方广告库名单软件，并且有手动验证过准确性。]]></content>
      <categories>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>文献阅读</tag>
        <tag>安卓重打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之访问者模式]]></title>
    <url>%2F2018%2F10%2F18%2FVistorPattern%2F</url>
    <content type="text"><![CDATA[设计模式之访问者模式1. 什么是访问者模式 Visitor模式也叫访问者模式，是行为模式之一，它分离对象的数据和行为，使用Visitor模式，可以不修改已有类的情况下，增加新的操作。 换句话说就是访问者模式就是说对于一组对象，在不改变数据结构的前提下，增加作用于这些结构元素新的功能。适用于数据结构相对稳定，它把数据结构和作用于其上的操作解耦，使得操作集合可以相对自由地演化。 访问者模式的结构： 访问者角色（Visitor）：为该对象结构中具体元素角色声明一个访问操作接口。该操作接口的名字和参数标识了发送访问请求给具体访问者的具体元素角色。这样访问者就可以通过该元素角色的特定接口直接访问它。 具体访问者角色（Concrete Visitor）：实现每个由访问者角色（Visitor）声明的操作。 元素角色（Element）：定义一个Accept操作，它以一个访问者为参数。 具体元素角色（Concrete Element）：实现由元素角色提供的Accept操作。 对象结构角色（Object Structure）： 这是使用访问者模式必备的角色。它要具备以下特征：能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个复合（组合模式）或是一个集合，如一个列表或一个无序集合。 优缺点： 优点： 符合单一职责原则 扩展性良好 有益于系统的管理和维护 缺点： 增加新的元素类变得很困难 破坏封装性，就是访问者需要知道一些类的数据结构，这些类的数据结构就暴露给了访问者。 适用场合： 如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的 注意事项： 系统有比较稳定的数据结构，数据结构不断更新的话访问者也就需要不断的修改。 与迭代器的关系，迭代器就是提供访问者的一种注入的方式，访问者需要对对象进行处理，迭代器就是访问，不管他是怎么处理的，但是访问者就是注重对对象的处理的。 2. 具体实例雇员管理系统，每个员工都有自己的信息，有大家都一样的，也有每个人不一样的。例如每个人的工资，入职时间，工作年限等等。现在雇员管理系统遇到的问题，需要添加一些新的操作功能。那怎么设计呢？ 我们想就是两个类，就是员工类和员工管理类，然后实现这些功能。但是当一个人的工资要涨了，休假的时间要变长了，或者要添加新的季度绩效这个评价指标，那就得去修改员工类和管理类。我们这里可以利用访问者模式来设计，就是使用访问者把变化的东西抽象出来，然后从员工类和员工管理类中获取进行处理显示。 设计的结构类图如下： 就是抽象一个vistor的访问者接口，然后由具体的访问者去实现，因为访问者可能有很多个，所以就设计一个接口。 然后在具体的员工中有一个accept方法，将vistor注入进来，然后员工类把自己传给vistor进行处理，这种双向传递是很有意思的。 看一下具体的代码实现： 员工的抽象类： 123public abstract class Element &#123; abstract public void Accept(Visitor visitor);&#125; 因为可能不只有员工这一个类，所以为了能够使访问者能够统一管理就设计一个基类，然后访问者可以管理实现这个基类的所有子类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Employee extends Element &#123; private String name; private float income; private int vacationDays; private int degree; public Employee(String name, float income, int vacationDays, int degree) &#123; this.name = name; this.income = income; this.vacationDays = vacationDays; this.degree = degree; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setIncome(float income) &#123; this.income = income; &#125; public float getIncome() &#123; return income; &#125; public void setVacationDays(int vacationDays) &#123; this.vacationDays = vacationDays; &#125; public int getVacationDays() &#123; return vacationDays; &#125; public void setDegree(int degree) &#123; this.degree = degree; &#125; public int getDegree() &#123; return degree; &#125; @Override public void Accept(Visitor visitor) &#123; // TODO Auto-generated method stub visitor.Visit(this); &#125;&#125; 通过public void Accept(Visitor visitor) 把自己传给访问者。 12345678910111213141516171819202122232425public class Employees &#123; private HashMap&lt;String, Employee&gt; employees; public Employees() &#123; employees = new HashMap(); &#125; public void Attach(Employee employee) &#123; employees.put(employee.getName(), employee); &#125; public void Detach(Employee employee) &#123; employees.remove(employee); &#125; public Employee getEmployee(String name) &#123; return employees.get(name); &#125; public void Accept(Visitor visitor) &#123; for (Employee e : employees.values()) &#123; e.Accept(visitor); &#125; &#125;&#125; 员工管理类通过遍历的方式把所有的员工都传给了访问者。 访问者 123public interface Visitor &#123; abstract public void Visit(Element element);&#125; 具体的访问者： 1234567891011public class CompensationVisitor implements Visitor &#123; @Override public void Visit(Element element) &#123; // TODO Auto-generated method stub Employee employee = ((Employee) element); System.out.println(employee.getName() + "'s Compensation is " + (employee.getDegree() * employee.getVacationDays() * 10)); &#125;&#125; 通过一个强制类型转换就把Element基类转换成具体实现的子类。 测试类： 1234567891011public class MainTest &#123; public static void main(String[] args) &#123; Employees mEmployees = new Employees(); mEmployees.Attach(new Employee("Tom", 4500, 8, 1)); mEmployees.Attach(new Employee("Jerry", 6500, 10, 2)); mEmployees.Attach(new Employee("Jack", 9600, 12, 3)); mEmployees.Accept(new CompensationVisitor()); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式 访问者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之模板方法模式]]></title>
    <url>%2F2018%2F10%2F18%2FTemplateMethod%2F</url>
    <content type="text"><![CDATA[设计模式之模板方法模式1. 什么是模板方法模式Template Method模式也叫模板方法模式，是行为模式之一，它把具有特定步骤算法中的某些必要的处理委让给抽象方法，通过子类继承对抽象方法的不同实现改变整个算法的行为。换句话说就是在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中去具体实现。 一般的应用场景： Template Method模式一般应用在具有以下条件的应用中： 具有统一的操作步骤或操作过程 具有不同的操作细节 存在多个具有同样操作步骤的应用场景，但某些具体的操作细节却各不相同 模板方法模式的结构： AbstractClass：抽象类的父类 ConcreteClass：具体的实现子类 templateMethod()：模板方法 method1()与method2()：具体步骤方法 hook()其实AbstractClass里面还应该有hook这个方法，这个方法是在抽象类中实现了，但是可以在继承的子类中进行改动 2. 具体的实例假设我们是星巴克的师傅，有一个训练手册，我们需要设计冲泡方法就是咖啡的冲泡方法和茶的冲泡方法 咖啡的冲泡方法：烧水，沸水冲泡，咖啡倒进杯子，最后是加糖和牛奶 茶的冲泡方法：烧水，沸水冲泡，茶倒进杯子，最后是加柠檬 对于上面的项目首先我们一开始的设计想法一般是定义两个类分别实现各自的流程呗。但是我们看到这两个类中是有重复的方法的，比如烧水，冲泡，然后我们就想可以把这两个方法拿出来，作为公共的方法。这样的话就又解耦合了一些。最后我们想饮料倒进杯子和加调料是两个抽象的方法定义在一个抽象类中，然后有各自的类去继承和个性化定制。这样我们就完成了整个的设计，这个过程其实就是模板模式的应用。 具体的代码实现： 模板类： 12345678910111213141516171819202122public abstract class HotDrink &#123; public final void prepareRecipe()&#123; boilWater(); brew(); pourIncup(); addCondiments(); &#125; private void boilWater()&#123; System.out.println("boil water"); &#125; public abstract void brew(); private void pourIncup()&#123; System.out.println("pour in cup"); &#125; public abstract void addCondiments();&#125; 1234567891011public class Coffee extends HotDrink &#123; @Override public void brew() &#123; System.out.println("brew coffee"); &#125; @Override public void addCondiments() &#123; System.out.println("add sugar and milk"); &#125;&#125; 1234567891011public class Tea extends HotDrink &#123; @Override public void brew() &#123; System.out.println("brew tea"); &#125; @Override public void addCondiments() &#123; System.out.println("add lemon"); &#125;&#125; 123456789public class MainTest &#123; public static void main(String[] args)&#123; HotDrink drinkTea = new Tea(); drinkTea.prepareRecipe(); HotDrink drinkCoffee = new Coffee(); drinkCoffee.prepareRecipe(); &#125;&#125; 这样我们就使用模板方法模式完成了设计。 其实还可以通过对模板方法进行挂钩。钩子是一种被声明在抽象类中的方法，但是只有空的或者是默认的实现，其实就是让我们自己来进行个性化扩展的。 对上面的例子我们来进行钩子方式的扩展。 12345678910111213141516171819202122232425262728293031public abstract class HotDrinkWithHook &#123; public final void prepareRecipe()&#123; boilWater(); brew(); pourIncup(); if (WantCondimentsHook())&#123; addCondiments(); &#125;else &#123; System.out.println("No Condiments"); &#125; &#125; public boolean WantCondimentsHook()&#123; return true; &#125; private void boilWater()&#123; System.out.println("boil water"); &#125; public abstract void brew(); private void pourIncup()&#123; System.out.println("pour in cup"); &#125; public abstract void addCondiments();&#125; 1234567891011121314151617181920212223242526272829303132public class TeaWithHook extends HotDrinkWithHook &#123; @Override public void brew() &#123; System.out.println("brew tea"); &#125; @Override public void addCondiments() &#123; System.out.println("add lemon"); &#125; @Override public boolean WantCondimentsHook()&#123; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); System.out.println("Would you like add milk and sugar in your coffee (y/n)"); try&#123; String str = bufferedReader.readLine(); if (str.equals("y"))&#123; return true; &#125;else if (str.equals("n"))&#123; return false; &#125;else &#123; System.out.println("you have input nothing"); return false; &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; return false; &#125;&#125; 通过上面的实例我们发现其实模板方法模式就是封装了一个算法步骤，并允许子类为一个或多个步骤方法提供实现，模板模式可以使子类在不改变算法结构的情况下，重新定义算法的某些步骤。 其实java中的Comparable接口就是一个模板方法模式设计的，我们可以自己设计个性化方法compareTo()方法。然后使用sort方法就可以实现排序了。 还有一个经典的例子就是Swing的窗口，我们一般写Swing的时候，会使用JFrame,就是那个最基本的Swing容器，使用JFrame的时候我们会继承paint()方法，默认他是不做任何事情的，他就是一个hook(),也就是我们可以自己定制的个性化方法。这里其实就是用的模板方法模式设计的。 3. 好莱坞原则《Head First 设计模式》上是这样给的定义：你别调用我们，我们会调用你。怎么理解呢？其实就是有的时候高层组件会依赖低层组件，低层组件又依赖高层组件，然后高层组件又依赖边侧组件，边侧组件又依赖低层组件，反正就是乱七八糟的依赖，导致发生了依赖腐败的问题。在好莱坞原则下呢我们允许低层组件挂钩到系统上，但是什么时候使用和怎么使用这些低层组件是由高层组件决定的。换句话就是高层组件对待低层组件的方式就是你别调用我们，我们会调用你。 4. 模板方法模式和策略模式的差异其实模板方法模式和策略模式还是有点相似的，但是也是有一定的差异的. 模板方法模式是抽象一个子类中的步骤方法，个别的步骤是可以有不同的实现的，而策略模式是将一类方法封装成算法族。 模板方法模式是通过继承实现的，而策略模式是通过对象组合的方式实现的。 模板方法模式的超类是抽象的，而且必须依赖于超类中的方法的实现，而策略模式不依赖于任何人，整个算法可以由他自己搞定。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之状态模式]]></title>
    <url>%2F2018%2F10%2F18%2FStateMode%2F</url>
    <content type="text"><![CDATA[设计模式之状态模式1. 什么是状态模式 State模式也叫状态模式，是行为设计模式的一种。State模式允许通过改变对象的内部状态而改变对象的行为，这个对象表现得就好像修改了它的类一样。 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转译到表现不同状态的一系列类当中，可以把复杂的判断逻辑简化。 Context：用户对象拥有一个State类型的成员，以标识对象的当前状态； State：接口或基类封装与Context的特定状态相关的行为； ConcreteState：接口实现类或子类实现了一个与Context某个状态相关的行为。 2. 具体实例智能糖果机，用Java软件控制糖果机，他有以下几个动作： 待机、投入一元硬币、转动把手、滑落一颗糖果、待机（根据机器内糖果库存情况，是否提示售罄）。 传统的设计怎么设计呢？很容易想到，我们就把糖果机封装成一个类，然后里面有具体的状态函数，在不同的状态函数中去判断和更新状态。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public class CandyMachine &#123; final static int SoldOutState = 0; final static int OnReadyState = 1; final static int HasCoin = 2; final static int SoldState = 3; private int state = SoldOutState; private int count = 0; public CandyMachine(int count) &#123; this.count = count; if (count &gt; 0) &#123; state = OnReadyState; &#125; &#125; public void insertCoin() &#123; switch (state) &#123; case SoldOutState: System.out.println("you can't insert coin,the machine sold out!"); break; case OnReadyState: state = HasCoin; System.out .println("you have inserted a coin,next,please turn crank!"); break; case HasCoin: System.out.println("you can't insert another coin!"); break; case SoldState: System.out.println("please wait!we are giving you a candy!"); break; &#125; &#125; public void returnCoin() &#123; switch (state) &#123; case SoldOutState: System.out .println("you can't return,you haven't inserted a coin yet!"); break; case OnReadyState: System.out.println("you haven't inserted a coin yet!"); break; case HasCoin: System.out.println("coin return!"); state = OnReadyState; break; case SoldState: System.out.println("sorry,you already have turned the crank!"); break; &#125; &#125; public void turnCrank() &#123; switch (state) &#123; case SoldOutState: System.out.println("you turned,but there are no candies!"); break; case OnReadyState: System.out.println("you turned,but you haven't inserted a coin!"); break; case HasCoin: System.out.println("crank turn...!"); state = SoldState; dispense(); break; case SoldState: System.out .println("we are giving you a candy,turning another get nothing,!"); break; &#125; &#125; private void dispense() &#123; count = count - 1; System.out.println("a candy rolling out!"); if (count &gt; 0) &#123; state = OnReadyState; &#125; else &#123; System.out.println("Oo,out of candies"); state = SoldOutState; &#125; &#125; public void printstate() &#123; switch (state) &#123; case SoldOutState: System.out.println("***SoldOutState***"); break; case OnReadyState: System.out.println("***OnReadyState***"); break; case HasCoin: System.out.println("***HasCoin***"); break; case SoldState: System.out.println("***SoldState***"); break; &#125; &#125;&#125; 这种设计没有什么问题吧，可以实现现有的需要。但是现在有了新的需求了，糖果机有新的功能要添加，比如有一个幸运功能，当转到幸运功能时会给出更多的糖果，对于这个功能我们可以在上面的类中去添加，然后更改每一个方法，这样做的话其实不符合开闭原则了。我们的上面设计其实是面向功能来做的，而我们应该做的是面向接口去编程，实现对修改封闭，对扩展开放。 根据上面的想法，我们想这个项目中什么是改变的，什么是不变的呢？其实动作是不变的，就那几个动作，然后状态是改变的，我们就把改变的地方抽取出来然后设计成接口，由具体的状态去扩展继承。 类图如下： 我们想状态模式能根据内部状态的变化，改变对象的行为，看起来好像修改了类。上面的设计就是根据这种模式设计的。我们把改变的状态抽象出来，然后取让行为跟着状态变化。 具体的代码实现： 状态接口： 1234567public interface State &#123; public void insertCoin(); public void returnCoin(); public void turnCrank(); public void dispense(); public void printstate();&#125; 具体的状态： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HasCoin implements State &#123; private CandyMachine mCandyMachine; public HasCoin(CandyMachine mCandyMachine) &#123; this.mCandyMachine = mCandyMachine; &#125; @Override public void insertCoin() &#123; // TODO Auto-generated method stub System.out.println("you can't insert another coin!"); &#125; @Override public void returnCoin() &#123; // TODO Auto-generated method stub System.out.println("coin return!"); mCandyMachine.setState(mCandyMachine.mOnReadyState); &#125; @Override public void turnCrank() &#123; // TODO Auto-generated method stub System.out.println("crank turn...!"); Random ranwinner=new Random(); int winner=ranwinner.nextInt(10); if(winner==0) &#123; mCandyMachine.setState(mCandyMachine.mWinnerState); &#125;else &#123; mCandyMachine.setState(mCandyMachine.mSoldState); &#125; &#125; @Override public void dispense() &#123; &#125; @Override public void printstate() &#123; // TODO Auto-generated method stub System.out.println("***HasCoin***"); &#125;&#125; 其他的状态同理。。。 糖果机： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class CandyMachine &#123; State mSoldOutState; State mOnReadyState; State mHasCoin; State mSoldState; State mWinnerState; private State state; private int count = 0; public CandyMachine(int count) &#123; this.count = count; mSoldOutState = new SoldOutState(this); mOnReadyState = new OnReadyState(this); mHasCoin = new HasCoin(this); mSoldState = new SoldState(this); mWinnerState = new WinnerState(this); if (count &gt; 0) &#123; state = mOnReadyState; &#125; else &#123; state = mSoldOutState; &#125; &#125; public void setState(State state) &#123; this.state = state; &#125; public void insertCoin() &#123; state.insertCoin(); &#125; public void returnCoin() &#123; state.returnCoin(); &#125; public void turnCrank() &#123; state.turnCrank(); state.dispense(); &#125; void releaseCandy() &#123; // TODO Auto-generated method stub if (count &gt; 0) &#123; count = count - 1; System.out.println("a candy rolling out!"); &#125; &#125; public int getCount() &#123; return count; &#125; public void printstate() &#123; state.printstate(); &#125;&#125; 在糖果机这个类中我们只需要初始化所有的State，然后在具体的行为中去使用state下的行为。其实也就是内部状态的变化改变了对象的行为。 测试类： 123456789101112131415161718192021public class MainTest &#123; public static void main(String[] args) &#123; CandyMachine mCandyMachine = new CandyMachine(6); mCandyMachine.printstate(); mCandyMachine.insertCoin(); mCandyMachine.printstate(); mCandyMachine.turnCrank(); mCandyMachine.printstate(); mCandyMachine.insertCoin(); mCandyMachine.printstate(); mCandyMachine.turnCrank(); mCandyMachine.printstate(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2F2018%2F10%2F18%2FProxyMode%2F</url>
    <content type="text"><![CDATA[设计模式之代理模式1. 什么是代理模式Proxy模式又叫做代理模式，是构造型的设计模式之一，它可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。 所谓代理，是指具有与代理元（被代理的对象）具有相同的接口的类，客户端必须通过代理与被代理的目标类交互，而代理一般在交互的过程中（交互前后），进行某些特别的处理。 代理模式为一个对象提供一个替身，以控制对这个对象的访问被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象代理模式有很多变体，都是为了控制与管理对象访问 代理模式的一般结构： subject（抽象主题角色）：真实主题与代理主题的共同接口。 RealSubject（真实主题角色）：定义了代理角色所代表的真实对象。 Proxy（代理主题角色）：含有对真实主题角色的引用，代理角色通常在将客户端调用传递给真是主题对象之前或者之后执行某些操作，而不是单纯返回真实的对象。 动态代理： InvocationHandler 接口 invoke方法 Proxy.newProxyInstance(); 代理模式和装饰者模式差异:装饰者模式，装饰以后会添加新功能，而代理模式目的是对目标对象访问的控制和管理。 2. 具体实例对于在状态模式中介绍的糖果机项目，我们现在要添加一个监控糖果机：监控糖果机的地点、糖果库存和当前状态。这时候我们使用远程代理的模式来设计这个项目是合适的。通过代理模式获取远程对象（糖果机）的本地代表，通过它可以让远程对象当本地对象来调用。这样就相当于在本地查看糖果机的状态了。 可以使用JAVA的RMI来实现远程代理： RMI的结构图： RMI远程方法调用是计算机之间通过网络实现对象调用的一种通讯机制。使用这种机制，一台计算机上的对象可以调用另外 一台计算机上的对象来获取远程数据。 在过去，TCP/IP通讯是远程通讯的主要手段，面向过程的开发。而RPC使程序员更容易地调用远程程序，但在面对复杂的信息传讯时，RPC依然未能很好的支持。 RMI被设计成一种面向对象开发方式，允许程序员使用远程对象来实现通信。 RMI的实现步骤： 制作远程接口：接口文件 远程接口的实现：Service文件 RMI服务端注册，开启服务 RMI代理端通过RMI查询到服务端，建立联系，通过接口调用远程方法 通过上面的步骤，实现一个简单的JavaRMI 的实例： 远程接口： 12345public interface MyRemote extends Remote&#123; public String sayHello() throws RemoteException; &#125; 接口的实现： 12345678910111213141516171819202122232425public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote&#123; protected MyRemoteImpl() throws RemoteException &#123; super(); // TODO Auto-generated constructor stub &#125; @Override public String sayHello() throws RemoteException &#123; // TODO Auto-generated method stub return "Hello World!"; &#125; public static void main(String[] args) &#123; try &#123; MyRemote service=new MyRemoteImpl(); // LocateRegistry.createRegistry(6600); Naming.rebind("rmi://127.0.0.1:6600/RemoteHello", service); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println( e.toString()); &#125; &#125;&#125; 12345678910111213141516171819public class MyRemoteClient &#123; public static void main(String[] args) &#123; new MyRemoteClient().go(); &#125; public void go() &#123; try &#123; MyRemote service=(MyRemote)Naming.lookup("rmi://127.0.0.1:6600/RemoteHello"); String s=service.sayHello(); System.out.println(s); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 然后通过使用RMI怎么来实现上面所讲的糖果机的项目呢？具体代码如下： 接口： 12345public interface CandyMachineRemote extends Remote&#123; public String getLocation() throws RemoteException; public int getCount() throws RemoteException; public State getstate() throws RemoteException;&#125; 接口的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class CandyMachine extends UnicastRemoteObject implements CandyMachineRemote &#123; State mSoldOutState; State mOnReadyState; State mHasCoin; State mSoldState; State mWinnerState; private String location=""; private State state; private int count = 0; public CandyMachine(String location,int count) throws RemoteException&#123; this.location=location; this.count = count; mSoldOutState = new SoldOutState(this); mOnReadyState = new OnReadyState(this); mHasCoin = new HasCoin(this); mSoldState = new SoldState(this); mWinnerState = new WinnerState(this); if (count &gt; 0) &#123; state = mOnReadyState; &#125; else &#123; state = mSoldOutState; &#125; &#125; public String getLocation() &#123; return location; &#125; public void setState(State state) &#123; this.state = state; &#125; public void insertCoin() &#123; state.insertCoin(); &#125; public void returnCoin() &#123; state.returnCoin(); &#125; public void turnCrank() &#123; state.turnCrank(); state.dispense(); &#125; void releaseCandy() &#123; // TODO Auto-generated method stub if (count &gt; 0) &#123; count = count - 1; System.out.println("a candy rolling out!"); &#125; &#125; public int getCount() &#123; return count; &#125; public void printstate() &#123; state.printstate(); &#125; public State getstate() &#123; return state; &#125;&#125; 注册： 1234567891011121314151617181920212223242526272829303132public class Monitor &#123; private ArrayList&lt;CandyMachineRemote&gt; candyMachinelst; public Monitor() &#123; candyMachinelst = new ArrayList&lt;CandyMachineRemote&gt;(); &#125; public void addMachine(CandyMachineRemote mCandyMachine) &#123; candyMachinelst.add(mCandyMachine); &#125; public void report() &#123; CandyMachineRemote mCandyMachine; for (int i = 0, len = candyMachinelst.size(); i &lt; len; i++) &#123; mCandyMachine = candyMachinelst.get(i); try &#123; System.out .println("Machine Loc:" + mCandyMachine.getLocation()); System.out.println("Machine Candy count:" + mCandyMachine.getCount()); System.out.println("Machine State:" + mCandyMachine.getstate().getstatename()); &#125; catch (RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 123456789101112131415161718public class RemoteMainTest &#123; public static void main(String[] args) &#123; try &#123; CandyMachine service = new CandyMachine("test1", 7); // LocateRegistry.createRegistry(6602); Naming.rebind("rmi://127.0.0.1:6602/test1", service); service.insertCoin(); service = new CandyMachine("test2", 5); Naming.rebind("rmi://127.0.0.1:6602/test2", service); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.toString()); &#125; &#125;&#125; 测试： 123456789101112131415161718192021public class MainTest &#123; public static void main(String[] args) &#123; Monitor mMonitor = new Monitor(); try &#123; CandyMachineRemote mCandyMachine = (CandyMachineRemote) Naming .lookup("rmi://127.0.0.1:6602/test1"); mMonitor.addMachine(mCandyMachine); mCandyMachine = (CandyMachineRemote) Naming .lookup("rmi://127.0.0.1:6602/test2"); mMonitor.addMachine(mCandyMachine); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; mMonitor.report(); &#125;&#125; 3. 几种其他常见的代理模式 虚拟代理： 虚拟代理为创建开销大的对象提供代理服务。真正的对象在创建前和创建中时，由虚拟代理来扮演替身。例如手机加载图片，一开始是个模糊的，加载完成才显示清楚，开始就就是本地代理的显示。 动态代理：运行时动态的创建代理类，并将方法调用转发到指定类 保护代理：这种代理用于对真实对象的功能做一些访问限制, 在代理层做身份验证. 通过了验证, 才调用真实的主体对象的相应方法. 几种变体：、防火墙代理、缓存代理、智能引用代理、同步代理、写入时复制代理 关于保护代理和动态代理的使用举一个简单的例子： 一个相亲网的项目，每个人都有自己的信息和评分，评分别人可以评价自己不能评价，个人信息自己可以修改别人只能查看。 具体的代码： 接口： 1234567891011public interface PersonBean &#123; String getName(); String getGender(); String getInterests(); int getHotOrNotRating(); void setName(String name); void setGender(String gender); void setInterests(String interests); void setHotOrNotRating(int rating);&#125; 接口的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class PersonBeanImpl implements PersonBean&#123; String name; String gender; String interests; int rating; int ratingcount=0; @Override public String getName() &#123; // TODO Auto-generated method stub return name; &#125; @Override public String getGender() &#123; // TODO Auto-generated method stub return gender; &#125; @Override public String getInterests() &#123; // TODO Auto-generated method stub return interests; &#125; @Override public int getHotOrNotRating() &#123; // TODO Auto-generated method stub if(ratingcount==0) return 0; return (rating/ratingcount); &#125; @Override public void setName(String name) &#123; // TODO Auto-generated method stub this.name=name; &#125; @Override public void setGender(String gender) &#123; // TODO Auto-generated method stub this.gender=gender; &#125; @Override public void setInterests(String interests) &#123; // TODO Auto-generated method stub this.interests=interests; &#125; @Override public void setHotOrNotRating(int rating) &#123; // TODO Auto-generated method stub this.rating=rating; ratingcount++; &#125;&#125; 非本人代理 123456789101112131415161718192021222324252627public class NonOwnerInvocationHandler implements InvocationHandler&#123; PersonBean person; public NonOwnerInvocationHandler(PersonBean person) &#123; this.person=person; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // TODO Auto-generated method stub if(method.getName().startsWith("get")) &#123; return method.invoke(person,args); &#125;else if(method.getName().equals("setHotOrNotRating")) &#123; return method.invoke(person,args); &#125;else if(method.getName().startsWith("set")) &#123; return new IllegalAccessException(); &#125; return null; &#125;&#125; 本人代理 1234567891011121314151617181920212223242526public class OwnerInvocationHandler implements InvocationHandler&#123; PersonBean person; public OwnerInvocationHandler(PersonBean person) &#123; this.person=person; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // TODO Auto-generated method stub if(method.getName().startsWith("get")) &#123; return method.invoke(person,args); &#125;else if(method.getName().equals("setHotOrNotRating")) &#123; return new IllegalAccessException(); &#125;else if(method.getName().startsWith("set")) &#123; return method.invoke(person,args); &#125; return null; &#125;&#125; 调用代理方法的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MatchService &#123; public MatchService() &#123; PersonBean joe = getPersonInfo("joe", "male", "running"); PersonBean OwnerProxy = getOwnerProxy(joe); System.out.println("Name is " + OwnerProxy.getName()); System.out.println("Interests is " + OwnerProxy.getInterests()); OwnerProxy.setInterests("Bowling"); System.out.println("Interests are " + OwnerProxy.getInterests()); OwnerProxy.setHotOrNotRating(50); System.out.println("Rating is " + OwnerProxy.getHotOrNotRating()); OwnerProxy.setHotOrNotRating(40); System.out.println("Rating is " + OwnerProxy.getHotOrNotRating()); System.out.println("**************"); PersonBean nonOwnerProxy = getNonOwnerProxy(joe); System.out.println("Name is " + nonOwnerProxy.getName()); System.out.println("Interests are " + nonOwnerProxy.getInterests()); nonOwnerProxy.setInterests("haha"); System.out.println("Interests are " + nonOwnerProxy.getInterests()); nonOwnerProxy.setHotOrNotRating(60); System.out.println("Rating is " + nonOwnerProxy.getHotOrNotRating()); &#125; PersonBean getPersonInfo(String name, String gender, String interests) &#123; PersonBean person = new PersonBeanImpl(); person.setName(name); person.setGender(gender); person.setInterests(interests); return person; &#125; PersonBean getOwnerProxy(PersonBean person) &#123; return (PersonBean) Proxy.newProxyInstance(person.getClass() .getClassLoader(), person.getClass().getInterfaces(), new OwnerInvocationHandler(person)); &#125; PersonBean getNonOwnerProxy(PersonBean person) &#123; return (PersonBean) Proxy.newProxyInstance(person.getClass() .getClassLoader(), person.getClass().getInterfaces(), new NonOwnerInvocationHandler(person)); &#125;&#125; 测试类： 123456public class MainTest &#123; public static void main(String[] args) &#123; MatchService mMatchService=new MatchService(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之原型模式]]></title>
    <url>%2F2018%2F10%2F18%2FPrototypePattern%2F</url>
    <content type="text"><![CDATA[设计模式之原型模式1. 什么是原型模式Prototype模式是一种对象创建型模式，它采取复制原型对象的方法来创建对象的实例。使用Prototype模式创建的实例，具有与原型一样的数据。 换句话说原型模式就是通过复制现有实例来创建新的实例，无须知道相应类的信息。 原型模式的结构： 优缺点： 优点： 使用原型模式创建对象比直接new一个对象更有效，因为他是直接对内存进行拷贝，数据对象的内容就全部都有了，不需要重新创建内存区域重新实例化赋值这些操作了，这样的话速度能够快很多。 隐藏制造新实例的复杂性 重复地创建相似对象时可以考虑使用原型模式 缺点： 每一个类必须配备一个克隆方法 深层复制比较复杂 特点： 由原型对象自身创建目标对象。也就是说，对象创建这一动作发自原型对象本身。 目标对象是原型对象的一个克隆。也就是说，通过Prototype模式创建的对象，不仅仅与原型对象具有相同的结构，还与原型对象具有相同的值。 根据对象克隆深度层次的不同，有浅度克隆与深度克隆。 适用场合： 复制对象的结构与数据 希望对目标对象的修改不影响既有的原型对象 创建对象成本较大的情况下 在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。 希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响） 隐藏克隆操作的细节。很多时候，对对象本身的克隆需要涉及到类本身的数据细节。 使用时注意事项： 使用原型模式复制对象不会调用类的构造方法。所以，单例模式与原型模式是冲突的，在使用时要特别注意。 Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。 2. 具体实例：银行的电子账单、广告信需要你群发邮件，特点：量大、时间要求紧。 想一下这个怎么实现，其实简单的想法就是邮件类，邮件模板类，发送邮件类这样三个函数，然后使用多线程给每个线程分配一个邮件的对象进行发送。这样的话的缺点就是需要实例化很多的对象，实例化对象的时候会有类的初始化赋值这一类的操作，速度慢，然后我们想就是因为每一封邮件是类似的，只是发送的人姓名什么的不同，我们直接拷贝对象，直接从内存中拷贝对象的话对象的信息都有然后重新进行修改，省下了new的整个过程，速度快很多。 设计的类图： 其实从图中看不出具体的原型模式是怎么回事。看一下具体的代码; 12345678910111213141516public class EventTemplate &#123; private String eventSubject, eventContent; public EventTemplate(String eventSubject, String eventContent) &#123; this.eventSubject = eventSubject; this.eventContent = eventContent; &#125; public String geteventSubject() &#123; return eventSubject; &#125; public String geteventContent() &#123; return eventContent; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Mail implements Cloneable &#123; private String receiver; private String subject; private String content; private String tail; private ArrayList&lt;String&gt; ars; public Mail(EventTemplate et) &#123; this.tail = et.geteventContent(); this.subject = et.geteventSubject(); &#125; @Override public Mail clone() &#123; Mail mail = null; try &#123; mail = (Mail) super.clone(); mail.ars = (ArrayList&lt;String&gt;)this.ars.clone(); &#125; catch (CloneNotSupportedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return mail; &#125; public String getReceiver() &#123; return receiver; &#125; public void setReceiver(String receiver) &#123; this.receiver = receiver; &#125; public String getSubject() &#123; return subject; &#125; public void setSubject(String subject) &#123; this.subject = subject; &#125; public void setContent(String content) &#123; this.content = content; &#125; public String getContent() &#123; return content; &#125; public String getTail() &#123; return tail; &#125; public void setTail(String tail) &#123; this.tail = tail; &#125;&#125; Mail这个类实现了Cloneable，继承了public Mail clone() {}这个方法，用来实现对象的拷贝。 1234567891011121314151617181920212223242526272829303132333435363738public class MainTest &#123; public static void main(String[] args) &#123; int i = 0; int MAX_COUNT = 10; EventTemplate et = new EventTemplate("9月份信用卡账单", "国庆抽奖活动..."); Mail mail = new Mail(et); while (i &lt; MAX_COUNT) &#123; // 以下是每封邮件不同的地方 Mail cloneMail = mail.clone(); cloneMail.setContent(getRandString(5) + ",先生（女士）:你的信用卡账单..." + mail.getTail()); cloneMail.setReceiver(getRandString(5) + "@" + getRandString(8) + ".com"); // 然后发送邮件 sendMail(cloneMail); i++; &#125; &#125; public static String getRandString(int maxLength) &#123; String source = "abcdefghijklmnopqrskuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; StringBuffer sb = new StringBuffer(); Random rand = new Random(); for (int i = 0; i &lt; maxLength; i++) &#123; sb.append(source.charAt(rand.nextInt(source.length()))); &#125; return sb.toString(); &#125; public static void sendMail(Mail mail) &#123; System.out.println("标题：" + mail.getSubject() + "\t收件人：" + mail.getReceiver() + "\t内容：" + mail.getContent() + "\t....发送成功！"); &#125;&#125; 在测试类中每次发不同的邮件时都会Mail cloneMail = mail.clone();就是对象的复制。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之备忘录模式]]></title>
    <url>%2F2018%2F10%2F18%2FMementoPattern%2F</url>
    <content type="text"><![CDATA[设计模式之备忘录模式1. 什么是备忘录模式备忘录模式就是说在不破坏封装的前提下，存储关键对象的重要状态，从而可以在将来把对象还原到存储的那个状态。 备忘录模式的结构： 如果一个对象需要保存状态并可通过undo或rollback等操作恢复到以前的状态时，可以使用Memento模式。 Originator（原生者）需要被保存状态以便恢复的那个对象。 Memento（备忘录）该对象由Originator创建，主要用来保存Originator的内部状态。 Caretaker（管理者）负责在适当的时间保存/恢复Originator对象的状态。 具体的就是说： 一个类需要保存它的对象的状态（相当于Originator角色） 设计一个类，该类只是用来保存上述对象的状态（相当于Memento角色） 需要的时候，Caretaker角色要求Originator返回一个Memento并加以保存 undo或rollback操作时，通过Caretaker保存的Memento恢复Originator对象的状态 优缺点： 优点： 状态存储在外面，不和关键对象混在一起，这可以帮助维护内聚 提供了容易实现的恢复能力 保持了关键对象的数据封装 缺点： 资源消耗上面备忘录对象会很昂贵 存储和恢复状态的过程比较耗时 2. 具体实例游戏进度保存：对象状态，场景…然后一个游戏中或者团队中有很多人要保存进度，然后每个人保存的进度必须是独立的，读取的时候也是只能自己读取自己的状态，这个时候我们就使用备忘录模式来设计。设计的类图如下： 就是先设计一个备忘录的接口，然后由具体的发起者去实现和扩展这个接口，当发起者需要保存状态时就创建一个备忘录然后交给Caretaker（管理者）去管理，读取的时候直接从管理者那里读取，并且只能读取到自己的状态。 看一下具体的代码实现： 备忘录的接口:空的，因为这个例子中没有什么要实现的，具体的都要发起者中自己个性化实现了。 123public interface MementoIF &#123;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Originator &#123; private HashMap&lt;String, String&gt; state; public Originator() &#123; state = new HashMap(); &#125; public MementoIF createMemento() &#123; return new Memento(state); &#125; public void restoreMemento(MementoIF memento) &#123; state = ((Memento) memento).getState(); &#125; public void showState() &#123; System.out.println("now state:" + state.toString()); &#125; public void testState1() &#123; state.put("blood", "500"); state.put("progress", "gate1 end"); state.put("enemy", "5"); &#125; public void testState2() &#123; state.put("blood", "450"); state.put("progress", "gate3 start"); state.put("enemy", "3"); &#125; private class Memento implements MementoIF &#123; private HashMap&lt;String, String&gt; state; private Memento(HashMap state) &#123; this.state = new HashMap(state); &#125; private HashMap getState() &#123; return state; &#125; private void setState(HashMap state) &#123; this.state = state; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Originator2 &#123; private ArrayList&lt;String&gt; state; public Originator2() &#123; state = new ArrayList&lt;String&gt;(); &#125; public MementoIF createMemento() &#123; return new Memento(state); &#125; public void restoreMemento(MementoIF memento) &#123; state = ((Memento) memento).getState(); &#125; public void testState1() &#123; state = new ArrayList&lt;String&gt;(); state.add("blood:320"); state.add("progress:gate2 mid"); state.add("enemy:15"); &#125; public void testState2() &#123; state = new ArrayList&lt;String&gt;(); state.add("blood:230"); state.add("progress:gate8 last"); state.add("enemy:12"); &#125; public void showState() &#123; System.out.println("now state:" + state.toString()); &#125; private class Memento implements MementoIF &#123; private ArrayList&lt;String&gt; state; private Memento(ArrayList&lt;String&gt; state) &#123; this.state = new ArrayList(state); &#125; private ArrayList&lt;String&gt; getState() &#123; return state; &#125; private void setState(ArrayList&lt;String&gt; state) &#123; this.state = state; &#125; &#125;&#125; 备忘录的管理者 123456789101112131415161718public class MementoCaretaker &#123; private HashMap&lt;String, MementoIF&gt; mementomap; public MementoCaretaker() &#123; mementomap = new HashMap&lt;String, MementoIF&gt;(); &#125; public MementoIF retrieveMemento(String name) &#123; return mementomap.get(name); &#125; /** * 备忘录赋值方法 */ public void saveMemento(String name, MementoIF memento) &#123; this.mementomap.put(name, memento); &#125;&#125; 测试类： 1234567891011121314151617181920212223242526272829303132333435public class MainTest &#123; public static void main(String[] args) &#123; MementoCaretaker mMementoCaretaker = new MementoCaretaker(); Originator mOriginator = new Originator(); Originator2 mOriginator2 = new Originator2(); System.out.println("*****Originator*****"); mOriginator.testState1(); mMementoCaretaker .saveMemento("Originator", mOriginator.createMemento()); mOriginator.showState(); mOriginator.testState2(); mOriginator.showState(); mOriginator.restoreMemento(mMementoCaretaker .retrieveMemento("Originator")); mOriginator.showState(); System.out.println("*****Originator 2*****"); mOriginator2.testState1(); mOriginator2.showState(); mMementoCaretaker.saveMemento("Originator2", mOriginator2.createMemento()); mOriginator2.testState2(); mOriginator2.showState(); mOriginator2.restoreMemento(mMementoCaretaker .retrieveMemento("Originator2")); mOriginator2.showState(); //System.out.println("*****Originator&amp;&amp;Originator 2*****"); //mOriginator.restoreMemento(mMementoCaretaker //.retrieveMemento("Originator2")); //mOriginator.showState(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>备忘录模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之迭代器模式]]></title>
    <url>%2F2018%2F10%2F18%2FIteratorMode%2F</url>
    <content type="text"><![CDATA[设计模式之迭代器模式1. 什么是迭代器模式Iterator模式也叫迭代模式，是行为模式之一，它把对容器中包含的内部对象的访问委让给外部类，使用Iterator（遍历）按顺序进行遍历访问的设计模式。 在应用Iterator模式之前，首先应该明白Iterator模式用来解决什么问题。或者说，如果不使用 Iterator模式，会存在什么问题： 由容器自己实现顺序遍历。直接在容器类里直接添加顺序遍历方法 让调用者自己实现遍历。直接暴露数据细节给外部。 以上方法1与方法2都可以实现对遍历，这样有问题呢？ 容器类承担了太多功能：一方面需要提供添加删除等本身应有的功能；一方面还需要提供遍历访问功能。 往往容器在实现遍历的过程中，需要保存遍历状态，当跟元素的添加删除等功能夹杂在一起，很容易引起混乱和程序运行错误等。 迭代器模式的一般应用： Iterator模式就是为了有效地处理按顺序进行遍历访问的一种设计模式，简单地说，Iterator模式提供一种有效的方法，可以屏蔽聚集对象集合的容器类的实现细节，而能对容器内包含的对象元素按顺序进行有效的遍历访问。 所以，Iterator模式的应用场景可以归纳为满足以下几个条件： 访问容器中包含的内部对象 按顺序访问 迭代器模式的结构： Iterator（迭代器接口）：该接口必须定义实现迭代功能的最小定义方法集比如提供hasNext()和next()方法。这是所有的迭代器必须要实现的方法，可以使用java内置的Iterator也可以自己个性化定制 ConcreteIterator（迭代器实现类）：迭代器接口Iterator的实现类。可以根据具体情况加以实现。 Aggregate（容器接口）：定义基本功能以及提供类似Iterator iterator()的方法； concreteAggregate（容器实现类）：容器接口的实现类。必须实现Iterator iterator()方法。 优点： 实现功能分离，简化容器接口。让容器只实现本身的基本功能，把迭代功能委让给外部类实现，符合类的设计原则。 隐藏容器的实现细节。 为容器或其子容器提供了一个统一接口，一方面方便调用；另一方面使得调用者不必关注迭代器的实现细节。 可以为容器或其子容器实现不同的迭代方法或多个迭代方法。 2.1具体实例举一个具体的例子吧，xain’z现在有两家餐厅要合并，合并之后呢需要把菜单统一合并，形成一个统一的菜单，在打印的时候呢能够全部打印出来。 首先的设计想法呢就是每一个餐厅设计一个自己的菜单的类，但是自己在设计的时候使用的是不同的数据结构实现的这个菜单类，这样子的话其实在写一个专门的类似于打印的类，然后实例化两个餐厅然后打印出来。这样的话就是我要再合并一个餐厅的时候需要更改这个类。比较麻烦，所以我们就需要使用迭代器模式来设计这个项目。使用迭代器的话就很容易解耦餐厅和打印菜单之间的耦合关系。具体是怎么实现呢？ 首先需要实现一个迭代器的接口： 12345public interface Iterator &#123; public boolean hasNext(); public Object next();&#125; 然后具体的类去扩展实现它： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ublic class DinerMenu &#123; private final static int Max_Items = 5; private int numberOfItems = 0; private MenuItem[] menuItems; public DinerMenu() &#123; menuItems = new MenuItem[Max_Items]; addItem("vegetable Blt", "bacon&amp;lettuce&amp;tomato&amp;cabbage", true, 3.58f); addItem("Blt", "bacon&amp;lettuce&amp;tomato", false, 3.00f); addItem("bean soup", "bean&amp;potato salad", true, 3.28f); addItem("hotdog", "onions&amp;cheese&amp;bread", false, 3.05f); &#125; private void addItem(String name, String description, boolean vegetable, float price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetable, price); if (numberOfItems &gt;= Max_Items) &#123; System.err.println("sorry,menu is full!can not add another item"); &#125; else &#123; menuItems[numberOfItems] = menuItem; numberOfItems++; &#125; &#125; public Iterator getIterator() &#123; return new DinerIterator(); &#125; class DinerIterator implements Iterator &#123; private int position; public DinerIterator() &#123; position = 0; &#125; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub if (position &lt; numberOfItems) &#123; return true; &#125; return false; &#125; @Override public Object next() &#123; // TODO Auto-generated method stub MenuItem menuItem = menuItems[position]; position++; return menuItem; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class CakeHouseMenu &#123; private ArrayList&lt;MenuItem&gt; menuItems; public CakeHouseMenu() &#123; menuItems = new ArrayList&lt;MenuItem&gt;(); addItem("KFC Cake Breakfast","boiled eggs&amp;toast&amp;cabbage",true,3.99f); addItem("MDL Cake Breakfast","fried eggs&amp;toast",false,3.59f); addItem("Stawberry Cake","fresh stawberry",true,3.29f); addItem("Regular Cake Breakfast","toast&amp;sausage",true,2.59f); &#125; private void addItem(String name, String description, boolean vegetable, float price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetable, price); menuItems.add(menuItem); &#125; public Iterator getIterator() &#123; return new CakeHouseIterator() ; &#125; class CakeHouseIterator implements Iterator &#123; private int position=0; public CakeHouseIterator() &#123; position=0; &#125; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub if(position&lt;menuItems.size()) &#123; return true; &#125; return false; &#125; @Override public Object next() &#123; // TODO Auto-generated method stub MenuItem menuItem =menuItems.get(position); position++; return menuItem; &#125;&#125;; //其他功能代码 &#125; 最后就是具体的合并之后的打印类： 1234567891011121314151617181920212223242526272829303132333435363738public class Waitress &#123; private ArrayList&lt;Iterator&gt; iterators=new ArrayList&lt;Iterator&gt;(); public Waitress() &#123; &#125; public void addIterator(Iterator iterator) &#123; iterators.add(iterator); &#125; public void printMenu() &#123; Iterator iterator; MenuItem menuItem; for (int i = 0, len = iterators.size(); i &lt; len; i++) &#123; iterator = iterators.get(i); while(iterator.hasNext()) &#123; menuItem=(MenuItem) iterator.next(); System.out.println(menuItem.getName() + "***" +menuItem.getPrice()+"***"+ menuItem.getDescription()); &#125; &#125; &#125; public void printBreakfastMenu() &#123; &#125; public void printLunchMenu() &#123; &#125; public void printVegetableMenu() &#123; &#125;&#125; 测试类： 1234567891011public class MainTest &#123; public static void main(String[] args) &#123; Waitress mWaitress=new Waitress(); CakeHouseMenu mCakeHouseMenu = new CakeHouseMenu(); DinerMenu mDinerMenu = new DinerMenu(); mWaitress.addIterator(mCakeHouseMenu.getIterator()); mWaitress.addIterator(mDinerMenu.getIterator()); mWaitress.printMenu(); &#125;&#125; 上面的方式其实是我们自己写了一个迭代器，其实java有内置的迭代器，我们用过collection的就知道，遍历的时候就是使用的Iterator。 上面的扩展实现Iterator的类使用java内置的Iterator怎么来做呢？ 首先是： DinerMenu，因为他的菜单是数组实现的，没有内置的迭代器，所以还是需要我们自己继承内置的迭代器然后自己扩展实现一个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class DinerMenu &#123; private final static int Max_Items = 5; private int numberOfItems = 0; private MenuItem[] menuItems; public DinerMenu() &#123; menuItems = new MenuItem[Max_Items]; addItem("vegetable Blt", "bacon&amp;lettuce&amp;tomato&amp;cabbage", true, 3.58f); addItem("Blt", "bacon&amp;lettuce&amp;tomato", false, 3.00f); addItem("bean soup", "bean&amp;potato salad", true, 3.28f); addItem("hotdog", "onions&amp;cheese&amp;bread", false, 3.05f); &#125; private void addItem(String name, String description, boolean vegetable, float price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetable, price); if (numberOfItems &gt;= Max_Items) &#123; System.err.println("sorry,menu is full!can not add another item"); &#125; else &#123; menuItems[numberOfItems] = menuItem; numberOfItems++; &#125; &#125; public Iterator getIterator() &#123; return new DinerIterator(); &#125; class DinerIterator implements Iterator &#123; private int position = 0; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub if (position &lt; numberOfItems) &#123; return true; &#125; position = 0; return false; &#125; @Override public Object next() &#123; // TODO Auto-generated method stub MenuItem menuItem = menuItems[position]; position++; return menuItem; &#125; @Override public void remove() &#123; // TODO Auto-generated method stub &#125; &#125;&#125; CakeHouseMenu的菜单是由 ArrayList，java内的 ArrayList是有Iterator的直接使用就可以了。 12345678910111213141516171819202122232425262728public class CakeHouseMenu &#123; private ArrayList&lt;MenuItem&gt; menuItems; private int position=0; public CakeHouseMenu() &#123; menuItems = new ArrayList&lt;MenuItem&gt;(); addItem("KFC Cake Breakfast","boiled eggs&amp;toast&amp;cabbage",true,3.99f); addItem("MDL Cake Breakfast","fried eggs&amp;toast",false,3.59f); addItem("Stawberry Cake","fresh stawberry",true,3.29f); addItem("Regular Cake Breakfast","toast&amp;sausage",true,2.59f); &#125; private void addItem(String name, String description, boolean vegetable, float price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetable, price); menuItems.add(menuItem); &#125; public Iterator getIterator() &#123; return menuItems.iterator(); &#125; //其他功能代码 &#125; 看了上面的迭代器，之后next方法，那我要是访问前一个的时候怎么办，有没有previous的方法，当你自己个性化实现迭代器的时候是可以实现的，你添加两个方法，一个是获取前一个元素，一个是告诉你是否到达了最前面。然后Java的Collection FrameWork提供了另一种迭代器接口ListIterator,这个接口里面就是那个previous的方法，可以访问前一个元素。 3. 单一责任原则单一责任原则就是：一个类应该只有一个引起变化的原因。 实现单一责任原则的话，在维护和修改代码的时候更加容易，因为每一个类只承担了一种责任，修改的该类的区域可能也就只有一组，但是很多种责任聚合在一块儿的话就修改的区域就会很多，并且你会感觉自己改的是乱起八糟的。 内聚是一个比单一责任原则更加普遍的概念，它用来度量一个类或模块紧密地达到单一目的或责任。当一个模块被设计的只支持一组相关功能的时候就是高内聚的，当被设计成支持一组不相关的功能的时候就是低内聚的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之解释器模式]]></title>
    <url>%2F2018%2F10%2F18%2FInterpreterPattern%2F</url>
    <content type="text"><![CDATA[设计模式之解释器模式1. 什么是解释器模式 Interpreter模式也叫解释器模式，是行为模式之一，它是一种特殊的设计模式，它建立一个解释器，对于特定的计算机程序设计语言，用来解释预先定义的文法。简单地说，Interpreter模式是一种简单的语法解释器构架。 换一种解释就是定义一个语法, 定义一个解释器，该解释器处理该语法句子将某些复杂问题，表达为某种语法规则，然后构建解释器来解释处理这类句子。 解释器模式的结构： Context：解释器上下文环境类。用来存储解释器的上下文环境，比如需要解释的文法等。 AbstractExpression：解释器抽象类。 ConcreteExpression：解释器具体实现类。 优缺点： 优点： 容易修改，修改语法规则只要修改相应非终结符即可 扩展方便，扩展语法，只要增加非终结符类即可 缺点： 对于复杂语法的表示会产生复杂的类层次结构，不便管理和维护 解释器采用递归方式，效率会受影响 一般的适用场景： 当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好： 该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。 效率不是一个关键问题，最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。 使用时的注意事项： 尽量不要在重要的模块中使用解释器模式 解释器模式在实际的系统开发中使用的非常少 可以考虑一下Expression4J、MESP、Jep等开源的解析工具包 2. 具体的实例有一个大数据的项目，大数据统计项目遇到了问题： 按照计算模型对现有数据统计、分析、预测，一般的计算模型是一个或多个运算公式，通常是加减乘除四则运算，设计方案要有高扩展性。 计算模型的设计： 计算模型按正常算术方式书写，解释器处理语法逻辑 计算模型里有两类符号：数据和计算符 用逆波兰算法分析算式语法 用解释器模式处理数据。 这里项目中其实就是要使用解释器来计算符号公式。 解释的意思就是用一种方式或语法来执行他。 项目设计的类图如下所示： .png) 具体的代码如下： AbstractExpresstion:抽象表达式： 123public abstract class AbstractExpresstion &#123; public abstract Float interpreter(HashMap&lt;String, Float&gt; var);&#125; VarExpresstion: 123456789101112131415public class VarExpresstion extends AbstractExpresstion &#123; private String key; public VarExpresstion(String _key) &#123; this.key = _key; &#125; @Override public Float interpreter(HashMap&lt;String, Float&gt; var) &#123; // TODO Auto-generated method stub return var.get(this.key); &#125;&#125; 具体的”加减乘除“运算符： 12345678910111213public class AddExpresstion extends SymbolExpresstion &#123; public AddExpresstion(AbstractExpresstion _left, AbstractExpresstion _right) &#123; super(_left, _right); // TODO Auto-generated constructor stub &#125; @Override public Float interpreter(HashMap&lt;String, Float&gt; var) &#123; // TODO Auto-generated method stub return super.left.interpreter(var) + super.right.interpreter(var); &#125;&#125; 12345678910111213public class SubExpresstion extends SymbolExpresstion &#123; public SubExpresstion(AbstractExpresstion _left, AbstractExpresstion _right) &#123; super(_left, _right); // TODO Auto-generated constructor stub &#125; @Override public Float interpreter(HashMap&lt;String, Float&gt; var) &#123; // TODO Auto-generated method stub return super.left.interpreter(var) - super.right.interpreter(var); &#125;&#125; 1234567891011121314public class MultiExpresstion extends SymbolExpresstion &#123; public MultiExpresstion(AbstractExpresstion _left, AbstractExpresstion _right) &#123; super(_left, _right); // TODO Auto-generated constructor stub &#125; @Override public Float interpreter(HashMap&lt;String, Float&gt; var) &#123; // TODO Auto-generated method stub return super.left.interpreter(var) * super.right.interpreter(var); &#125;&#125; 12345678910111213public class DivExpresstion extends SymbolExpresstion &#123; public DivExpresstion(AbstractExpresstion _left, AbstractExpresstion _right) &#123; super(_left, _right); // TODO Auto-generated constructor stub &#125; @Override public Float interpreter(HashMap&lt;String, Float&gt; var) &#123; // TODO Auto-generated method stub return super.left.interpreter(var) / super.right.interpreter(var); &#125;&#125; 逆波兰实现,具体就是统一的实现运算的，让计算表达式转换成为逆波兰表达式，然后可以实现按运算符运算顺序规则的运算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150public class RPN &#123; private ArrayList&lt;String&gt; expression = new ArrayList&lt;String&gt;();// 存储中序表达式 private ArrayList&lt;String&gt; right = new ArrayList&lt;String&gt;();// 存储右序表达式 private AbstractExpresstion result;// 结果 // 依据输入信息创建对象，将数值与操作符放入ArrayList中 public RPN(String input) &#123; StringTokenizer st = new StringTokenizer(input, "+-*/()", true); while (st.hasMoreElements()) &#123; expression.add(st.nextToken()); &#125; &#125; // 将中序表达式转换为右序表达式 private void toRight() &#123; Stacks aStack = new Stacks(); String operator; int position = 0; while (true) &#123; if (Calculate.isOperator((String) expression.get(position))) &#123; if (aStack.top == -1 || ((String) expression.get(position)).equals("(")) &#123; aStack.push(expression.get(position)); &#125; else &#123; if (((String) expression.get(position)).equals(")")) &#123; if (!((String) aStack.top()).equals("(")) &#123; operator = (String) aStack.pop(); right.add(operator); &#125; &#125; else &#123; if (Calculate.priority((String) expression .get(position)) &lt;= Calculate .priority((String) aStack.top()) &amp;&amp; aStack.top != -1) &#123; operator = (String) aStack.pop(); if (!operator.equals("(")) right.add(operator); &#125; aStack.push(expression.get(position)); &#125; &#125; &#125; else right.add(expression.get(position)); position++; if (position &gt;= expression.size()) break; &#125; while (aStack.top != -1) &#123; operator = (String) aStack.pop(); right.add(operator); &#125; &#125; // 对右序表达式进行求值 public void getResult(HashMap&lt;String, Float&gt; var) &#123; this.toRight(); Stack&lt;AbstractExpresstion&gt; stack = new Stack&lt;AbstractExpresstion&gt;(); AbstractExpresstion op1, op2; String is = null; Iterator it = right.iterator(); while (it.hasNext()) &#123; is = (String) it.next(); if (Calculate.isOperator(is)) &#123; op2 = stack.pop(); op1 = stack.pop(); stack.push(Calculate.twoResult(is, op1, op2)); &#125; else stack.push(new VarExpresstion(is)); &#125; result = stack.pop(); it = expression.iterator(); while (it.hasNext()) &#123; System.out.print((String) it.next()); &#125; System.out.println("=" + result.interpreter(var)); &#125; public static class Calculate &#123; // 判断是否为操作符号 public static boolean isOperator(String operator) &#123; if (operator.equals("+") || operator.equals("-") || operator.equals("*") || operator.equals("/") || operator.equals("(") || operator.equals(")")) return true; else return false; &#125; // 设置操作符号的优先级别 public static int priority(String operator) &#123; if (operator.equals("+") || operator.equals("-") || operator.equals("(")) return 1; else if (operator.equals("*") || operator.equals("/")) return 2; else return 0; &#125; // 做2值之间的计算 public static AbstractExpresstion twoResult(String op, AbstractExpresstion a, AbstractExpresstion b) &#123; try &#123; AbstractExpresstion result = null; if (op.equals("+")) result = new AddExpresstion(a, b); else if (op.equals("-")) result = new SubExpresstion(a, b); else if (op.equals("*")) result = new MultiExpresstion(a, b); else if (op.equals("/")) result = new DivExpresstion(a, b); else ; return result; &#125; catch (NumberFormatException e) &#123; System.out.println("input has something wrong!"); return null; &#125; &#125; &#125; // 栈类 public class Stacks &#123; private LinkedList list = new LinkedList(); int top = -1; public void push(Object value) &#123; top++; list.addFirst(value); &#125; public Object pop() &#123; Object temp = list.getFirst(); top--; list.removeFirst(); return temp; &#125; public Object top() &#123; return list.getFirst(); &#125; &#125;&#125; 底部的计算器： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Calculator &#123; public Calculator() &#123; float[][] dataSource = new float[3][6]; System.out.println("data source:"); for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 6; j++) &#123; dataSource[i][j] = (float) (Math.random() * 100); System.out.print(dataSource[i][j] + ","); &#125; System.out.println(";"); &#125; try &#123; System.out.println("Input a expression:"); BufferedReader is = new BufferedReader(new InputStreamReader( System.in)); for (;;) &#123; String input = new String(); input = is.readLine().trim(); if (input.equals("q")) break; else &#123; RPN boya = new RPN(input); HashMap&lt;String, Float&gt; var; for (int i = 0; i &lt; 3; i++) &#123; var = new HashMap&lt;String, Float&gt;(); var.put("a", dataSource[i][0]); var.put("b", dataSource[i][1]); var.put("c", dataSource[i][2]); var.put("d", dataSource[i][3]); var.put("e", dataSource[i][4]); var.put("f", dataSource[i][5]); boya.getResult(var); &#125; &#125; System.out .println("Input another expression or input 'q' to quit:"); &#125; is.close(); &#125; catch (IOException e) &#123; System.out.println("Wrong input!!!"); &#125; &#125;&#125; 测试类： 1234567public class MainTest &#123; public static void main(String[] args) &#123; new Calculator(); &#125;&#125; 看一下输出吧，就是实现了表达式的运算： .png)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>解释器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之中介者模式]]></title>
    <url>%2F2018%2F10%2F18%2FMediatorPattern%2F</url>
    <content type="text"><![CDATA[设计模式之中介者模式1. 什么是中介者模式Mediator模式也叫中介者模式，是由GoF提出的23种软件设计模式的一种。Mediator模式是行为模式之一，在Mediator模式中，类之间的交互行为被统一放在Mediator的对象中，对象通过Mediator对象同其他对象交互，Mediator对象起着控制器的作用。 中介者模式就是用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 中介者模式的结构： mediator中介者类的抽象父类。 concreteMediator具体的中介者类。 colleague关联类的抽象父类。 concreteColleague具体的关联类。 优缺点： 优点： 通过将对象彼此解耦，可以增加对象的复用性 通过将控制逻辑集中，可以简化系统维护 可以让对象之间所传递的消息变得简单而且大幅减少 提高系统的灵活性，使得系统易于扩展和维护 缺点： 中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响 如果设计不当，中介者对象本身变得过于复杂 适用场合： 一组对象之间的通信方式比较复杂，导致相互依赖，结构混乱 一个对象引用很多其他对象并直接与这些对象通信，导致难以复用该对象 2. 具体实例智慧房屋公司的产品：闹钟、咖啡机、电视机、窗帘等，相互之间需要通信，比如闹钟到什么时候需要通知电视机干什么，通知窗帘干什么，咖啡机要通知窗帘干什么。 这样对象之间需要相互的通信，会形成复杂的网络结构，并且以后想要添加新的设备对象时需要与他进行交互的对象全部需要修改，也就是说这些通信的对象之间的耦合度很高。不利于维护和扩展。 所以这里引入中介者模式来设计这个项目，类图如下： 对象之间的通信通过中介者来进行处理，而且每个对象只需要知道中介者就可以了，不需要了解他要通知的对象，这件事请交给中介者去干。这样设计的好处就是对象之间的耦合度降低了，并且添加新的对象的时候只需要与中介者进行交互，不需要改动每一个对象。 具体的代码实现： 中介者接口： 1234567public interface Mediator &#123; public abstract void Register(String colleagueName, Colleague colleague); public abstract void GetMessage(int stateChange, String colleagueName); public abstract void SendMessage();&#125; 具体的中介者实现，也就是在中介者中统筹管理设备之间的通信： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ConcreteMediator implements Mediator &#123; private HashMap&lt;String, Colleague&gt; colleagueMap; private HashMap&lt;String, String&gt; interMap; public ConcreteMediator() &#123; colleagueMap = new HashMap&lt;String, Colleague&gt;(); interMap = new HashMap&lt;String, String&gt;(); &#125; @Override public void Register(String colleagueName, Colleague colleague) &#123; // TODO Auto-generated method stub colleagueMap.put(colleagueName, colleague); // TODO Auto-generated method stub if (colleague instanceof Alarm) &#123; interMap.put("Alarm", colleagueName); &#125; else if (colleague instanceof CoffeeMachine) &#123; interMap.put("CoffeeMachine", colleagueName); &#125; else if (colleague instanceof TV) &#123; interMap.put("TV", colleagueName); &#125; else if (colleague instanceof Curtains) &#123; interMap.put("Curtains", colleagueName); &#125; &#125; @Override public void GetMessage(int stateChange, String colleagueName) &#123; // TODO Auto-generated method stub if (colleagueMap.get(colleagueName) instanceof Alarm) &#123; if (stateChange == 0) &#123; ((CoffeeMachine) (colleagueMap.get(interMap .get("CoffeeMachine")))).StartCoffee(); ((TV) (colleagueMap.get(interMap.get("TV")))).StartTv(); &#125; else if (stateChange == 1) &#123; ((TV) (colleagueMap.get(interMap.get("TV")))).StopTv(); &#125; &#125; else if (colleagueMap.get(colleagueName) instanceof CoffeeMachine) &#123; ((Curtains) (colleagueMap.get(interMap.get("Curtains")))) .UpCurtains(); &#125; else if (colleagueMap.get(colleagueName) instanceof TV) &#123; &#125; else if (colleagueMap.get(colleagueName) instanceof Curtains) &#123; &#125; &#125; @Override public void SendMessage() &#123; // TODO Auto-generated method stub &#125;&#125; 具体的设备的抽象类： 1234567891011121314151617public abstract class Colleague &#123; private Mediator mediator; public String name; public Colleague(Mediator mediator, String name) &#123; this.mediator = mediator; this.name = name; &#125; public Mediator GetMediator() &#123; return this.mediator; &#125; public abstract void SendMessage(int stateChange);&#125; 设备实现类： 123456789101112131415161718public class Alarm extends Colleague &#123; public Alarm(Mediator mediator, String name) &#123; super(mediator, name); // TODO Auto-generated constructor stub mediator.Register(name, this); &#125; public void SendAlarm(int stateChange) &#123; SendMessage(stateChange); &#125; @Override public void SendMessage(int stateChange) &#123; // TODO Auto-generated method stub this.GetMediator().GetMessage(stateChange, this.name); &#125;&#125; 12345678910111213141516171819202122232425public class CoffeeMachine extends Colleague &#123; public CoffeeMachine(Mediator mediator, String name) &#123; super(mediator, name); // TODO Auto-generated constructor stub mediator.Register(name, this); &#125; @Override public void SendMessage(int stateChange) &#123; // TODO Auto-generated method stub this.GetMediator().GetMessage(stateChange, this.name); &#125; public void StartCoffee() &#123; System.out.println("It's time to startcoffee!"); &#125; public void FinishCoffee() &#123; System.out.println("After 5 minutes!"); System.out.println("Coffee is ok!"); SendMessage(0); &#125;&#125; 123456789101112131415161718192021222324public class TV extends Colleague &#123; public TV(Mediator mediator, String name) &#123; super(mediator, name); // TODO Auto-generated constructor stub mediator.Register(name, this); &#125; @Override public void SendMessage(int stateChange) &#123; // TODO Auto-generated method stub this.GetMediator().GetMessage(stateChange, this.name); &#125; public void StartTv() &#123; // TODO Auto-generated method stub System.out.println("It's time to StartTv!"); &#125; public void StopTv() &#123; // TODO Auto-generated method stub System.out.println("StopTv!"); &#125;&#125; 123456789101112131415161718public class Curtains extends Colleague &#123; public Curtains(Mediator mediator, String name) &#123; super(mediator, name); // TODO Auto-generated constructor stub mediator.Register(name, this); &#125; @Override public void SendMessage(int stateChange) &#123; // TODO Auto-generated method stub this.GetMediator().GetMessage(stateChange, this.name); &#125; public void UpCurtains() &#123; System.out.println("I am holding Up Curtains!"); &#125;&#125; 测试类： 123456789101112131415public class MainTest &#123; public static void main(String[] args) &#123; Mediator mediator = new ConcreteMediator(); Alarm mAlarm = new Alarm(mediator, "mAlarm"); CoffeeMachine mCoffeeMachine = new CoffeeMachine(mediator, "mCoffeeMachine"); Curtains mCurtains = new Curtains(mediator, "mCurtains"); TV mTV = new TV(mediator, "mTV"); mAlarm.SendAlarm(0); mCoffeeMachine.FinishCoffee(); mAlarm.SendAlarm(1); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>中介者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之享元模式（蝇量模式）]]></title>
    <url>%2F2018%2F10%2F18%2FFlyweightPattern%2F</url>
    <content type="text"><![CDATA[设计模式之享元模式（蝇量模式）1. 什么是享元模式Flyweight模式也叫享元模式，是构造型模式之一，它通过与其他类似对象共享数据来减小内存占用。 换句话说就是通过共享的方式高效地支持大量细粒度的对象。 享元模式的结构： 享元模式的角色和职责： 抽象享元角色：所有具体享元类的父类，规定一些需要实现的公共接口。 具体享元角色：抽象享元角色的具体实现类，并实现了抽象享元角色规定的方法。 享元工厂角色：负责创建和管理享元角色。 优缺点： 优点： 减少运行时的对象实例个数，节省创建开销和内存 将许多“虚拟”对象的状态集中管理 缺点： 系统设计更加复杂 需要专门维护对象的外部状态 适用场合： 需要大量细粒度对象 这些对象的外部状态不多 按照内部状态分成几个组，每一个组都仅用一个蝇量对象代替 2. 具体实例我们有一个景观设计软件项目： 需要布置很多的树：XY坐标，树的大小，外观 假如需要10000000棵树，我们该怎么设计呢？ 首先的想法就是抽象一个树的类，然后使用的时候初始化10000000个树的实例。 按照这种方式具体的实现一下： 12345678910111213public class Tree &#123; private int xCoord, yCoord, age; public Tree(int xCoord, int yCoord, int age) &#123; this.xCoord = xCoord; this.yCoord = yCoord; this.age = age; &#125; public void display() &#123; // System.out.print("x"); &#125;&#125; 12345678910111213141516171819public class TreesTest &#123; private int length = 10000000; private Tree[] treelst = new Tree[length]; public TreesTest() &#123; for (int i = 0; i &lt; length; i++) &#123; treelst[i] = new Tree((int) (Math.random() * length), (int) (Math.random() * length), (int) (Math.random() * length) % 5); &#125; &#125; public void display() &#123; for (int i = 0, len = treelst.length; i &lt; len; i++) &#123; treelst[i].display(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930public class MainTest &#123; public static void main(String[] args) &#123; showMemInfo(); TreesTest mTreesTest; mTreesTest = new TreesTest(); showMemInfo(); mTreesTest.display(); showMemInfo(); &#125; public static void showMemInfo() &#123; // 最大内存： long max = Runtime.getRuntime().maxMemory(); // 分配内存： long total = Runtime.getRuntime().totalMemory(); // 已分配内存中的剩余空间 ： long free = Runtime.getRuntime().freeMemory(); // 已占用的内存： long used = total - free; System.out.println("最大内存 = " + max); System.out.println("已分配内存 = " + total); System.out.println("已分配内存中的剩余空间 = " + free); System.out.println("已用内存 = " + used); System.out.println("时间 = " + System.currentTimeMillis()); System.out.println(""); &#125;&#125; 看一下运行的结果吧 最大内存 = 926941184 已分配内存 = 64487424 已分配内存中的剩余空间 = 62465304 已用内存 = 2022120 时间 = 1539587641214 最大内存 = 926941184 已分配内存 = 361234432 已分配内存中的剩余空间 = 79750928 已用内存 = 281483504 时间 = 1539587644567 最大内存 = 926941184 已分配内存 = 361234432 已分配内存中的剩余空间 = 79750928 已用内存 = 281483504 时间 = 1539587644583 我们这时候发现我们需要多少的树就要new出多少个树的对象，占用内存。 看一下树这个类，他的有些状态是共享的，如display这个方法，每一个树的显示都是一样的，然后像具体的坐标和年龄这个信息都相当于外部的状态，每一个都是不同的，我们可以设计一个新的类来管理这些信息，然后在实例化树的对象的时候就只需要实例化一个，然后每个树得信息从管理类中获取。那个管理的类中其实就是虚拟化了很多的树的类。这其实就是享元模式的设计思想，把相似的对象的数据进行共享。 看下具体的实现： 123456789public class TreeFlyWeight &#123; public TreeFlyWeight() &#123; &#125; public void display(int xCoord, int yCoord, int age) &#123; // System.out.print("x"); &#125;&#125; 12345678910111213141516171819202122232425262728public class TreeManager &#123; private int length = 10000000; int[] xArray = new int[length], yArray = new int[length], AgeArray = new int[length]; private TreeFlyWeight mTreeFlyWeight; public TreeManager() &#123; mTreeFlyWeight = new TreeFlyWeight(); for (int i = 0; i &lt; length; i++) &#123; xArray[i] = (int) (Math.random() * length); yArray[i] = (int) (Math.random() * length); AgeArray[i] = (int) (Math.random() * length) % 5; &#125; &#125; public void displayTrees() &#123; for (int i = 0; i &lt; length; i++) &#123; mTreeFlyWeight.display(xArray[i], yArray[i], AgeArray[i]); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class MainTest &#123; public static void main(String[] args) &#123; showMemInfo(); TreeManager mTreeManager; mTreeManager = new TreeManager(); showMemInfo(); mTreeManager.displayTrees(); showMemInfo(); &#125; public static void showMemInfo() &#123; // 已分配内存中的剩余空间 ： long free = Runtime.getRuntime().freeMemory(); // 分配内存： long total = Runtime.getRuntime().totalMemory(); // 最大内存： long max = Runtime.getRuntime().maxMemory(); // 已占用的内存： long used = total - free; System.out.println("最大内存 = " + max); System.out.println("已分配内存 = " + total); System.out.println("已分配内存中的剩余空间 = " + free); System.out.println("已用内存 = " + used); System.out.println("时间 = " + System.currentTimeMillis()); System.out.println(""); &#125;&#125; 看一下运行结果： 最大内存 = 926941184 已分配内存 = 64487424 已分配内存中的剩余空间 = 62465304 已用内存 = 2022120 时间 = 1539588509988 最大内存 = 926941184 已分配内存 = 145227776 已分配内存中的剩余空间 = 22870040 已用内存 = 122357736 时间 = 1539588510873 最大内存 = 926941184 已分配内存 = 145227776 已分配内存中的剩余空间 = 22870040 已用内存 = 122357736 时间 = 1539588510881 通过比较发现内存被占用变小了，运行时间变小了。 其实享元模式就是通过共享细粒度对象的数据减少对象的数据的初始化或者是减少实例对象的创建。 再看一个更加复杂一点的例子。就是上面的景观项目，我不只要栽树，还要栽花。 这时候使用享元模式的设计的类图如下所示： 我们把草和树都抽象成为了一个plant的类，然后使用PlantManager来统一管理外部状态数据。但是有人说当我需要放置雕像的时候怎么办呢？那就直接把雕像单独作为一个类，然后抽象一个manager来做统一的管理。以后每添加一个对象要是可以抽象成为一组的就抽象，不能抽象成为一组的就直接单独成为一类。 看一下具体的代码实现： 12345678public class Tree extends Plant &#123; @Override public void display(int xCoord, int yCoord, int age) &#123; // TODO Auto-generated method stub // System.out.print("Tree x"); &#125;&#125; 12345678public class Grass extends Plant &#123; @Override public void display(int xCoord, int yCoord, int age) &#123; // TODO Auto-generated method stub // System.out.print("Grass x"); &#125;&#125; 12345678public abstract class Plant &#123; public Plant() &#123; &#125; public abstract void display(int xCoord, int yCoord, int age);&#125; 12345678910111213141516171819202122232425public class PlantManager &#123; private int length = 10000000; private int[] xArray = new int[length], yArray = new int[length], AgeArray = new int[length], typeArray = new int[length]; private PlantFactory mPlantFactory; public PlantManager() &#123; mPlantFactory=new PlantFactory(); for (int i = 0; i &lt; length; i++) &#123; xArray[i] = (int) (Math.random() * length); yArray[i] = (int) (Math.random() * length); AgeArray[i] = (int) (Math.random() * length) % 5; typeArray[i]= (int) (Math.random() * length) % 2; &#125; &#125; public void displayTrees() &#123; for (int i = 0; i &lt; length; i++) &#123; mPlantFactory.getPlant(typeArray[i]).display(xArray[i], yArray[i], AgeArray[i]); &#125; &#125;&#125; 12345678910111213141516171819202122232425public class PlantFactory &#123; private HashMap&lt;Integer, Plant&gt; plantMap = new HashMap&lt;Integer, Plant&gt;(); public PlantFactory() &#123; &#125; public Plant getPlant(int type) &#123; if (!plantMap.containsKey(type)) &#123; switch (type) &#123; case 0: plantMap.put(0, new Tree()); break; case 1: plantMap.put(1, new Grass()); break; &#125; &#125; return plantMap.get(type); &#125;&#125; PlantFactory是用来管理和获取具体的plant类型的。 12345678910111213141516171819202122232425262728293031323334public class MainTest &#123; public static void main(String[] args) &#123; showMemInfo(); PlantManager mPlantManager; mPlantManager = new PlantManager(); showMemInfo(); mPlantManager.displayTrees(); showMemInfo(); &#125; public static void showMemInfo() &#123; // 已分配内存中的剩余空间 ： long free = Runtime.getRuntime().freeMemory(); // 分配内存： long total = Runtime.getRuntime().totalMemory(); // 最大内存： long max = Runtime.getRuntime().maxMemory(); // 已占用的内存： long used = total - free; System.out.println("最大内存 = " + max); System.out.println("已分配内存 = " + total); System.out.println("已分配内存中的剩余空间 = " + free); System.out.println("已用内存 = " + used); System.out.println("时间 = " + System.currentTimeMillis()); System.out.println(""); &#125;&#125; 看一下测试类的结果： 最大内存 = 926941184 已分配内存 = 64487424 已分配内存中的剩余空间 = 62465304 已用内存 = 2022120 时间 = 1539589480028 最大内存 = 926941184 已分配内存 = 185597952 已分配内存中的剩余空间 = 23240200 已用内存 = 162357752 时间 = 1539589481484 最大内存 = 926941184 已分配内存 = 185597952 已分配内存中的剩余空间 = 23240200 已用内存 = 162357752 时间 = 1539589481658 通过结果我们可以看出尽管添加了一个新的类，但是内存占用和运行时间还是比初始的时候要小。 所以可以看出享元模式的好处。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之外观模式]]></title>
    <url>%2F2018%2F10%2F17%2FFacadeMode%2F</url>
    <content type="text"><![CDATA[设计模式之外观模式1. 什么是外观模式Facade模式也叫外观模式, Facade模式为一组具有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。其实也就是提供一个统一的接口，来访问子系统中一群功能相关接口。外观模式定义了一个高层接口，让子系统更容易使用。 外观模式的结构： Facade：为调用方定义简单的调用接口。 Clients： 调用者。通过Facade接口调用提供某功能的内部类群。 Packages ：功能提供者。指提供功能的类群（模块或子系统） 2. 具体实例我们通过一个家庭电影院的实例来看一下外观模式的具体实现 我们组建一个家庭影院：需要DVD播放器、投影仪、自动屏幕、环绕立体声、爆米花机，每一个对象都有自己需要实现的具体功能。 我们首先设想一个传统的设计：直接用遥控器统筹各设备开关：开爆米花机，放下屏幕，开投影仪，开音响，开DVD，选dvd，去拿爆米花，调暗灯光，播放，观影结束后，关闭各种设备。按照这种设计顺序我们就可以实现整个的设计，但是这种设计有什么问题呢？每一种设备需要一个遥控器，然后打开关闭各自需要执行一遍，太复杂了。看一下基于外观模式的设计怎么解决这个问题。 基于外观模式的设计： 其实他就是把这些设备的相同的功能如ready,play等等统一放在一起，一块儿执行。这样的话一下子就可以把之前需要单个执行的命令一次性就执行完。其实也就是相当于设计了一个更加高层的接口来同意管理低层的接口。其实就是简化了这个系统对外暴露的接口，你可以不用关心底层是怎么操作的，只需要直接使用高层的接口的功能就可以了。 具体的代码如下： Popcorn: 123456789101112131415161718192021222324252627public class Popcorn &#123; private static Popcorn instance = null; private Popcorn() &#123; &#125; public static Popcorn getInstance() &#123; if (instance == null) &#123; instance = new Popcorn(); &#125; return instance; &#125; public void on() &#123; System.out.println("Popcorn On"); &#125; public void off() &#123; System.out.println("Popcorn Off"); &#125; public void pop() &#123; System.out.println("Popcorn is popping"); &#125; &#125; 其余的设备类的初始化同理： 外观模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class HomeTheaterFacade &#123; private TheaterLights mTheaterLights; private Popcorn mPopcorn; private Stereo mStereo; private Projector mProjector; private Screen mScreen; private DVDPlayer mDVDPlayer; public HomeTheaterFacade() &#123; mTheaterLights = TheaterLights.getInstance(); mPopcorn = Popcorn.getInstance(); mStereo = Stereo.getInstance(); mProjector = Projector.getInstance(); mScreen = Screen.getInstance(); mDVDPlayer = DVDPlayer.getInstance(); &#125; public void ready() &#123; mPopcorn.on(); mPopcorn.pop(); mScreen.down(); mProjector.on(); mStereo.on(); mDVDPlayer.on(); mDVDPlayer.setdvd(); mTheaterLights.dim(10); &#125; public void end() &#123; mPopcorn.off(); mTheaterLights.bright(); mScreen.up(); mProjector.off(); mStereo.off(); mDVDPlayer.setdvd(); mDVDPlayer.off(); &#125; public void play() &#123; mDVDPlayer.play(); &#125; public void pause() &#123; mDVDPlayer.pause(); &#125;&#125; 测试类 12345678public class MainTest &#123; public static void main(String[] args) &#123; HomeTheaterFacade mHomeTheaterFacade=new HomeTheaterFacade(); mHomeTheaterFacade.ready(); mHomeTheaterFacade.play(); &#125;&#125; 从测试类中我们可以看到直接使用了外观模式中的统一接口执行，显得简单了很多。其实外观模式我们在自己设计程序的过程中不知不觉的就用到了，其实就是为了简化系统的类似的接口而统一封装一个。 上面的系统还可以使用命令模式来设计实现，命令模式就是把命令进行封装，实现命令和执行者之间的解耦。命令模式中的宏命令模式就是把几个命令封装起来统一执行，很像上面的设计方式，但是命令模式和外观模式的侧重点是不一样的，命令模式侧重于解耦，而外观模式侧重于系统的简化。 3. 最少知识原则最少知识原则是设计模式的6大原则之一，最少知识原则就是要告诉我们要减少对象之间的交互，只留下几个“密友”，也就是只留下必要的对象，其实就是为了在设计中不让太多的类耦合在一起，要不然在修改和维护系统的时候牵一发而动全身。 怎么样才能只留下需要的对象，不引入过多的对象呢？设计方针就是： 就任何对象而言，在对象方法内只应该调用属于以下范围内的方法： 该对象本身 被当做方法的参数而传进来的对象 此方法所创建或实例化的任何对象 对象的任何组件 有一个值得注意的地方就是：不调用从另一个调用中返回对象的方法，如果说调用了，那么不就是引入新的对象了嘛。越多了调用这种方法，引入的对象越多，越不容易维护。 举个例子： 123456789101112131415161718public class Car&#123; Engine engine; //类组件 public Car() &#123; //初始化发动机 &#125; public void start(Key mKey) //新的对象但是是传入的参数 &#123; Doors doors=new Doors(); //此方法所创建或实例化的任何对象 boolean authorized=mKey.turns(); //被当做方法的参数而传进来的对象 if(authorized) &#123; engine.start(); //对象的组件方法 doors.lock(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之复合模式]]></title>
    <url>%2F2018%2F10%2F17%2FcompoundMode%2F</url>
    <content type="text"><![CDATA[设计模式之复合模式1. 什么是复合模式在形式上，复合模式确实是多个模式的组合，但满足了这一条并不一定是复合模式，注意它的定义：将多个模式结合起来形成一个“框架”，以解决一般性问题。一提到“框架”，可能最容易联想到的就是MVC吧，不过MVC确实是一个经典的复合模式。 2. 具体实例项目的类图： 首先要创建一群呱呱叫的鸭子类，让他们实现接口Quackable： 123public interface Quackable &#123; public void quack();&#125; 这是一个鸭子类： 12345public class RedheadDuck implements Quackable &#123; @Override public void quack() &#123; System.out.println("Quack");&#125; 这时候水里还有鹅，也会叫： 123456public class Goose &#123; public void hoke()&#123; System.out.println("Honk"); &#125;&#125; 想让鹅也实现Quackable接口统一管理，可以用适配器模式： 12345678910111213public class GooseAdapter implements Quackable &#123; Goose goose; public GooseAdapter(Goose goose)&#123; this.goose = goose; observable = new Observable(this); &#125; @Override public void quack() &#123; goose.hoke(); notifyObservers();&#125; 这时，想要统计他们叫的次数，就可以使用装饰者模式把它们装饰城=成QuackCounter： 1234567891011121314151617public class QuackCounter implements Quackable &#123; Quackable duck; static int numberOfQuacks; public QuackCounter(Quackable duck)&#123; this.duck = duck; &#125; @Override public void quack() &#123; duck.quack(); numberOfQuacks++; &#125; public static int getQuacks()&#123; return numberOfQuacks; &#125;&#125; 每次创建鸭子都要new很麻烦，就可以用工厂模式，要鸭子就直接跟工厂要： 123456789101112131415161718192021public class CountingDuckFactory extends AbstrctDuckFactory &#123; @Override public Quackable createMallardDuck() &#123; return new QuackCounter(new MallardDuck()); &#125; @Override public Quackable createRedheadDuck() &#123; return new QuackCounter(new RedheadDuck()); &#125; @Override public Quackable createDuckCall() &#123; return new QuackCounter(new DuckCall()); &#125; @Override public Quackable createRubberDuck() &#123; return new QuackCounter(new RubberDuck()); &#125;&#125; 因为鸭子太多了，可以用组合模式统一管理，用迭代器模式查看内部对象： 123456789101112131415public class Flock implements Quackable &#123; ArrayList quackers = new ArrayList(); public void add(Quackable quacker)&#123; quackers.add(quacker); &#125; @Override public void quack() &#123; Iterator iterator = quackers.iterator(); while (iterator.hasNext())&#123; Quackable quacker = (Quackable) iterator.next(); quacker.quack(); &#125; &#125;&#125; 现在，生物学家想每次呱呱叫都被通知到，就可以使用观察者模式： 1234567891011121314151617181920212223242526272829public class Flock implements Quackable &#123; ArrayList quackers = new ArrayList(); public void add(Quackable quacker)&#123; quackers.add(quacker); &#125; @Override public void quack() &#123; Iterator iterator = quackers.iterator(); while (iterator.hasNext())&#123; Quackable quacker = (Quackable) iterator.next(); quacker.quack(); &#125; &#125; @Override public void registerObserver(Observer observer) &#123; Iterator iterator = quackers.iterator(); while (iterator.hasNext()) &#123; Quackable duck = (Quackable) iterator.next(); duck.registerObserver(observer); &#125; &#125; @Override public void notifyObservers() &#123; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class DuckSimulator &#123; public static void main(String[] args) &#123; DuckSimulator simulator = new DuckSimulator(); AbstrctDuckFactory duckFactory = new CountingDuckFactory(); simulator.simulate(duckFactory); &#125; void simulate(AbstrctDuckFactory duckFactory)&#123; Quackable redheadDuck = duckFactory.createRedheadDuck(); Quackable duckCall = duckFactory.createDuckCall(); Quackable rubberDuck = duckFactory.createRubberDuck(); Quackable gooseDuck = new QuackCounter(new GooseAdapter(new Goose())); System.out.println("\nDuck Simulator: With Composite - Flocks"); Flock flock = new Flock(); flock.add(redheadDuck); flock.add(rubberDuck); flock.add(duckCall); flock.add(gooseDuck); Flock flock1 = new Flock(); Quackable mallardDuck1 = duckFactory.createMallardDuck(); Quackable mallardDuck2 = duckFactory.createMallardDuck(); Quackable mallardDuck3 = duckFactory.createMallardDuck(); Quackable mallardDuck4 = duckFactory.createMallardDuck(); flock1.add(mallardDuck1); flock1.add(mallardDuck2); flock1.add(mallardDuck3); flock1.add(mallardDuck4); flock.add(flock1); System.out.println("\nDuck Simulator: Whole Flock Simulation"); simulate(flock); System.out.println("\nDuck Simulator: Mallard Flock Simulation"); simulate(flock1); Quackologist quackologist = new Quackologist(); flock.registerObserver(quackologist); simulate(flock); System.out.println("The duck quacked "+QuackCounter.getQuacks()+" times"); &#125; void simulate(Quackable duck)&#123; duck.quack(); &#125;&#125; 3. MVC与复合模式结构： 模型：模型持有所有的数据、状态和程序逻辑，模型没有注意到视图和控制器，虽然它提供了操纵和检索状态的接口，并发送状态改变通知给观察者。是程序主体，代表了业务数据和业务逻辑。 视图：用来呈现模型，视图通常直接从模型中取得它需要显示的状态与数据。是与用户交互的界面，显示数据、接收输入，但不参与实际业务逻辑 控制器：取得用户的输入并解读其对模型的意思。接收用户输入，并解析反馈给Model。 MVC的最大优点就是把表现层View与模型Model分离，实现了设计上的松耦合（应对变化）以及代码的复用（View可以随便换，只需要改改新View里面那一丁点儿控制逻辑就好了） 前面说过了MVC是一种复合模式，那它到底复合了哪些模式，一起看看： 策略模式 视图和控制器实现了策略模式：视图是一个对象，可以被调整使用不同的策略，而控制提供了策略。视图只关心系统中可视的部分，对与任何界面行为，都委托给控制器处理。使用策略模式也可以让视图和模型之间关系解耦，因为控制器负责和模型交互来传递用户的请求。对与工作是怎么完成的，视图豪不知情。 观察者模式 模型实现了观察者模式，当状态改变时，相关对象将持续更新。使用观察者模式，可以让模型完全独立于视图和控制器。同一个模型可以使用不同的视图，甚至可以同时使用多个视图。 组合模式 显示包括了窗口、面板、按钮、文本标签等。每个显示组件如果不是组合节点（例如窗口），就是叶节点（例如按钮）。当控制器告诉视图更新时，只需告诉视图最顶层的组件即可，组合会处理其余的事。 MVC应用了多个模式，并能够较好的解决设计上的一般性问题，所以被称为复合模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>复合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之组合模式]]></title>
    <url>%2F2018%2F10%2F17%2FCompositeMode%2F</url>
    <content type="text"><![CDATA[设计模式之组合模式1. 什么是组合模式Composite模式也叫组合模式，是构造型的设计模式之一。通过递归手段来构造树形的对象结构，并可以通过一个对象来访问整个对象树。 换一种说法就是组合模式将对象聚合成树形结构来表现“整体/部分”的层次结构。组合模式能让客户以一致的方式来处理个别对象以及对象组合。也就是我们可以忽略对象组合与个体对象之间的差别。 组合模式的结构： Component （树形结构的节点抽象） 为所有的对象定义统一的接口（公共属性，行为等的定义） 提供管理子节点对象的接口方法 [可选]提供管理父节点对象的接口方法 Leaf （树形结构的叶节点） Component的实现子类 Composite（树形结构的枝节点） Component的实现子类 2. 具体实例在具体的例子中去只看一下具体是怎么实现和使用的。例子都是书上的例子。 这次的实例还是使用的是那个迭代器模式中的例子。具体的就不在描述了，具体放入可以参考那篇文章。 这次呢就是在那个的基础上我们需要添加新的子菜单，不是添加的某一个菜单，而是在一个菜单项中添加一个子菜单。如下图示： 这样的话我们按照原来的迭代器的设计就是需要修改那个DinerMenu,并且还要抽取其中的Item变为类，然后需要这个子类去继承他。而且迭代的方法也需要修改，这样的话太费劲了，而且每加一个子菜单都要进行修改，维护成本太大。所以需要一个新的模式来重新设计他。 怎么设计呢？ 就是我们把所有的菜单项都设计成一种结构，然后统一的去迭代他。要想抽象成一种结构的话需要一个统一的超类供继承和扩展。我们这里把整个项目设计成一个树形的结构。每个节点的类型都是相同的。节点是菜单或子菜单，叶子是菜单项需要能够在各个菜单项之间游走，遍历要能够有弹性的在菜单项之间游走。 项目类图结构： 具体代码实现： 首先是所有的节点都需要继承的那个抽象类，也就是所有的菜单项都需要继承的类，把通用的方法全部抽取出来： 123456789101112131415161718192021222324public abstract class MenuComponent &#123; public String getName() &#123; return ""; &#125; public String getDescription() &#123; return ""; &#125; public float getPrice() &#123; return 0; &#125; public boolean isVegetable() &#123; return false; &#125; public abstract void print(); public Iterator getIterator() &#123; return new NullIterator(); &#125;&#125; 具体的菜单项： 12345678910111213141516171819202122232425262728293031323334353637383940public class MenuItem extends MenuComponent&#123; private String name,description; private boolean vegetable; private float price; public MenuItem(String name,String description,boolean vegetable,float price) &#123; this.name=name; this.description=description; this.vegetable=vegetable; this.price=price; &#125; @Override public String getName() &#123; return name; &#125; @Override public String getDescription() &#123; return description; &#125; @Override public float getPrice() &#123; return price; &#125; @Override public boolean isVegetable() &#123; return vegetable; &#125; @Override public void print() &#123; // TODO Auto-generated method stub System.out.println(getName() + "***" + getPrice() + "***" + getDescription()); &#125;&#125; 子菜单： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class DinerMenu extends MenuComponent &#123; private final static int Max_Items = 5; private int numberOfItems = 0; private MenuComponent[] menuItems; public DinerMenu() &#123; menuItems = new MenuComponent[Max_Items]; addItem("vegetable Blt", "bacon&amp;lettuce&amp;tomato&amp;cabbage", true, 3.58f); addItem("Blt", "bacon&amp;lettuce&amp;tomato", false, 3.00f); addItem("bean soup", "bean&amp;potato salad", true, 3.28f); addItem("hotdog", "onions&amp;cheese&amp;bread", false, 3.05f); addSubMenu(new SubMenu()); &#125; private void addItem(String name, String description, boolean vegetable, float price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetable, price); if (numberOfItems &gt;= Max_Items) &#123; System.err.println("sorry,menu is full!can not add another item"); &#125; else &#123; menuItems[numberOfItems] = menuItem; numberOfItems++; &#125; &#125; private void addSubMenu(MenuComponent mMenuComponent) &#123; if (numberOfItems &gt;= Max_Items) &#123; System.err.println("sorry,menu is full!can not add another item"); &#125; else &#123; menuItems[numberOfItems] = mMenuComponent; numberOfItems++; &#125; &#125; public Iterator getIterator() &#123; return new ComposeIterator(new DinerIterator()); &#125; class DinerIterator implements Iterator &#123; private int position; public DinerIterator() &#123; position = 0; &#125; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub if (position &lt; numberOfItems) &#123; return true; &#125; return false; &#125; @Override public Object next() &#123; // TODO Auto-generated method stub MenuComponent menuItem = menuItems[position]; position++; return menuItem; &#125; @Override public void remove() &#123; // TODO Auto-generated method stub &#125; &#125; @Override public void print() &#123; // TODO Auto-generated method stub System.out.println("****This is DinerMenu****"); &#125;&#125; 12345678910111213141516171819202122232425262728293031public class CakeHouseMenu extends MenuComponent &#123; private ArrayList&lt;MenuComponent&gt; menuItems; public CakeHouseMenu() &#123; menuItems = new ArrayList&lt;MenuComponent&gt;(); addItem("KFC Cake Breakfast", "boiled eggs&amp;toast&amp;cabbage", true, 3.99f); addItem("MDL Cake Breakfast", "fried eggs&amp;toast", false, 3.59f); addItem("Stawberry Cake", "fresh stawberry", true, 3.29f); addItem("Regular Cake Breakfast", "toast&amp;sausage", true, 2.59f); &#125; private void addItem(String name, String description, boolean vegetable, float price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetable, price); menuItems.add(menuItem); &#125; public Iterator getIterator() &#123; return new ComposeIterator(menuItems.iterator()); &#125; @Override public void print() &#123; // TODO Auto-generated method stub System.out.println("****This is CakeHouseMenu****"); &#125;; // 其他功能代码&#125; 等等… 然后需要一个统一的迭代器来遍历这个树，怎么遍历呢？使用堆栈进行遍历？具体的遍历方法可以参考我之前写的二分搜索树的介绍的文章，非递归方式遍历，这里大同小异。下面就是一个组合迭代器，确保所有的子菜单都要包含进来： 1234567891011121314151617181920212223242526272829303132333435363738394041public class ComposeIterator implements Iterator &#123; private Stack&lt;Iterator&gt; stack = new Stack&lt;Iterator&gt;(); public ComposeIterator(Iterator iterator) &#123; stack.push(iterator); &#125; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub if (stack.empty()) &#123; return false; &#125; Iterator iterator = stack.peek(); if (!iterator.hasNext()) &#123; stack.pop(); return hasNext(); &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; // TODO Auto-generated method stub if (hasNext()) &#123; Iterator iterator = stack.peek(); MenuComponent mMenuComponent = (MenuComponent) iterator.next(); stack.push(mMenuComponent.getIterator()); return mMenuComponent; &#125; return null; &#125; @Override public void remove() &#123; // TODO Auto-generated method stub &#125;&#125; 当我们的菜单中什么都没有，也就是没有需要打印的东西的话怎么办呢？需要设计一个空的迭代器: 123456789101112131415161718192021public class NullIterator implements Iterator&#123; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub return false; &#125; @Override public Object next() &#123; // TODO Auto-generated method stub return null; &#125; @Override public void remove() &#123; // TODO Auto-generated method stub &#125;&#125; 前台打印菜单的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Waitress &#123; private ArrayList&lt;MenuComponent&gt; iterators = new ArrayList&lt;MenuComponent&gt;(); public Waitress() &#123; &#125; public void addComponent(MenuComponent mMenuComponent) &#123; iterators.add(mMenuComponent); &#125; public void printMenu() &#123; Iterator iterator; MenuComponent menuItem; for (int i = 0, len = iterators.size(); i &lt; len; i++) &#123; iterators.get(i).print(); iterator = iterators.get(i).getIterator(); while (iterator.hasNext()) &#123; menuItem = (MenuComponent) iterator.next(); menuItem.print(); &#125; &#125; &#125; public void printBreakfastMenu() &#123; &#125; public void printLunchMenu() &#123; &#125; public void printVegetableMenu() &#123; Iterator iterator; MenuComponent menuItem; for (int i = 0, len = iterators.size(); i &lt; len; i++) &#123; iterators.get(i).print(); iterator = iterators.get(i).getIterator(); while (iterator.hasNext()) &#123; menuItem = (MenuComponent) iterator.next(); if (menuItem.isVegetable()) &#123; menuItem.print(); &#125; &#125; &#125; &#125;&#125; 测试类： 12345678910public class MainTest &#123; public static void main(String[] args) &#123; Waitress mWaitress = new Waitress(); CakeHouseMenu mCakeHouseMenu = new CakeHouseMenu(); DinerMenu mDinerMenu = new DinerMenu(); mWaitress.addComponent(mCakeHouseMenu); mWaitress.addComponent(mDinerMenu); mWaitress.printVegetableMenu();; &#125;&#125; 通过上面的实例我们就使用组合模式重新设计了原来的项目，通过组合的模式将Waitress 与具体的子菜单进行了解耦，也就是Waitress 只需要使用MenuComponent，而不用去关心具体的子菜单是怎么实现的。 当我们有一系列的对象集合的时候，并且彼此之间还有整体和部分的关系，你需要用一致性的方法来处理这些对象的时候就需要组合模式，例如上面的统一的去遍历所有的菜单对象。而且组合内的所有方法是都要实现一个统一的接口的，要不然客户就需要操心那个对象使用那个接口，失去了组合模式的意义，但是这样子的话其实有些对象也就需要实现一些没有意义的方法。但是你可以让这些方法都返回null或者不处理任何事情就可以了。组合模式一般是使用树形结构这种层次结构。根就是顶层的组合。而且孩子节点也可以有指向父亲节点的指针，这样的设计会使得对象的游走遍历更加的方便。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之命令模式]]></title>
    <url>%2F2018%2F10%2F17%2FCommandMode%2F</url>
    <content type="text"><![CDATA[设计模式之命令模式1. 什么是命令模式Command模式也叫命令模式 ，是行为设计模式的一种。Command模式通过被称为Command的类封装了对目标对象的调用行为以及调用参数。 应用场景 在面向对象的程序设计中，一个对象调用另一个对象，一般情况下的调用过程是：创建目标对象实例；设置调用参数；调用目标对象的方法。但在有些情况下有必要使用一个专门的类对这种调用过程加以封装，我们把这种专门的类称作command类。 整个调用过程比较繁杂，或者存在多处这种调用。这时，使用Command类对该调用加以封装，便于功能的再利用。 调用前后需要对调用参数进行某些处理。 调用前后需要进行某些额外处理，比如日志，缓存，记录历史操作等。 命令模式的结构 Command：Command抽象类。 ConcreteCommand:Command的具体实现类。 Receiver:需要被调用的目标对象。 Invorker:通过Invorker执行Command对象。 2. 具体实例这里以一个家电自动化遥控器API项目的问题为例来实现命令模式的应用。 其实遥控器的需求就是不同的按钮控制不同的家电，比如有控制灯的，有控制电视的，有控制音箱的。按照面向对象的设计原则，我们就设计家电类和控制类就可以实现了，控制类去控制家电类中不同的具体的命令。但是这种方案的缺陷是什么呢？就是我们要添加新的家电的时候需要添加新的类并且同时修改控制类，也就是说这个过程中不同的家电执行的命令和家电之间是高耦合的，不利于代码的维护和扩展。 既然命令是需要改变的变量，我们把命令单独抽取出来形成接口，然后有具体的类去实现它，这样的话其实就是把命令和家电之间的关系进行了解耦合。具体的设计方案如下： 看一下代码的具体实现： Command接口： 1234public interface Command &#123; public void execute(); public void undo();&#125; 具体实现Command接口的类： 1234567891011121314151617181920public class LightOnCommand implements Command &#123; private Light light; public LightOnCommand(Light light) &#123; this.light=light; &#125; @Override public void execute() &#123; // TODO Auto-generated method stub light.On(); &#125; @Override public void undo() &#123; // TODO Auto-generated method stub light.Off(); &#125;&#125; 123456789101112131415161718public class LightOffCommand implements Command &#123; private Light light; public LightOffCommand(Light light) &#123; this.light=light; &#125; @Override public void execute() &#123; // TODO Auto-generated method stub light.Off(); &#125; @Override public void undo() &#123; // TODO Auto-generated method stub light.On(); &#125;&#125; 等等。。。其余的设别的控制命令的实现类同理。 Control接口： 12345678public interface Control &#123; public void onButton(int slot); public void offButton(int slot); public void undoButton();&#125; 实现类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class CommandModeControl implements Control&#123; private Command[] onCommands; private Command[] offCommands; private Stack&lt;Command&gt; stack=new Stack&lt;Command&gt;(); public CommandModeControl() &#123; onCommands=new Command[5]; offCommands=new Command[5]; Command noCommand=new NoCommand(); for(int i=0,len=onCommands.length;i&lt;len;i++) &#123; onCommands[i]=noCommand; offCommands[i]=noCommand; &#125; &#125; public void setCommand(int slot,Command onCommand,Command offCommand) &#123; onCommands[slot]=onCommand; offCommands[slot]=offCommand; &#125; @Override public void onButton(int slot) &#123; onCommands[slot].execute(); stack.push(onCommands[slot]); &#125; @Override public void offButton(int slot) &#123; offCommands[slot].execute(); stack.push(offCommands[slot]); &#125; @Override public void undoButton() &#123; // TODO Auto-generated method stub stack.pop().undo(); &#125;&#125; 设备的类就不在赘述了，其实很简单的 最后是测试这个工程的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ControlTest &#123; public static void main(String[] args) &#123; CommandModeControl control = new CommandModeControl(); MarcoCommand onmarco,offmarco; Light bedroomlight = new Light("BedRoom"); Light kitchlight = new Light("Kitch"); Stereo stereo = new Stereo(); LightOnCommand bedroomlighton = new LightOnCommand(bedroomlight); LightOffCommand bedroomlightoff = new LightOffCommand(bedroomlight); LightOnCommand kitchlighton = new LightOnCommand(kitchlight); LightOffCommand kitchlightoff = new LightOffCommand(kitchlight); Command[] oncommands=&#123;bedroomlighton,kitchlighton&#125;; Command[] offcommands=&#123;bedroomlightoff,kitchlightoff&#125;; onmarco=new MarcoCommand(oncommands); offmarco=new MarcoCommand(offcommands); StereoOnCommand stereoOn = new StereoOnCommand(stereo); StereoOffCommand stereoOff = new StereoOffCommand(stereo); StereoAddVolCommand stereoaddvol = new StereoAddVolCommand(stereo); StereoSubVolCommand stereosubvol = new StereoSubVolCommand(stereo); control.setCommand(0, bedroomlighton, bedroomlightoff); control.setCommand(1, kitchlighton, kitchlightoff); control.setCommand(2, stereoOn, stereoOff); control.setCommand(3, stereoaddvol, stereosubvol); control.setCommand(4, onmarco, offmarco); control.onButton(0); control.undoButton(); //control.offButton(0); control.onButton(1); control.offButton(1); control.onButton(2); control.onButton(3); control.offButton(3); control.undoButton(); control.offButton(2); control.undoButton(); control.onButton(4); control.offButton(4); &#125;&#125; 通过上面的命令模式的例子我们可以看到通过命令模式实现了命令与设备之间的解耦合，就是使得命令和设备之间不是那么强相关的，便不再是具体的设备中来写具体的命令，而是专门抽象出一个接口，然后由具体的命令去具体的实现它。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之责任链模式]]></title>
    <url>%2F2018%2F10%2F17%2FChainmsPattern%2F</url>
    <content type="text"><![CDATA[设计模式之责任链模式1. 什么是责任链模式Chain of Responsibility（CoR）模式也叫职责链模式或者责任链模式，是行为模式之一，该模式构造一系列分别担当不同的职责的类的对象来共同完成一个任务，这些类的对象之间像链条一样紧密相连，所以被称作职责链模式。 换句话说责任链模式就是如果有多个对象都有机会处理请求，责任链可使请求的发送者和接收者解耦，请求沿着责任链传递，直到有一个对象处理了它为止。 责任链模式的结构： 要实现Chain of Responsibility模式，需要满足该模式的基本条件： 对象链的组织。需要将某任务的所有职责执行对象以链的形式加以组织。 消息或请求的传递。将消息或请求沿着对象链传递，以让处于对象链中的对象得到处理机会。 处于对象链中的对象的职责分配。不同的对象完成不同的职责。 任务的完成。处于对象链的末尾的对象结束任务并停止消息或请求的继续传递。 优缺点： 优点： 将请求的发送者和接收者解耦，使多个对象都有机会处理这个请求 可以简化对象，因为它无须知道链的结构 可以动态地增加或删减处理请求的链结构 缺点： 请求从链的开头进行遍历，对性能有一定的损耗 并不保证请求一定被处理 适用场合： 有多个对象可以处理一个请求 不明确接收者的情况，就是你把事情扔到责任链中，找一圈总能找到合适的处理者 有序、无序链，线型、树形、环形链 举几个例子： 例1：比如客户Client要完成一个任务，这个任务包括a,b,c,d四个部分。首先客户Client把任务交给A，A完成a部分之后，把任务交给B，B完成b部分，…，直到D完成d部分。 例2：比如政府部分的某项工作，县政府先完成自己能处理的部分，不能处理的部分交给省政府，省政府再完成自己职责范围内的部分，不能处理的部分交给中央政府，中央政府最后完成该项工作。 例3：软件窗口的消息传播。 例4：SERVLET容器的过滤器（Filter）框架实现。 2. 具体实例：从一个具体的实例来简单看下责任链模式是怎么实现和使用的。 购买请求决策项目： 决策因素：价格 决策级别：组长、部长、副总、总裁 我们一般就是想设计一个抽象类，然后使用switch实现决策的功能，然后具体的实现和处理由下面的具体的继承和扩展的类来做。这样做的时候就是我们要个更改决策者的权限或者是增加删除决策者的时候需要将这个抽象类一并修改，不符合开闭的原则。 然后我们这里用责任链模式进行的设计如下所示： 类图： 其实就是把switch的决策交给了责任链去实现。每一层的具体的去做，到能够处理掉的时候就把事情处理掉，否则往下一层找。 具体的代码： 结合上面的责任链的结构，我们需要有一个handler，在这里也就是Approver。 12345678910111213public abstract class Approver &#123; Approver successor; String Name; public Approver(String Name) &#123; this.Name=Name; &#125; public abstract void ProcessRequest( PurchaseRequest request); public void SetSuccessor(Approver successor) &#123; // TODO Auto-generated method stub this.successor=successor; &#125;&#125; 然后是具体的approver,也就是具体决策的执行者。 12345678910111213141516171819public class DepartmentApprover extends Approver &#123; public DepartmentApprover(String Name) &#123; super(Name + " DepartmentLeader"); &#125; @Override public void ProcessRequest(PurchaseRequest request) &#123; // TODO Auto-generated method stub if ((5000 &lt;= request.GetSum()) &amp;&amp; (request.GetSum() &lt; 10000)) &#123; System.out.println("**This request " + request.GetID() + " will be handled by " + this.Name + " **"); &#125; else &#123; successor.ProcessRequest(request); &#125; &#125;&#125; 123456789101112131415161718192021public class GroupApprover extends Approver &#123; public GroupApprover(String Name) &#123; super(Name+" GroupLeader"); // TODO Auto-generated constructor stub &#125; @Override public void ProcessRequest(PurchaseRequest request) &#123; // TODO Auto-generated method stub if (request.GetSum() &lt; 5000) &#123; System.out.println("**This request " + request.GetID() + " will be handled by " + this.Name + " **"); &#125; else &#123; successor.ProcessRequest(request); &#125; &#125;&#125; 123456789101112131415161718public class PresidentApprover extends Approver &#123; public PresidentApprover(String Name) &#123; super(Name + " President"); &#125; @Override public void ProcessRequest(PurchaseRequest request) &#123; // TODO Auto-generated method stub if (50000 &lt;= request.GetSum()) &#123; System.out.println("**This request " + request.GetID() + " will be handled by " + this.Name + " **"); &#125;else &#123; successor.ProcessRequest(request); &#125; &#125;&#125; 123456789101112131415161718public class VicePresidentApprover extends Approver &#123; public VicePresidentApprover(String Name) &#123; super(Name + " Vice President"); &#125; @Override public void ProcessRequest(PurchaseRequest request) &#123; // TODO Auto-generated method stub if ((10000 &lt;= request.GetSum()) &amp;&amp; (request.GetSum() &lt; 50000)) &#123; System.out.println("**This request " + request.GetID() + " will be handled by " + this.Name + " **"); &#125; else &#123; successor.ProcessRequest(request); &#125; &#125;&#125; 然后我们需要client也就是员工来发出请求： Client: 12345678public class Client &#123; public Client() &#123; &#125; public PurchaseRequest sendRequst(int Type, int Number, float Price) &#123; return new PurchaseRequest(Type, Number, Price); &#125;&#125; 请求： 123456789101112131415161718192021222324public class PurchaseRequest &#123; private int Type = 0; private int Number = 0; private float Price = 0; private int ID = 0; public PurchaseRequest(int Type, int Number, float Price) &#123; this.Type = Type; this.Number = Number; this.Price = Price; &#125; public int GetType() &#123; return Type; &#125; public float GetSum() &#123; return Number * Price; &#125; public int GetID() &#123; return (int) (Math.random() * 1000); &#125;&#125; 这样整个的结构代码就完成了，测试类,在测试类中需要将所有的具体的Approver实例化，然后去一层一层的往下找，其实这里的话其实责任链已经构成了一个环，所以你具体的以哪一个Approver开始执行命令是不影响结果的。然后设计的责任链的顺序也是无所谓的，因为总会找到合适的处理者，但是这样也造成了性能的开销。 123456789101112131415161718192021public class MainTest &#123; public static void main(String[] args) &#123; Client mClient=new Client(); Approver GroupLeader=new GroupApprover("Tom"); Approver DepartmentLeader=new DepartmentApprover("Jerry"); Approver VicePresident=new VicePresidentApprover("Kate"); Approver President=new PresidentApprover("Bush"); GroupLeader.SetSuccessor(VicePresident); DepartmentLeader.SetSuccessor(President); VicePresident.SetSuccessor(DepartmentLeader); President.SetSuccessor(GroupLeader); VicePresident.ProcessRequest(mClient.sendRequst(1, 100, 40)); VicePresident.ProcessRequest(mClient.sendRequst(2, 200, 40)); VicePresident.ProcessRequest(mClient.sendRequst(3, 300, 40)); VicePresident.ProcessRequest(mClient.sendRequst(4, 400, 140)); &#125;&#125; 3. 责任链模式与状态模式的差异责任链模式和状态模式主要区别： 责任链模式注重请求的传递 状态模式注重对象状态的转换]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之生成器模式]]></title>
    <url>%2F2018%2F10%2F17%2FBuilderPattern%2F</url>
    <content type="text"><![CDATA[设计模式之生成器模式1. 什么是生成器模式 Builder模式也叫建造者模式或者生成器模式，是由GoF提出的23种设计模式中的一种。Builder模式是一种对象创建型模式之一，用来隐藏复合对象的创建过程，它把复合对象的创建过程加以抽象，通过子类继承和重载的方式，动态地创建具有复合属性的对象。 简单来说就是封装一个复杂对象的构造过程，并允许按照步骤构造。 生成器模式的结构： 对象的创建：Builder模式是为对象的创建而设计的模式 创建的是一个复合对象：被创建的对象为一个具有复合属性的复合对象 关注对象创建的各部分的创建过程：不同的工厂（这里指builder生成器）对产品属性有不同的创建方法 适用场景： 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 优缺点： 优点： 封装性很好：使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。 扩展性很好：建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。 有效控制细节风险：由于具体的建造者是独立的，因此可以对建造者过程逐步细化，而不对其他的模块产生任何影响。 将复杂对象的创建过程封装起来 允许对象通过几个步骤来创建，并且可以改变过程（工厂模式只有一个步骤） 只需指定具体生成器就能生成特定对象，隐藏类的内部结构 对象的实现可以被替换 缺点： 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 2. 具体实例这里举一个具体的例子来介绍生成器模式是怎么使用的. 度假计划生成项目：就是一个公司要推出度假的活动，然后会有具体的安排计划。 度假计划的因素：时间、门票、餐厅、住宿、特殊活动等。 所以我们就像抽象一个度假类，然后每一天去继承和扩展这个类。所以类图如下： 这样一个计划就是一个具体对象，便于扩展。 然后我们基于上面的基础，我们想用户可以自己选择具体是怎么过？选什么样的方式，就是我选3天的度假模式，还是选四天的度假模式，或者是其他种类的。这样的话我们就需要在设计一个抽象类AbsBuilder的类，然后在这个类中实现Vaction,然后用户通过Director就可以自行选择具体是什么样的度假模式，不用管底层的实现，直接使用这个类就可以了。然后要添加新的度假类的时候也不需要修改，符合开闭原则。具体的类图如下： 具体的代码实现： Vacation: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class Vacation &#123; private ArrayList&lt;VacationDay&gt; mVacationDayLst; private Date mStDate; private int mDays = 0; private VacationDay mVacationDay; public Vacation(String std) &#123; mVacationDayLst = new ArrayList&lt;VacationDay&gt;(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); try &#123; mStDate = sdf.parse(std); mVacationDay = new VacationDay(mStDate); mVacationDayLst.add(mVacationDay); mDays++; &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public void setStDate(String std) &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); try &#123; mStDate = sdf.parse(std); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public Date getStDate() &#123; return mStDate; &#125; public void addDay() &#123; mVacationDay = new VacationDay(nextDate(mDays)); mVacationDayLst.add(mVacationDay); mDays++; &#125; public boolean setVacationDay(int i) &#123; if ((i &gt; 0) &amp;&amp; (i &lt; mVacationDayLst.size())) &#123; mVacationDay = mVacationDayLst.get(i); return true; &#125; mVacationDay = null; return false; &#125; public void setHotel(String mHotels) &#123; mVacationDay.setHotel(mHotels); &#125; public void addTicket(String ticket) &#123; mVacationDay.addTicket(ticket); &#125; public void addEvent(String event) &#123; mVacationDay.addEvent(event); &#125; public void showInfo() &#123; for (int i = 0, len = mVacationDayLst.size(); i &lt; len; i++) &#123; System.out.println("** " + (i + 1) + " day**"); System.out.println(mVacationDayLst.get(i).showInfo()); &#125; &#125; private Date nextDate(int n) &#123; Calendar cal = Calendar.getInstance(); cal.setTime(mStDate); cal.add(Calendar.DATE, n); return cal.getTime(); &#125;&#125; VacationDay: 1234567891011121314151617181920212223242526272829303132333435363738public class VacationDay &#123; private Date mDate; private String mHotels; private ArrayList&lt;String&gt; mTickets = null; private ArrayList&lt;String&gt; mEvents = null; public VacationDay(Date date) &#123; mDate = date; mTickets = new ArrayList&lt;String&gt;(); mEvents = new ArrayList&lt;String&gt;(); &#125; public void setDate(Date date) &#123; mDate = date; &#125; public void setHotel(String mHotels) &#123; this.mHotels = mHotels; &#125; public void addTicket(String ticket) &#123; mTickets.add(ticket); &#125; public void addEvent(String event) &#123; mEvents.add(event); &#125; public String showInfo() &#123; StringBuilder stb = new StringBuilder(); stb.append("Date:" + mDate.toString() + "\n"); stb.append("Hotel:" + mHotels + "\n"); stb.append("Tickets:" + mTickets.toString() + "\n"); stb.append("Events" + mEvents.toString() + "\n"); return stb.toString(); &#125;&#125; 抽象类AbsBuilder: 123456789101112131415161718192021222324public abstract class AbsBuilder &#123; public Vacation mVacation; public AbsBuilder(String std) &#123; mVacation = new Vacation(std); &#125; public abstract void buildvacation(); public abstract void buildDay(int i); public abstract void addHotel(String hotel); public abstract void addTicket(String ticket); public abstract void addEvent(String tvent); public Vacation getVacation() &#123; return mVacation; &#125;&#125; 具体的度假模式（3天）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Builder3d extends AbsBuilder &#123; public Builder3d(String std) &#123; super(std); // TODO Auto-generated constructor stub &#125; @Override public void buildDay(int i) &#123; // TODO Auto-generated method stub mVacation.setVacationDay(i); &#125; @Override public void addHotel(String hotel) &#123; // TODO Auto-generated method stub mVacation.setHotel(hotel); &#125; @Override public void addTicket(String ticket) &#123; // TODO Auto-generated method stub mVacation.addTicket(ticket); &#125; @Override public void addEvent(String event) &#123; // TODO Auto-generated method stub mVacation.addEvent(event); &#125; @Override public void buildvacation() &#123; // TODO Auto-generated method stub addTicket("Plane Ticket"); addEvent("Fly to Destination"); addEvent("Supper"); addEvent("Dancing"); addHotel("Four Seasons"); mVacation.addDay(); addTicket("Theme Park"); addEvent("Bus to Park"); addEvent("lunch"); addHotel("Four Seasons"); mVacation.addDay(); addTicket("Plane Ticket"); addEvent("City Tour"); addEvent("Fly to Home"); &#125;&#125; 4天的模式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Builder4d extends AbsBuilder &#123; public Builder4d(String std) &#123; super(std); // TODO Auto-generated constructor stub &#125; @Override public void buildDay(int i) &#123; // TODO Auto-generated method stub mVacation.setVacationDay(i); &#125; @Override public void addHotel(String hotel) &#123; // TODO Auto-generated method stub mVacation.setHotel(hotel); &#125; @Override public void addTicket(String ticket) &#123; // TODO Auto-generated method stub mVacation.addTicket(ticket); &#125; @Override public void addEvent(String event) &#123; // TODO Auto-generated method stub mVacation.addEvent(event); &#125; @Override public void buildvacation() &#123; // TODO Auto-generated method stub addTicket("Plane Ticket"); addEvent("Fly to Destination"); addEvent("Supper"); addHotel("Hilton"); mVacation.addDay(); addTicket("Zoo Ticket"); addEvent("Bus to Zoo"); addEvent("Feed animals"); addHotel("Hilton"); mVacation.addDay(); addTicket("Beach"); addEvent("Swimming"); addHotel("Home inn"); mVacation.addDay(); addTicket("Plane Ticket"); addEvent("Fly to Home"); &#125;&#125; Director:在Director中传入Builder,然后构造的时候实现vacation的实例化。 1234567891011121314151617public class Director &#123; private AbsBuilder builder; public Director(AbsBuilder builder) &#123; this.builder=builder; &#125; public void setBuilder(AbsBuilder builder) &#123; this.builder=builder; &#125; public void construct() &#123; builder.buildvacation(); builder.getVacation().showInfo(); &#125;&#125; 测试类： 1234567891011121314151617181920212223242526272829public class MainTest &#123; public static void main(String[] args) &#123; Director mDirector = new Director(new Builder4d("2015-12-29")); mDirector.construct(); mDirector.setBuilder(new Builder3d("2015-8-30")); mDirector.construct(); testself() ; &#125; public static void testself() &#123; BuilderSelf builder = new BuilderSelf("2015-9-29"); builder.addTicket("Plane Ticket").addEvent("Fly to Destination") .addEvent("Supper").addHotel("Hilton"); builder.addDay().addTicket("Zoo Ticket").addEvent("Bus to Zoo") .addEvent("Feed animals").addHotel("Home Inn"); builder.addDay(); builder.addTicket("Beach"); builder.addEvent("Swimming"); builder.addHotel("Home inn"); builder.addDay().addTicket("Plane Ticket").addEvent("Fly to Home"); builder.getVacation().showInfo(); &#125;&#125; 3. 生成器模式与抽象工厂的差异生成器模式和抽象工厂模式在功能上很相似，主要区别： 生成器一般用来创建大的复杂的对象 生成器模式强调的是一步步创建对象，可以改变步骤来生成不同的对象 一般来说生成器模式中对象不直接返回]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>生成器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之桥接模式]]></title>
    <url>%2F2018%2F10%2F17%2FBridgeMode%2F</url>
    <content type="text"><![CDATA[设计模式之桥接模式1. 什么是桥接模式Bridge 模式又叫做桥接模式，是构造型的设计模式之一。Bridge模式基于类的最小设计原则，通过使用封装，聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。 桥接模式的一般结构： ClientBridge：模式的使用者 Abstraction：抽象类接口（接口或抽象类）维护对行为实现（Implementor）的引用 Refined Abstraction：Abstraction子类 Implementor：行为实现类接口 (Abstraction接口定义了基于Implementor接口的更高层次的操作) ConcreteImplementor： Implementor子类 2. 具体实例以一个遥控器项目为例来看一下桥接模式的使用，遥控器，就是几个功能开关，上下换台。 首先看一种设计方案，就是统一设计一个接口，然后不同的厂家去扩展继承他。 这种设计是可以实现目前的需求的，但是有什么问题呢？就是我现在要添加一个新的厂家，然后新的厂家呢增加了新的功能，这时候要是在继承统一的接口的话就不够了，需要修改具体的厂家类，还需要设计自己的类。 那我们使用桥接模式怎么设计呢？类图如下： 桥接模式就是把实现和抽象放在两个不同的类层次中，使得两个层次可以独立改变。这里就是设计了两个层次，一个是具体的遥控器，一个是生产的厂家，通过Control接口来桥接。这样的话就具体的遥控器就可以使用这个接口来使用厂家的方法，不用管顶层，解耦合了。容易扩展和维护。 具体的代码实现： Control 接口： 12345678public interface Control &#123; public void On(); public void Off(); public void setChannel(int ch); public void setVolume(int vol);&#125; 生产厂家类： 123456789101112131415161718192021222324252627public class LGControl implements Control &#123; @Override public void On() &#123; // TODO Auto-generated method stub System.out.println("**Open LG TV**"); &#125; @Override public void Off() &#123; // TODO Auto-generated method stub System.out.println("**Off LG TV**"); &#125; @Override public void setChannel(int ch) &#123; // TODO Auto-generated method stub System.out.println("**The LG TV Channel is setted "+ch+"**"); &#125; @Override public void setVolume(int vol) &#123; // TODO Auto-generated method stub System.out.println("**The LG TV Volume is setted "+vol+"**"); &#125;&#125; 其余的同理，就不再贴代码了，太多了。 TVControl抽象类： 123456789101112public abstract class TvControlabs &#123; Control mControl=null; public TvControlabs(Control mControl) &#123; this.mControl=mControl; &#125; public abstract void Onoff(); public abstract void nextChannel(); public abstract void preChannel(); &#125; TVControl抽象类的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TvControl extends TvControlabs &#123; private int ch=0; private boolean ison=false; public TvControl(Control mControl) &#123; super(mControl); &#125; @Override public void Onoff() &#123; // TODO Auto-generated method stub if(ison) &#123; ison=false; mControl.Off(); &#125;else&#123; ison=true; mControl.On(); &#125; &#125; @Override public void nextChannel() &#123; // TODO Auto-generated method stub ch++; mControl.setChannel(ch); &#125; @Override public void preChannel() &#123; // TODO Auto-generated method stub ch--; if(ch&lt;0) &#123; ch=200; &#125; mControl.setChannel(ch); &#125;&#125; 再有新的TVControl的具体实现的时候同理。 测试类： 1234567891011121314151617181920212223242526272829public class MainTest &#123; public static void main(String[] args) &#123; TvControl mLGTvControl; TvControl mSonyTvControl; mSonyTvControl=new TvControl(new SonyControl()); mLGTvControl=new TvControl(new LGControl()); mLGTvControl.Onoff(); mLGTvControl.nextChannel(); mLGTvControl.nextChannel(); mLGTvControl.preChannel(); mLGTvControl.Onoff(); mSonyTvControl.Onoff(); mSonyTvControl.preChannel(); mSonyTvControl.preChannel(); mSonyTvControl.preChannel(); mSonyTvControl.Onoff(); newTvControl mSharpTvControl; mSharpTvControl=new newTvControl(new SharpControl()); mSharpTvControl.Onoff(); mSharpTvControl.nextChannel(); mSharpTvControl.setChannel(9); mSharpTvControl.setChannel(28); mSharpTvControl.Back(); mSharpTvControl.Onoff(); &#125;&#125; 3. 桥接模式与策略模式的差异 桥接模式的目的是让底层实现和上层接口可以分别演化，从而提高移植性 策略模式的目的是将复杂的算法封装起来，从而便于替换不同的算法 桥接模式是往往是为了利用已有的类或方法 策略模式是为了扩展和修改，并提供动态配置 桥接模式强调接口对象仅仅提供基本操作 策略模式强调接口对象提供的是一种算法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2F2018%2F10%2F17%2FAdapterMode%2F</url>
    <content type="text"><![CDATA[设计模式之适配器模式1. 什么是适配器模式Adapter模式也叫适配器模式，是构造型模式之一，通过Adapter模式可以改变已有类（或外部类）的接口形式。就是将一个类的接口转换成另一个接口，让原本接口不兼容的类可以兼容。 从用户的角度是看不到被适配者的，是解耦的，用户只是调用了适配器转换出来的目标接口方法。 适配器模式的一般的使用场景： 在大规模的系统开发过程中，我们常常碰到诸如以下这些情况：我们需要实现某些功能，这些功能已有还不太成熟的一个或多个外部组件，如果我们自己重新开发这些功能会花费大量时间；所以很多情况下会选择先暂时使用外部组件，以后再考虑随时替换。但这样一来，会带来一个问题，随着对外部组件库的替换，可能需要对引用该外部组件的源代码进行大面积的修改，因此也极可能引入新的问题等等。如何最大限度的降低修改面呢？Adapter模式就是针对这种类似需求而提出来的。Adapter模式通过定义一个新的接口（对要实现的功能加以抽象），和一个实现该接口的Adapter（适配器）类来透明地调用外部组件。这样替换外部组件时，最多只要修改几个Adapter类就可以了，其他源代码都不会受到影响。 适配器模式有两种实现的方式： 类适配器（继承实现） 通过多重继承目标接口和被适配者类方式来实现适配。 多重继承，其中继承的目标接口部分达到适配目的，而继承被适配者类的部分达到通过调用被适配者类里的方法来实现目标接口的功能。但是java是不支持多重继承的，但是可以继承类然后继承接口，算是间接的实现了多重继承吧。 对象适配器（委让实现） 对象适配器和类适配器使用了不同的方法实现适配，对象适配器使用组合，类适配器使用继承. 2. 具体实例适配器的话其实向转换器，比如usb转type C这样子的。 这个举一个项目的例子：用火鸡冒充鸭子。 就是外在是鸭子，其实内在是火鸡，就是用火鸡冒充鸭子。 首先通过类对象适配器的方式来实现 1234public interface Turkey &#123; public void gobble(); public void fly();&#125; 1234567891011121314public class WildTurkey implements Turkey &#123; @Override public void gobble() &#123; // TODO Auto-generated method stub System.out.println(" Go Go"); &#125; @Override public void fly() &#123; // TODO Auto-generated method stub System.out.println("I am flying a short distance"); &#125;&#125; Duck的实现同理 对象适配器 1234567891011121314151617public class TuckeyAdapter implements Duck&#123; private Turkey turkey; public TuckeyAdapter(Turkey turkey)&#123; this.turkey = turkey; &#125; @Override public void quack() &#123; turkey.gobble(); &#125; @Override public void fly() &#123; turkey.fly(); turkey.fly(); turkey.fly(); &#125;&#125; 类适配器 123456789101112131415public class TurkeyAdapter2 extends WildTurkey implements Duck &#123; @Override public void quack() &#123; // TODO Auto-generated method stub super.gobble(); &#125; @Override public void fly() &#123; // TODO Auto-generated method stub super.fly(); super.fly(); super.fly(); &#125;&#125; 通过上面两种适配器模式其实我们就实现了火鸡冒充鸭子。 对象适配器模式其实是通过使用对象组合，以修改的接口去包装被适配者，所以他不仅可以适配某个类，而且可以适配该类的任何子类；而类适配器需要多重的继承。 其实就是改了下外在，但是内在不变，有点像装饰者模式哈，因为就像给火鸡做了一层外包装。但是装饰者模式和适配器模式还是不一样的，一方面装饰者模式是可以继承和嵌套超类的，但是这里的适配器模式是只能继承某一接口，并且适配器模式是接口功能的改变，不能扩展，但是装饰者模式是为了实现某些功能的扩展，举个例子吧，比如usb转换器这个东西，我们要给他添加什么电容保护什么功能的时候用装饰者模式，然后我们要将其转换成type C 的接口就要用适配器模式，也就是让他适配type C的功能模式。 3. 从枚举器到迭代器的适配java的老版本中有枚举器，现在改成了迭代器，就是有一些类似于Collection，HashMap这种高级的数据结构的遍历使用的迭代器。 为了老代码的好维护，需要从枚举器到迭代器的适配。只不过枚举器中没有remove()方法，就直接抛出异常了。 123456789101112131415161718192021222324252627public class EnumerationIterator implements Iterator&lt;Object&gt; &#123; private Enumeration enumeration; public EnumerationIterator(Enumeration enumeration) &#123; this.enumeration= enumeration; &#125; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub return enumeration.hasMoreElements(); &#125; @Override public Object next() &#123; // TODO Auto-generated method stub return enumeration.nextElement(); &#125; @Override public void remove() &#123; // TODO Auto-generated method stub throw new UnsupportedOperationException(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之装饰者模式]]></title>
    <url>%2F2018%2F10%2F07%2Fdecorator%2F</url>
    <content type="text"><![CDATA[设计模式之装饰者模式1. 什么是装饰者模式 装饰（ Decorator ）模式又叫做包装模式。通过一种对客户端透明的方式来扩展对象的功能，是继承关系的一个替换方案。 装饰者模式的结构如下图所示： 抽象组件角色： 一个抽象接口，是被装饰类和、装饰类的父接口。 具体组件角色：为抽象组件的实现类。 抽象装饰角色：包含一个组件的引用，并定义了与抽象组件一致的接口。 具体装饰角色：为抽象装饰角色的实现类。负责具体的装饰。 2. 简单实例以一个简单的咖啡馆订单系统项目为例来一步步的介绍装饰者模式 咖啡馆订单项目： 1） 咖啡种类：Espresso、ShortBlack、LongBlack、Decaf 2） 调料：Milk、Soy、Chocolate 3） 扩展性好、改动方便、维护方便 首先按照我们的想法是： 就是设计一个Drink的类（咖啡的种类）然后在设计调料的类去扩展和组合，这样的话导致的问题就是我要添加新的调料的时候就需要添加很多的组合，这样的话就会导致添加很多的类，不容易维护和扩展 一个新的想法就是： 我重新设计下Drink类，调料直接添加在里面，然后设计咖啡类，每次添加调料的时候去查找有还是没有，然后进行添加，这样的话省掉了调料整合的问题，但是还是存在问题的，就是在添加新的调料的时候需要更新Drink这个类，这样其实也带来了扩展的不方便。 所以基于装饰者模式的思想，可以重新设计上面的项目，装饰者模式的设计思想其实可以看做是打包快递的过程，我要打包一件衣服，我需要包装袋和纸箱子，衣服就是主体，包装袋就是装饰，改变的时候就扩展包装就可以了。 重新设计的方案如上，Drink最为超类，然后咖啡去继承和扩展他，然后设计一个装饰者的类，去扩展Drink，然后调料的类去继承和扩展Decorator,这样的话每次更新调料，只需要添加新的继承自Decorator即可。下面给出具体的代码。 12345678910111213141516171819202122232425public abstract class Drink &#123; public String description=""; private float price=0f; public void setDescription(String description) &#123; this.description=description; &#125; public String getDescription() &#123; return description+"-"+this.getPrice(); &#125; public float getPrice() &#123; return price; &#125; public void setPrice(float price) &#123; this.price=price; &#125; public abstract float cost(); &#125; Coffee 作为一个中间层： 12345678public class Coffee extends Drink &#123; @Override public float cost() &#123; // TODO Auto-generated method stub return super.getPrice(); &#125;&#125; 12345678public class Espresso extends Coffee&#123; public Espresso() &#123; super.setDescription("Espresso"); super.setPrice(4.0f); &#125;&#125; 其他的咖啡同理……. 1234567891011121314151617181920public class Decorator extends Drink &#123; private Drink Obj; public Decorator(Drink Obj)&#123; this.Obj=Obj; &#125; @Override public float cost() &#123; // TODO Auto-generated method stub return super.getPrice()+Obj.cost(); &#125; @Override public String getDescription() &#123; return super.description+"-"+super.getPrice()+"&amp;&amp;"+Obj.getDescription(); &#125;&#125; 123456789public class Chocolate extends Decorator &#123; public Chocolate(Drink Obj) &#123; super(Obj); // TODO Auto-generated constructor stub super.setDescription("Chocolate"); super.setPrice(3.0f); &#125;&#125; 其他的调料同理…….. 1234567891011121314151617 public static void main(String[] args) &#123; Drink order; order=new Decaf(); System.out.println("order1 price:"+order.cost()); System.out.println("order1 desc:"+order.getDescription()); System.out.println("****************"); order=new LongBlack(); order=new Milk(order); order=new Chocolate(order); order=new Chocolate(order); System.out.println("order2 price:"+order.cost()); System.out.println("order2 desc:"+order.getDescription()); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之观察者模式]]></title>
    <url>%2F2018%2F10%2F07%2Fobserver%2F</url>
    <content type="text"><![CDATA[设计模式之观察者模式1. 什么是观察者模式Observer模式是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态。这样的话就不会错过该对象感兴趣的事情。对象甚至可以在运行时决定是否需要继续被通知。 Observer模式提供给关联对象一种同步通信的手段，使某个对象与依赖它的其他对象之间保持状态同步。 Subject（被观察者）被观察的对象。当需要被观察的状态发生变化时，需要通知队列中所有观察者对象。Subject需要维持（添加，删除，通知）一个观察者对象的队列列表。 ConcreteSubject被观察者的具体实现。包含一些基本的属性状态及其他操作。 Observer（观察者）接口或抽象类。当Subject的状态发生变化时，Observer对象将通过一个callback函数得到通知。 ConcreteObserver观察者的具体实现。得到通知后将完成一些具体的业务逻辑处理。 2. 具体实例首先我有一个Internet的气象站项目： 提供温度、气压和湿度的接口 测量数据更新时需时时通知给第三方 需要设计开放型API，便于其他第三方公司也能接入气象站获取数据 我首先按照面向对象的设计过程，我首先想到的是设计两个类，一个是天气的数据，一个就是公告板也就是对天气的数据进行操作的类 具体实现如下： CurrentConditions: 123456789101112131415161718192021public class CurrentConditions &#123; private float mTemperature; private float mPressure; private float mHumidity; public void update(float mTemperature,float mPressure,float mHumidity) &#123; this.mTemperature=mTemperature; this.mPressure=mPressure; this.mHumidity=mHumidity; display(); &#125; public void display() &#123; System.out.println("***Today mTemperature: "+mTemperature+"***"); System.out.println("***Today mPressure: "+mPressure+"***"); System.out.println("***Today mHumidity: "+mHumidity+"***"); &#125;&#125; WeatherData: 12345678910111213141516171819202122232425262728293031public class WeatherData &#123; private float mTemperature; private float mPressure; private float mHumidity; private CurrentConditions currentConditions; public WeatherData( CurrentConditions currentConditions)&#123; this.currentConditions = currentConditions; &#125; public float getmTemperature() &#123; return mTemperature; &#125; public float getmPressure() &#123; return mPressure; &#125; public float getmHumidity() &#123; return mHumidity; &#125; public void dataChange()&#123; currentConditions.update( getmTemperature(),getmPressure(),getmHumidity()); &#125; public void setData(float mTemperature,float mPressure,float mHumidity) &#123; this.mTemperature=mTemperature; this.mPressure=mPressure; this.mHumidity=mHumidity; dataChange(); &#125;&#125; 这样设计带来的问题是什么呢？ 1）其他第三方公司接入气象站获取数据的问题 2）无法在运行时动态的添加第三方 也就是说我们想要再添加新的公告板的时候，同时需要更改WeatherData类，这样的话工作量变大，不符合设计要求。 根据上面观察者模式，我们重新设计我们的方案，也就是留出subject和observer两个接口，由WeatherDada和CurrentConditions分别继承实现，这样的话我再来新的公告板的话只需要扩展observer这个接口就可以了。 observer接口： 123public interface Observer &#123; public void update(float mTemperatrue,float mPressure,float mHumidity);&#125; subject接口： 123456public interface Subject &#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers();&#125; WeatherDataSt继承自subject，然后observer由ArrayList组成，这样的话每扩展一个公告板就只需要注册Observer就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class WeatherDataSt implements Subject &#123; private float mTemperature; private float mPressure; private float mHumidityp; ArrayList&lt;Observer&gt; observers; public float getmTemperature() &#123; return mTemperature; &#125; public float getmPressure() &#123; return mPressure; &#125; public float getmHumidityp() &#123; return mHumidityp; &#125; public WeatherDataSt()&#123; observers = new ArrayList&lt;&gt;(); &#125; @Override public void registerObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; if (observers.contains(o))&#123; observers.remove(o); &#125; &#125; @Override public void notifyObservers() &#123; for (int i = 0; i &lt; observers.size(); i++)&#123; observers.get(i).update(getmTemperature(),getmPressure(),getmHumidityp()); &#125; &#125; public void dataChange()&#123; notifyObservers(); &#125; public void setData(float mTemperature,float mPressure,float mHumidity)&#123; this.mTemperature = mTemperature; this.mPressure = mPressure; this.mHumidityp = mHumidity; dataChange(); &#125;&#125; 公告板 1234567891011121314151617181920public class ConcurrentConditions implements Observer&#123; private float mTemperature; private float mPressure; private float mHumidityp; @Override public void update(float mTemperature, float mPressure, float mHumidity) &#123; this.mTemperature =mTemperature; this.mPressure = mPressure; this.mHumidityp = mHumidity; display(); &#125; public void display()&#123; System.out.println("***Today mTemperatrue:" + mTemperature + "***"); System.out.println("***Today mPressure:" + mPressure + "***"); System.out.println("***Today mHumidity:" + mHumidityp + "***"); &#125;&#125; 这个时候我想要添加一个气象预报的公告板，只需要继承Observer接口然后在WeatherData中注册就可以了 123456789101112131415161718public class ForcastConditions implements Observer&#123; private float mTemperature; private float mPressure; private float mHumidityp; @Override public void update(float mTemperature, float mPressure, float mHumidity) &#123; this.mTemperature = mTemperature; this.mPressure = mPressure; this.mHumidityp = mHumidity; displsy(); &#125; public void displsy()&#123; System.out.println("**明天温度:"+(mTemperature+Math.random())+"**"); System.out.println("**明天气压:"+(mPressure+10*Math.random())+"**"); System.out.println("**明天湿度:"+(mHumidityp+Math.random())+"**"); &#125;&#125; 12345678910111213public class InternetWeatherOb &#123; public static void main(String[] args)&#123; ConcurrentConditions concurrentConditions = new ConcurrentConditions(); WeatherDataSt weatherDataSt = new WeatherDataSt(); weatherDataSt.registerObserver(concurrentConditions); weatherDataSt.setData(10,200,20); ForcastConditions forcastConditions = new ForcastConditions(); weatherDataSt.registerObserver(forcastConditions); weatherDataSt.setData(20,300,30); &#125;&#125; 通过上面的例子我们可以看出通过观察者模式，我们可以轻松的扩展程序，扩展后只需要让观察者通知被观察者发生的改变即可。 其实观察者模式有两种的实现方式，就是推和拉的模式，推的模式其实就是有主题去通知观察者那些状态发生了改变，拉的方式就是有观察者自己去获取自己需要的状态的改变，对于不需要的不需要获取。 3. java内置的观察者模式Java内置的观察者： Observable Observer 接下来通过内置的观察者模式来上面的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class WeatherData extends Observable&#123; private float mTemperatrue; private float mPressure; private float mHumidity; public float getTemperature() &#123; return mTemperatrue; &#125; public float getPressure() &#123; return mPressure; &#125; public float getHumidity() &#123; return mHumidity; &#125; public void dataChange()&#123; this.setChanged(); //boolean类型的，是否发生了改变 this.notifyObservers(new Data(getTemperature(),getPressure(),getHumidity())); //通知观察者发生的改变 &#125; public void setData(float mTemperatrue,float mPressure,float mHumidity) &#123; this.mTemperatrue=mTemperatrue; this.mPressure=mPressure; this.mHumidity=mHumidity; dataChange(); &#125; public class Data &#123; public float mTemperatrue; public float mPressure; public float mHumidity; public Data(float mTemperatrue,float mPressure,float mHumidity) &#123; this.mTemperatrue=mTemperatrue; this.mPressure=mPressure; this.mHumidity=mHumidity; &#125; &#125;&#125; 1234567891011121314151617181920public class ConcurrentConditions implements Observer &#123; private float mTemperature; private float mPressure; private float mHumidityp; @Override public void update(Observable o, Object arg) &#123; this.mTemperature = ((WeatherData.Data) arg).mTemperatrue; this.mPressure = ((WeatherData.Data) arg).mPressure; this.mHumidityp = ((WeatherData.Data) arg).mHumidity; display(); &#125; public void display() &#123; System.out.println("***Today mTemperatrue:" +mTemperature+"***"); System.out.println("***Today mPressure:" +mPressure+"***"); System.out.println("***Today mHumidity:" +mHumidityp+"***"); &#125;&#125; 12345678public class InternetWeather &#123; public static void main(String[] args)&#123; ConcurrentConditions concurrentConditions = new ConcurrentConditions(); WeatherData weatherData = new WeatherData(); weatherData.addObserver(concurrentConditions); //添加 weatherData.setData(10,100,10); &#125;&#125; 其实就是通过继承Java内部的Observable和Observer，实现观察者模式，不用自己去写这俩个接口了。 4. 典型应用Observer模式的典型应用: 侦听事件驱动程序设计中的外部事件 侦听/监视某个对象的状态变化 发布者/订阅者(publisher/subscriber)模型中，当一个外部事件（新的产品，消息的出现等等）被触发时，通知邮件列表中的订阅者]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式]]></title>
    <url>%2F2018%2F10%2F07%2Ffactory%2F</url>
    <content type="text"><![CDATA[设计模式之工厂模式工厂模式分为以下三种： 简单工厂模式 工厂方法模式 抽象工厂模式 1. 简单工厂模式1.1 什么是简单工厂模式 简单工厂模式属于类的创建型模式,又叫做静态工厂方法模式。通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 工厂（Creator）角色：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 抽象（Product）角色： 简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品（Concrete Product）角色：简单工厂模式所创建的具体实例对象 优缺点： 优点：在这个模式中，工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。当需要大量的创建实例对象的时候使用工厂模式是可以的。 缺点：不难发现，简单工厂模式的缺点也正体现在其工厂类上，由于工厂类集中了所有实例的创建逻辑，所以“高内聚”方面做的并不好。另外，当系统中的具体产品类不断增多时，可能会出现要求工厂类也要做相应的修改，扩展性并不很好。 1.2 具体实例：以一个披萨店为例，从下单到派送整个过程 首先需要一个Pizza的抽象类，现在是假设不同的披萨的烘焙，切割，装盒都是一样的，不同之处只是在原料。所以需要一个抽象类。 12345678910111213141516171819public abstract class Pizza &#123; public String name; public abstract void Prepare(); public void bake()&#123; System.out.println(name + ":"+ "bake"); &#125; public void cut()&#123; System.out.println(name + ":"+ "cut"); &#125; public void box()&#123; System.out.println(name + ":"+ "box"); &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; 不同的披萨去继承和扩展该类 1234567public class CheesePizza extends Pizza &#123; @Override public void Prepare() &#123; super.setName("CheesePizza"); System.out.println(name + "preparing" ); &#125;&#125; 其余类型的同理。 然后下单 12345678910111213141516171819202122232425262728293031323334353637383940public class OrderPizza &#123; public OrderPizza() &#123; Pizza pizza = null; String ordertype; do &#123; ordertype = gettype(); if (ordertype.equals("cheese")) &#123; pizza = new CheesePizza(); &#125; else if (ordertype.equals("greek")) &#123; pizza = new GreekPizza(); &#125; else if (ordertype.equals("pepper")) &#123; pizza = new PepperPizza(); &#125; else if (ordertype.equals("chinese")) &#123; pizza = new ChinesePizza(); &#125; else &#123; break; &#125; pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); &#125; while (true); &#125; private String gettype() &#123; try &#123; BufferedReader strin = new BufferedReader(new InputStreamReader( System.in)); System.out.println("input pizza type:"); String str = strin.readLine(); return str; &#125; catch (IOException e) &#123; e.printStackTrace(); return ""; &#125; &#125;&#125; 上面的那个类我们可以看出，每次添加新的披萨种类的时候我们需对这个类进行更新，不太符合对扩展开放，对修改封闭的开闭原则，所以我们需要用到工厂模式进行修改： 工厂模式：就是我们下单的时候需要很多的披萨的实例，要是直接就封装在下单的类中的话每次进行更改的话就需要不断地重现更改和加载那个类，所以就把实例有更改的地方抽取出来，单独作为一个类，就是所谓的工厂类。 1234567891011121314public class SimplePizzaFactory &#123; public Pizza CreatePizza(String orderType)&#123; Pizza pizza = null; if (orderType.equals("cheese")) &#123; pizza = new CheesePizza(); &#125; else if (orderType.equals("greek")) &#123; pizza = new GreekPizza(); &#125; &#125; else if (orderType.equals("pepper")) &#123; pizza = new PepperPizza(); &#125; return pizza; &#125;&#125; 订单： 1234567891011121314151617181920212223242526272829303132public class OrderPizza &#123; public OrderPizza(SimplePizzaFactory simplePizzaFactory)&#123; setSimplePizzaFactory(simplePizzaFactory); &#125; public void setSimplePizzaFactory(SimplePizzaFactory simplePizzaFactory)&#123; String orderType; do &#123; orderType = getType(); Pizza pizza =simplePizzaFactory.CreatePizza(orderType); if (pizza != null)&#123; pizza.Prepare(); pizza.bake(); pizza.cut(); pizza.box(); &#125; &#125;while (true); &#125; private String getType()&#123; try &#123; BufferedReader strIn = new BufferedReader(new InputStreamReader(System.in)); System.out.println("input pizza type"); String str = strIn.readLine(); return str; &#125;catch (IOException e)&#123; e.printStackTrace(); return ""; &#125; &#125;&#125; 12345public class PizzaStore &#123; SimplePizzaFactory simplePizzaFactory = new SimplePizzaFactory(); OrderPizza orderPizza = new OrderPizza(simplePizzaFactory);&#125; 上面的例子就是简单工厂模式的一个下例子。 2. 工厂方法模式2.1什么是工厂方法模式工厂方法模式同样属于类的创建型模式又被称为多态工厂模式 。工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 抽象工厂（Creator）角色:工厂方法模式的核心，任何工厂类都必须实现这个接口。 具体工厂（ Concrete Creator）角色:具体工厂类是抽象工厂的一个实现，负责实例化产品对象。 抽象（Product）角色:工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品（Concrete Product）角色 工厂方法模式所创建的具体实例对象 与简单工厂模式的比较： 工厂方法模式与简单工厂模式在结构上的不同不是很明显。工厂方法类的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。 工厂方法模式之所以有一个别名叫多态性工厂模式是因为具体工厂类都有共同的接口，或者有共同的抽象父类。 当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，很好的符合了“开放－封闭”原则。而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。 工厂方法模式退化后可以演变成简单工厂模式。 2.2 具体实例还是上面的例子，如果说我想要扩展了新的门店了，然后不同的门店是由不同的味道的，然后这个程序要扩展的话就需要修改工厂模式类，去new不同门店的实例，这样的话维护起来比较费劲，所以用工厂方法模式来进行改进，就是把工厂模式抽象成方法，具体如下： 首先就是订单类我们把该类做成抽象类，我们CreatePizza（）这个方法单独拿出来变成抽象方法，由不同门店的类去扩展该类。 12345678910111213141516171819202122232425262728293031public abstract class OrderPizza &#123; Pizza pizza = null; public String orderType; public OrderPizza()&#123; do &#123; orderType = getType(); pizza = CreatePizza(orderType); if (pizza != null)&#123; pizza.Prepare(); pizza.bake(); pizza.cut(); pizza.box(); &#125; &#125;while (true); &#125; public abstract Pizza CreatePizza(String OrderType); private String getType()&#123; try &#123; BufferedReader strIn = new BufferedReader(new InputStreamReader(System.in)); System.out.println("input pizza type"); String str = strIn.readLine(); return str; &#125;catch (IOException e)&#123; e.printStackTrace(); return ""; &#125; &#125;&#125; 其中的一家店的类： 1234567891011121314public class LDOrderPizza extends OrderPizza &#123; @Override public Pizza CreatePizza(String OrderType) &#123; Pizza pizza = null; if (orderType.equals("cheese")) &#123; pizza = new LDCheesePizza(); &#125; else if (orderType.equals("pepper")) &#123; pizza = new LDPepperPizza(); &#125; return pizza; &#125;&#125; 其余的所有的都是同理的，里面的一些披萨的具体的实例的初始化的类其实和上面是一样的，就不再赘述了。 12345public class PizzaStore &#123; public static void main(String[] args)&#123; LDOrderPizza orderPizza = new LDOrderPizza(); &#125;&#125; 3. 抽象工厂模式3.1 什么是抽象工厂模式 抽象工厂模式是所有形态的工厂模式中最为抽象和最其一般性的。抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，能够创建多个产品族的产品对象。 抽象工厂（Creator）角色: 抽象工厂模式的核心，包含对多个产品结构的声明，任何工厂类都必须实现这个接口。 具体工厂（ Concrete Creator）角色:具体工厂类是抽象工厂的一个实现，负责实例化某个产品族中的产品对象。 抽象（Product）角色: 抽象模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品（Concrete Product）角色:抽象模式所创建的具体实例对象总结：抽象工厂中方法对应产品结构，具体工厂对应产品族。 3.2 具体实例其实抽象工厂模式就是定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类。也可以看做是把简单工厂模式抽象成了两级，抽象工厂的接口和具体的实现，形成工厂族。 还是上面的那个披萨店的例子，我们创建一个抽象工厂的接口，然后由不同的具体的工厂去继承该接口形成工厂族，然后在订单中去new抽象工厂就可以了，让他自己去选择下面是具体怎么实现的，具体的实现如下面所示： 抽象工厂接口： 1234public interface AbsFactory &#123; public Pizza CreatePizza(String ordertype) ;&#125; 不同具体的实现类： 1234567891011121314public class NYFactory implements AbsFactory &#123; @Override public Pizza CreatePizza(String ordertype) &#123; Pizza pizza = null; if (ordertype.equals("cheese")) &#123; pizza = new NYCheesePizza(); &#125; else if (ordertype.equals("pepper")) &#123; pizza = new NYPepperPizza(); &#125; return pizza; &#125;&#125; 1234567891011121314public class LDFactory implements AbsFactory&#123; @Override public Pizza CreatePizza(String ordertype) &#123; Pizza pizza = null; if (ordertype.equals("cheese")) &#123; pizza = new LDCheesePizza(); &#125; else if (ordertype.equals("pepper")) &#123; pizza = new LDPepperPizza(); &#125; return pizza; &#125;&#125; 订单： 12345678910111213141516171819202122232425262728293031323334353637public class AbsOrderPizza &#123; AbsFactory absFactory; public AbsOrderPizza(AbsFactory absFactory)&#123; setAbsFactory(absFactory); &#125; private void setAbsFactory(AbsFactory absFactory)&#123; Pizza pizza = null; String ordertype; do &#123; ordertype = getOrderType(); this.absFactory = absFactory; if (absFactory != null)&#123; pizza = absFactory.CreatePizza(ordertype); pizza.bake(); pizza.cut(); pizza.box(); &#125; &#125;while (true); &#125; private String getOrderType()&#123; try&#123; BufferedReader strIn = new BufferedReader(new InputStreamReader(System.in)); System.out.println("input pizza type:"); String strs = strIn.readLine(); return strs; &#125;catch (IOException e)&#123; e.printStackTrace(); return ""; &#125; &#125;&#125; 在订单类中直接使用抽象工厂的接口就可以了，而不必去实现具体的什么工厂。 12345public class PizzaStore &#123; public static void main(String[] args)&#123; AbsOrderPizza order = new AbsOrderPizza(new LDFactory()); &#125;&#125; 总结其实通过工厂模式我们可以看到一种设计规则就是依赖抽象原则，这也是设计模式的6大原则之一，依赖抽象原则的意义： 变量不要持有具体类的引用 比方说我们这里面的我要去new 一个具体的工厂类，这这其实就是依赖性比较强了。 不要让类继承自具体类，要继承自抽象类或接口，要是直接继承具体类的话依赖关系就很强了，不适合维护和扩展。 不要覆盖基类中已经实现的方法。因为基类中的方法是通用方法，你要是有方法需要进行覆盖的话，这种方法是个性化的方法，你需要在具体类中去实现。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2018%2F10%2F07%2Fsingleton%2F</url>
    <content type="text"><![CDATA[设计模式之单例模式1. 什么是单例模式 单例模式是一种对象创建型模式，使用单例模式，可以保证为一个类只生成唯一的实例对象。也就是说，在整个程序空间中，该类只存在一个实例对象。 其实，GoF对单例模式的定义是：保证一个类、只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。 应用场景： 在应用系统开发中，我们常常有以下需求： 在多个线程之间，比如servlet环境，共享同一个资源或者操作同一个对象 在整个程序空间使用全局变量，共享资源 大规模系统中，为了性能的考虑，需要节省对象的创建时间等等。 因为Singleton模式可以保证为一个类只生成唯一的实例对象，所以这些情况，Singleton模式就派上用场了。 实现： 饿汉式。 懒汉式。 双重检查。 2. 具体实例经典单例模式的类视图如下： 1234567891011121314public class Singleton &#123; private static Singleton uniqeInstance=null; private Singleton()&#123; //private类型的构造函数只能在类内部进行new，类外是不可获取的，就和private修饰的变量一样 &#125; public static Singleton getInstance()&#123; if (uniqeInstance == null)&#123; uniqeInstance = new Singleton(); &#125; return uniqeInstance; &#125;&#125; 通过上面的这种方式就实现了实例的new操作的控制，保证唯一性。只有uniqeInstance为null的时候才会new。这其实也就是懒汉式。 举一个应用的例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ChocolateFactory &#123; private boolean empty; private boolean boiled; public static ChocolateFactory uniqueInstance = null; private ChocolateFactory() &#123; empty = true; boiled = false; &#125; public static ChocolateFactory getInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new ChocolateFactory(); &#125; return uniqueInstance; &#125; public void fill() &#123; if (empty) &#123; // 添加原料巧克力动作 empty = false; boiled = false; &#125; &#125; public void drain() &#123; if ((!empty) &amp;&amp; boiled) &#123; // 排出巧克力动作 empty = true; &#125; &#125; public void boil() &#123; if ((!empty) &amp;&amp; (!boiled)) &#123; // 煮沸 boiled = true; &#125; &#125;&#125; 其实就是控制ChocolateFactory的实例对象只有一个。 上面的这种设计方式是存在问题的，当多线程同时访问的时候，会new出多个对象。这样的话其实就和单例模式的初衷相违背。怎么去解决呢？ 使用synchronized同步锁，也就是在public synchronized static ChocolateFactory getInstance()加上锁，这样就保证每次只有一个线程访问该方法。 这种方式的缺点是消耗资源，也就是当你需要频繁的访问该方法的时候就会大量的使用同步锁，对于资源得消耗也很大。 “急切”创建实例（饿汉式），其实就是在类初始化的时候就把public static ChocolateFactory uniqueInstance = new ChocolateFactory (); 这样其实就是提前占用一定的空间呗。当你不需要的时候他也存在。 双重检查：首先使用volatilepublic volatile static ChocolateFactory uniqueInstance = null;，然后在构造方法出再加锁： 123456789101112public synchronized static ChocolateFactory getInstance() &#123; if (uniqueInstance == null) &#123; synchronized (ChocolateFactory.class)&#123; if (uniqueInstance == null)&#123; uniqueInstance = new ChocolateFactory(); &#125; &#125; &#125; return uniqueInstance;&#125; 这样的话就保证了线程安全的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F2018%2F10%2F07%2Fstrategy%2F</url>
    <content type="text"><![CDATA[设计模式之策略模式1. 定义策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为算法的变化独立于算法的使用者。 策略模式定义了算法簇，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法上客户。 策略模式的结构图如下： 策略模式 Strategy: 定义所有支持的算法的公共接口抽象类. ConcreteStrategy: 封装了具体的算法或行为，继承于Strategy Context: 用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。 Strategy模式有下面的一些优点： 12341) 相关算法系列 Strategy类层次为Context定义了一系列的可供重用的算法或行为。 继承有助于析取出这些算法中的公共功能。2) 提供了可以替换继承关系的办法： 继承提供了另一种支持多种算法或行为的方法。你可以直接生成一个Context类的子类，从而给它以不同的行为。但这会将行为硬行编制到 Context中，而将算法的实现与Context的实现混合起来,从而使Context难以理解、难以维护和难以扩展，而且还不能动态地改变算法。最后你得到一堆相关的类 , 它们之间的唯一差别是它们所使用的算法或行为。 将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。3) 消除了一些if else条件语句 ：Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时 ,很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句。含有许多条件语句的代码通常意味着需要使用Strategy模式。4) 实现的选择 Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间 /空间权衡取舍要求从不同策略中进行选择。 Strategy模式缺点: 1231)客户端必须知道所有的策略类，并自行决定使用哪一个策略类: 本模式有一个潜在的缺点，就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同。此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时 , 才需要使用Strategy模式。2 ) Strategy和Context之间的通信开销 ：无论各个ConcreteStrategy实现的算法是简单还是复杂, 它们都共享Strategy定义的接口。因此很可能某些 ConcreteStrategy不会都用到所有通过这个接口传递给它们的信息；简单的 ConcreteStrategy可能不使用其中的任何信息！这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题 , 那么将需要在Strategy和Context之间更进行紧密的耦合。3 )策略模式将造成产生很多策略类：可以通过使用享元模式在一定程度上减少对象的数量。 增加了对象的数目 Strategy增加了一个应用中的对象的数目。有时你可以将 Strategy实现为可供各Context共享的无状态的对象来减少这一开销。任何其余的状态都由 Context维护。Context在每一次对Strategy对象的请求中都将这个状态传递过去。共享的 Strategy不应在各次调用之间维护状态。 2. 具体代码从项目“模拟鸭子游戏开始”： 首先定义一个超类DUCK： 1234567891011121314public abstract class Duck &#123; public Duck() &#123; &#125; public void Quack() &#123; System.out.println("~~gaga~~"); &#125; public abstract void display(); public void swim() &#123; System.out.println("~~im swim~~"); &#125; 然后有GreenHeadDuck继承Duck ，并且重写父类的方法： 123456public class GreenHeadDuck extends Duck &#123; @Override public void display() &#123; System.out.println("**GreenHead**"); &#125; 同理可有RedHeadDuck等继承了DUCk 现在我们有一个新的需求; (1)添加会飞的鸭子 我们想的就是在DUCK这个类里面添加一个方法 12345public abstract class Duck &#123; ... public void Fly() &#123; System.out.println("~~im fly~~"); &#125; 然后这样的话就导致了所有的鸭子都是会飞的，那要是有些鸭子不会飞呢， 然后我们想的是在子类里面重写这个方法，例如 123456public class GreenHeadDuck extends Duck &#123; ... @Override public void Fly() &#123; System.out.println("~~no fly~~"); &#125; 这样的话所有的不会飞的鸭子全部要改动，这样的话工作量很大，上面的设计思想就是我们经常会想到的方法，也就是用面向对象的方式去设计。 继承的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。影响会有溢出效应 而且超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式 需要新的设计方式，应对项目的扩展性，降低复杂度： 1）分析项目变化与不变部分，提取变化部分，抽象成接口+实现； 2）鸭子哪些功能是会根据新需求变化的？叫声、飞行… 所以设计两个接口一个是飞行，一个是叫声 123public interface FlyBehavior &#123; void fly();&#125; 123public interface QuackBehavior &#123; void quack();&#125; 然后不同的叫声各种实现这个叫声接口例如 12345678public class GaGaQuackBehavior implements QuackBehavior&#123; @Override public void quack() &#123; // TODO Auto-generated method stub System.out.println("__GaGa__"); &#125; &#125; 12345678public class GeGeQuackBehavior implements QuackBehavior&#123; @Override public void quack() &#123; // TODO Auto-generated method stub System.out.println("__GeGe__"); &#125;&#125; 重新设计DUCK这个类 12345678910111213141516171819202122232425262728293031public abstract class Duck &#123; FlyBehavior mFlyBehavior; QuackBehavior mQuackBehavior; public Duck() &#123; &#125; public void Fly() &#123; mFlyBehavior.fly(); &#125; public void Quack() &#123; mQuackBehavior.quack(); &#125; public abstract void display(); public void SetQuackBehavoir(QuackBehavior qb) &#123; mQuackBehavior = qb; &#125; public void SetFlyBehavoir(FlyBehavior fb) &#123; mFlyBehavior = fb; &#125; public void swim() &#123; System.out.println("~~im swim~~"); &#125;&#125; 重写DUCK的子类GreenHeadDuck ： 12345678public class GreenHeadDuck extends Duck &#123; public GreenHeadDuck() &#123; mFlyBehavior = new GoodFlyBehavior(); //实例化的时候必须要传入的参数，因为在具体的父类中会用到，并且在用的时候用的是父类中的方法，而且你不必去计较底层是怎么实现的 mQuackBehavior = new GaGaQuackBehavior(); &#125; @Override public void display() &#123;...&#125;&#125; 这样的话在添加不同的新的需求的时候可以直接添加新的接口和具体的实现类，最后在你需要的地方通过这些实现类来实例化你的对象就可以了 12345678910111213141516171819public static void main(String[] args) &#123; Duck mGreenHeadDuck = new GreenHeadDuck(); Duck mRedHeadDuck = new RedHeadDuck(); mGreenHeadDuck.display(); mGreenHeadDuck.Fly(); mGreenHeadDuck.Quack(); mGreenHeadDuck.swim(); mRedHeadDuck.display(); mRedHeadDuck.Fly(); mRedHeadDuck.Quack(); mRedHeadDuck.swim(); mRedHeadDuck.display(); mRedHeadDuck.SetFlyBehavoir(new NoFlyBehavior()); mRedHeadDuck.Fly(); mRedHeadDuck.SetQuackBehavoir(new NoQuackBehavior()); mRedHeadDuck.Quack(); &#125; 最终通过策略模式设计实现的框架如下图所示。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F10%2F07%2FDesignPattern%2F</url>
    <content type="text"><![CDATA[设计模式（参考《Head First 设计模式》）设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 1. 设计模式的分类总体来说设计模式分为三大类： 创建型模式：对象实例化的模式，创建型模式解耦了对象的实例化过程。一共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式：把类或对象结合在一起形成更大的结构，一共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式：类和对象如何交互，及划分责任和算法，一共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。 2. 设计模式的六大原则总原则：开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。 实际上，绝对封闭的系统是不存在的。无论模块是怎么封闭，到最后，总还是有一些无法封闭的变化。而我们的思路就是：既然不能做到完全封闭，那我们就应该对那些变化封闭，那些变化隔离做出选择。我们做出选择，然后将那些无法封闭的变化抽象出来，进行隔离，允许扩展，尽可能的减少系统的开发。当系统变化来临时，我们要及时的做出反应。 我们并不害怕改变的到来。当变化到来时，我们首先需要做的不是修改代码，而是尽可能的将变化抽象出来进行隔离，然后进行扩展。面对需求的变化，对程序的修改应该是尽可能通过添加代码来实现，而不是通过修改代码来实现。 实际上，变化或者可能的变化来的越早，抽象就越容易，相对的，代码的维护也就越容易；而当项目接近于完成而来的需求变化，则会使抽象变得很困难——这个困难，并不是抽象本身的困难，抽象本身并没有困难，困难在于系统的架构已经完成，修改牵扯的方面太多而使得抽象工作变得很困难。 2.1 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 2.2 里氏替换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一，他是设计整个继承体系的原则。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。换句话说就是所有引用基类的地方必须能透明地使用其子类对象，使用子类替换基类的时候功能不会发生变化；子类在扩展父类功能时不能破坏父类原有的功能； 使用继承时，遵循里氏替换原则： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 当子类重载父类方法时，方法的形参要比父类方法的参数更宽松 当子类实现父类的抽象方法时，方法的返回值要比父类更严格 2.3 依赖倒置原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。要依赖于抽象，不要依赖于具体；高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖具体，具体应该依赖抽象；针对接口编程，不要针对实现编程。在java中，抽象指的是接口或者抽象类，具体就是具体的实现类。工厂方法模式，模板方法模式，迭代器模式都用到了依赖倒置原则。 2.4 接口隔离原则（Interface Segregation Principle）这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 2.5 迪米特法则（最少知识原则）（Demeter Principle）就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知识原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。成员变量、方法参数、方法返回值中需要的类为直接朋友。类与类之间的关系越密切了解越多，耦合度越大。 外观模式和中介者模式都用到了最少知识原则。 2.6 合成复用原则（Composite Reuse Principle）原则是尽量首先使用合成/聚合的方式，而不是使用继承。就是找到变化部分，抽象，封装变化。 3. 具体设计模式3.1 工厂模式简单工厂：一个工厂类根据传入的参量决定创建出哪一种产品类的实例 工厂方法：定义一个创建对象的接口，让子类决定实例化哪一个类 抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类 工厂模式 3.2 单例模式单例模式：某个类只能有一个实例，提供一个全局访问点 单例模式 3.3生成器模式生成器模式：封装一个复杂对象的构建过程，并可以按步骤构造 生成器模式 3.4原型模式原型模式：通过复制现有的实例来创建新的实例 原型模式 3.5适配器模式适配器模式：将一个类的方法接口转换成客户希望的另外一个接口 适配器模式 3.6组合模式组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构 组合模式 3.7装饰者模式装饰者模式：动态地给对象添加新的功能 装饰者模式 3.8代理模式代理模式：为其他对象提供一个代理以控制对这个对象的访问 代理模式 3.9享元模式享元模式：通过共享技术有效地支持大量细粒度的对象 享元模式 3.10外观模式外观模式：提供统一的方法来访问子系统的一群接口 外观模式 3.11桥接模式桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化 桥接模式 3.12模板模式模板模式：定义一个算法结构，而将一些步骤延迟到子类中实现 模板模式 3.13解释器模式解释器模式：给定一个语言， 定义它的文法的一种表示，并定义一个解释器 解释器模式 3.14策略模式策略模式：定义一系列的算法，把它们封装起来， 并且使它们可相互替换 策略模式 3.15状态模式状态模式：允许一个对象在其内部状态改变时改变它的行为 状态模式 3.16 观察者模式观察者模式：对象间的一对多的依赖关系 观察者模式 3.17备忘录模式备忘录模式：在不破坏封装性的前提下，保存对象的内部状态 备忘录模式 3.18中介者模式中介者模式：用一个中介对象来封装一系列的对象交互 中介者模式 3.19命令模式命令模式：将命令请求封装为一个对象，使得可用不同的请求来进行参数化 命令模式 3.20访问者模式访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素新的功能 访问者模式 3.21责任链模式责任链模式：请求发送者和接收者之间解耦，使的多个对象都有机会处理这个请求 责任链模式 3.22迭代器模式迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构 迭代器模式 3.23 复合模式复合模式：多个模式的组合 复合模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL性能优化基础]]></title>
    <url>%2F2018%2F10%2F03%2FMMSySQL-Optimization%2F</url>
    <content type="text"><![CDATA[MySQL性能优化基础MySQL性能影响的分析 服务器的硬件 服务器系统的不同 数据库存储引擎的选择（MyISAM(不支持事务，表级锁)、InnoDB（事务级存储引擎，完美的支持行级锁，事务ACID特性））。 数据库参数的配置 数据库结构的设计和SQL语句的优化 RAID磁盘冗余队列，其实就是把多个容量较小的磁盘组成一组容量更大的磁盘，并提供数据冗余来保证数据完整性的技术。 高并发的场景下CPU的数量比主频更重要，而对于CPU密集型场景和复杂的SQL频率越高越好。 centos 参数优化网络参数的优化内核相关参数（/etc/sysctl.conf） net.core.somaxconn=65535:监听队列的最大长度 net.core.netdev_max_backlog=65535第二是网络接口的速率 net.ipv4.tcp_max_syn_backlog=65535第三个是保存在队列中等待执行的速率 net.ipv4.tcp.fin_timeout = 10 :TCP 链接处理的等待时间 12net.ipv4.tcp.tw.reuse = 1net.ipv4.tcp.tw.recyle = 1 上面这两个呢就是为了加快TCP的回收 1234net.core.wemem_default = 87380net.core.wemem_max = 16777216net.core.rmem_default = 87380net.core.rmem_max = 16777216 上面四个参数就是设置TCP接收和发送的峰值，设定的大一些 123net.ipv4.tcp_keepalive_time = 120 //这是表示tcp发送keepalive的时间间隔(s)net.ipv4.tcp_keepalive_intvl = 30 //探测消息未响应的时候重发消息的时间间隔net.ipv4.tcp_keepalive_probes = 3//发送几个keepalive无响应就可以认定TCP链接无效 上面三个参数用于减少失效TCP连接占用的系统资源，尽量小。 内存参数 kernel.shmmax = 4294967295 这个参数是用于定义单个内存共享段的最大值。尽量大以便能容纳下整个Innodb缓冲池的大小。 vm.swappiness = 0 内存不足时对系统性能影响的大小。这个参数就表示除非我的Linux参数占满了否则就不使用交换分区。使用交换分区就是把一部分数据写到硬盘上，肯定会很慢，但是不使用交换分区的话一旦发生内存溢出系统崩溃。 资源限制（/etc/security/limit.conf） 打开文件数的限制 12* soft nofile 65535 * hard nofile 65535 把这两个添加到limit.conf末尾就可以了，这就把文件的限制数量提高了 磁盘调度策略 noop(电梯式的调度策略) deadline（截止时间调度策略） anticipatory（预料I/O调度策略） Innodb引擎的特性 Innodb通过使用Redo_log和undo_log实现了系统的原子性，一致性和持久性 然后通过锁实现了事务的隔离性 锁：分为共享锁和独占锁，共享锁（读锁）可以并发访问，独占锁（写锁）在执行一个写操作的时候其他的写操作会被阻塞。 锁的粒度 表级锁 开销最小的锁，但是一般开销越小的话，并发性能就差 行级锁 能够最大程度的支持并发，但是开销也大 阻塞和死锁 阻塞是一个链接阻塞其他连接的访问，一般若是发生了大量的阻塞的时候就是系统出现问题 而死锁是两个及以上的连接相互占用了对方等待的资源而造成的数据库的不能访问。死锁是可以有系统自动处理的，就是系统会自动选择一个占用资源最小的锁进行释放。 MySQL服务器参数MySQL配置参数的作用域 全局参数 12set global 参数名=参数值set @@global.参数名：参数值 会话参数 12set [session] 参数名=参数值set @@session.参数名：参数值 数据库的设计对数据库性能的影响 过分的反范式化为表建立太多的列 过分的范式化造成太多表的关联 在OLTP环境中使用了不同的分区表（分区键的设计会影响分区查询，若是跨很多个分区的话就容易造成查询过慢） 使用外键保证数据的完整性，这样的话其实修改的时候需要先对外键进行查询，就会导致额外的开销。备份恢复也会有问题。 数据库的设计范式 第一范式： 数据库表中的所有字段都只有单一属性 单一属性的列是由基本的数据类型构成的 设计出来的表示二维表 第二范式 要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系。 比如一个表中有学号和课程名称两个主键组成的复合主键，然后有一列的数据如学分这个非主键，他只和课程名称这一个主键有关，这就是非主键只对部分主键有依赖。不符合第二范式的设计要求的。 第三范式 指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主属性对主键的传递依赖。 举个例子，一个表中一个学生的学号可以查询到学院的名称和学院的电话，但是学院的名称和学院的电话和学院是相关的，因此存在传递依赖。解决的话就是将学院信息的这个表单独拆分出来。 数据库的反范式化设计有的时候遵循范式化的设计，会导致很多表的拆分和关联，这样的话查询效率会很慢，因此有的时候为了性能和读取效率的考虑需要进行一些反范式化的设计，允许存在少量的数据冗余，其实反范式化的设计就是用空间来换取时间。 物理设计 为表中字段选择合适的数据类型 当一个列可以选择多种数据类型时，优先了考虑数字类型，其次是日期或二进制类型，最后是字符类型。对相同级别的数据类型，应该优先选择占用空间小的数据类型。 VARCHAR和CHAR类型： VARCHAR用于可变长字符串，存储空间大小是以字符为存储单位的，只占用必要的存储空间。一般适用于字符串列的最大长度比平均长度大很多，字符串列很少被更新和使用了多字节字符集存储字符串。 CAHR是定长的（最大255字节），字符串存储在CAHR类型的列中会删除末尾的空格。适合存储长度近似的值，存储短字符串，存储经常更新的字符串列。 存储日期格式 DATATIME类型：与时区无关，占用8字节的存储空间 TIMESTAMP类型：只占用4字节，存储的时间范围是1970-01–1—2038-01-19，显示依赖于多指定的时区，在行的数据修改时可以自动修改timeStamp列的值 date:只占用3字节，还可以用时间函数进行计算。 time:存储时分秒微秒 MySQL复制功能MySQL复制功能提供分担读负载并且可以实现不同服务器上数据库的高可用和故障切换。 并且MySQL的复制是用二进制日志增量进行的 MySQL二进制日志二进制日志的格式 基于段的格式 binlob_format= STATEMENT: 优点是：日志记录量性对较小，节约磁盘及网络IO 缺点是：可能造成MySQL复制的主备服务器数据不一致 1必须要记录上下文的信息，保证语句在服务器上执行结果和在主服务器上执行的结果相同，但是对于UUID这种函数可能还是无法复制。 基于行的日志格式binlog_format=ROW 优点是：MySQL的主从复制更加安全。 1对每一行数据的修改比基于段的复制高效 缺点：记录的日志量较大； 混合日志格式（混合了基于行和基于段的日志格式）binlog_format=MIXED 特点是：根据SQL语句由系统决定在基于段和基于行的日志格式中进行选择 1数据量的大小有所执行的SQL语句决定的。 对复制的影响 基于SQL语句的复制（基于段的格式的日志）： 优点： 生成的日志量少，节省网络传输IO 不强制要求主从数据库的表定义完全相同 相比于基于行的复制更加灵活 缺点： 对于非确定性事件，无法保证主从复制数据的一致性 对于存储过程，触发器，自定义函数进行的修改也可能造成数据不一致。 相比于基于行的复制方式在从执行时需要更多的行锁 基于行的复制（使用基于行的日志格式） 优点： 可以应用于任何SQL的复制包括非确定性函数，存储过程等 可以减少数据库锁的使用 缺点： 要求主从数据库的表结构相同，否则可能会中断复制 无法再从服务器上单独执行触发器 MySQL的复制方式步骤： 主服务器将变更写进二进制日志 从读取主的二进制日志变更并写入到relay_log中 在从服务器上重放relay中的日志 方式： 基于日志点的复制配置 基于gtid的复制：GTID就是全局事务ID，其保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的ID 优点： 可以很方便的进行故障转移 从库不会丢失主库上的任何修改 缺点： 故障处理比较复杂 MySQL复制拓扑 一主多从的复制拓扑（为不同业务使用不同的从库，从库可以作为灾备恢复） 优点： 配置简单 可以用多个从库分担读负载 主主复制拓扑（主主模式下的主主复制拓扑：数据冲突和数据丢失，两个表中的数据最好能分开） 可以使用两个参数来控制自增ID的生成，一个2468，一个1357这样增长。（auto_incrment_increment = 2 auto_increment_offset = 1|2） 主备模式下的主主复制模式：只有一台主服务器对外提供服务，另外一台处于只读并只作为热备使用。一般可以作为高可用来做。 注意事项： 确保两台服务器上的初始数据相同 确保两台服务器上已经启动binlog并且有不同的server_id 在两台服务器上启用log_slave_updates参数 在初始的备库上启用read_only 有备库的主主复制模式 级联复制（存在一个分发主库，其实就是一个分发主机的二进制日志的从库） MySQL复制性能优化影响主从延迟的因素 主库写入二进制日志的时间 优化：控制主库事务的大小，分割大事务 二进制日志的传输时间 优化：使用MIXED日志格式：设置 set binlog_row_image=minimal; 从上默认只有一个SQL线程，主上并发的修改在从上变成了串行 优化：使用多线程复制 stop slave; set global_parallel_type = &#39;logical_clock&#39;就是使用逻辑时钟的方式来实现多线程复制 set global slave_parallel_workers = 4 设置线程的数量 start slave MySQL 高可用 避免导致系统不可用的因素导致的系统不可用的时间 建立完善的监控及报警系统 对备份数据进行恢复测试 正确配置数据库环境 对不需要的数据进行归档和清理 增加系统冗余，保证发生故障时可以尽快恢复 避免存在单点故障 使用SUN共享存储或DEDB磁盘复制 使用多写集群（Percona）或NDB集群(大内存) 使用主从复制 主从切换及故障转移 MMM管理主主复制拓扑结构，并工作在主备复制模式下。 监控MySQL主从复制健康情况 在主库出现宕机时进行故障转移并自动配置其他从对新主的复制 提供了主写虚拟IP，在主服务器出现问题时可以自动迁移虚拟IP 配置所需的资源： MHA 监控主数据库服务器是否可用 当主DB不可用时，从多个服务器中选举出新的主数据库服务器 提供了主从切换和故障转移功能 MHA主从切换的过程： 尝试从出现故障的主数据库保存二进制日志 从多个备选服务器中选举出新的备选主服务器 在备选主服务器和其他的从服务器之间同步差异二进制数据 应用从原主DB服务器上保存的二进制日志 提升备选主DB服务器作为新的主DB服务器 优点： 可以支持GTID的复制模式 在故障转移的时候更不易产生数据丢失 同一个节点可以监控多个集群 但是没有提供负载均衡的操作 MaxScale实现读写分离和负载均衡读写分离是分析哪些语句需要在哪些数据库上执行，尽量的写操作在主库上进行，读操作尽量在从数据库上执行。 读的负载均衡是尽量的让读操作分散在多个从数据库上执行。 MySQL支持的索引类型B-tree索引B-tree索引的特点 B-tree索引以B+树的结构存储数据 更适合进行范围查找，加快数据的查询速度 使用场景： 全值匹配的查询 匹配最左前缀的查询 匹配列前缀查询 匹配范围值的查询 精确匹配左前列并范围匹配另外一列 只访问索引的查询 使用限制 如果不是按照索引最左列开始查找，则无法使用索引 使用索引时不能跳过索引中的列 Not in 和&lt;&gt;操作无法使用索引 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引 Hash索引特点： 等值查询：Hash索引是基于Hash表实现的，只有查询条件精确匹配时Hash索引中的所有列时，才能够使用到hash索引 对于Hash索引中的所有列，存储引擎都会为每一行计算一个Hash码，Hash索引中存储的就是Hash码。 使用限制 Hash索引必须进行二次查找 Hash索引无法用于排序查找 Hash索引不支持部分索引查找也不支持范围查找 产生Hash冲突，产生查询错误 MySQL索引优化 索引上不能使用表达式或函数 索引长度过长时可以使用前缀索引（索引的选择性：指的是不重复的索引值和表达记录数的比值） 联合索引 顺序选择： 经常被使用到的列优先 选择性高的列优先 宽度小的列优先 覆盖索引（包含了查询字段的所有值的索引，就是在使用B-tree索引时通过索引的键值还能够查询到该索引对应的值，Hash索引不能用覆盖索引），使用覆盖索引可以优化缓存，减少磁盘IO操作，也可以减少随机IO，把随机IO改为顺序IO的操作，避免对主键的二次查询。 使用索引来优化查询 使用索引扫描来优化排序： 索引的列顺序和Order By 子句的顺序完全一致 索引中所有列的方向（升序，降序）和Order by子句完全一致 Order by中的字段全部在关联表中的第一张表中 使用Hash索引优化查询，当搜索引擎不支持Hash索引的时候可以使用B-tree索引来模拟Hash索引。 使用索引优化锁 索引可以减少锁定的行数 索引可以加快处理速度，同时也加快了锁的释放 删除重复和冗余的索引 可以使用pt-duplicate-key-checker h=127.0.0.1实现重复和冗余的查询 清理未被使用过的索引 更新索引信息和减小索引的碎片 获取有性能问题的SQL 慢查询日志获取存在性能问题的SQL 默认是不启动的 1234slow_query_log 启动停止记录慢查日志slow_query_log_file 指定慢查日志的存储路径及文件long_query_time 指定记录慢查日志SQL执行时间的阀值long_queries_not_using_indexs 是否记录未使用索引的SQL 分析工具： mysqldumpslow pt-query-digest 实时获取存在性能问题的SQL information_schema 和PROCESSLIST表的方式通过执行SQL语句然后查询哪一些语句执行到的时间过长，找到性能问题的存在的地方。 MySQL优化器可以优化的SQL类型 重新定义表的关联顺序 将外连接转换为内连接 使用等价变换规则 优化count(),min(),max() 将一个表达式转换常数表达式 子查询优化 提前终止查询 对in()条件进行优化 确定查询处理各个阶段所消耗的时间 使用performance_schema 数据库的分库分表 方式 把一个实例中的多个数据库拆分到不同的实例 其实就是把一个MySQL节点（MySQL集群）的数据库拆分到其他节点上去。 把一个库中的表分离到不同的数据库中、 数据库表的水平拆分尽量不分片 选择分区键 分区键要尽量避免跨分片查询 分区键要尽量保证各个分片内的数据量是均匀的 存储无需分片的表 每个分片中存储一份相同的数据 如何在节点上部署分片 每个分片使用单一数据库，并且数据库名字相同 将多个分片表存储在一个数据库中 如何分配分片中的数据 按分区键的Hash值取模来分配 分片工具：oneProxyp 数据库监控数据库可用性监控 是否可以通过网络连接 在远程服务器执行mysqladmin -umonitor_user -p -h ping看返回值 telnet ip db_port 使用程序来建立连接判断是否能够连接 是否可读写 检查数据库的read_only参数是否为off 建立监控表并对表中数据进行更新 执行简单的查询 select @@version 监控连接数 show variables like ‘max_connections’ show global status like ‘Threads_connected’ 可以对上面的两个参数设置一个阈值，进行预警 性能监控 计算QPS和TPS 监控并发请求数量 show global status like ‘Threads_running’ 监控Innodb的阻塞 可以使用SQL语句来查询被阻塞线程阻塞的时间，当大于某个值的时候就可以认为阻塞了。 主从复制监控 监控链路状态 检测从数据库的IO状态 监控主从复制的延迟 show glave status 这种方式不准确的 show master staus查询主服务器上的二进制日志文件的偏移量，然后在从服务器上执行show glave status获取用户栈的信息 主从复制数据一致性检查 使用pt-table-checksum工具]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文献阅读20180929]]></title>
    <url>%2F2018%2F09%2F30%2FPaperRead2%2F</url>
    <content type="text"><![CDATA[文献阅读1 A Framework for Evaluating Mobile App Repackaging Detection Algorithms 引用：Huang H, Zhu S, Liu P, et al. A Framework for Evaluating Mobile App Repackaging Detection Algorithms[M]// Trust and Trustworthy Computing. Springer Berlin Heidelberg, 2013:169-186. 1.1 文章中提到的几种方法 DroidMOSS：使用一种称为模糊散列的特殊的散列技术：这种方法是计算每个单元中的dex文件的哈希值，它使用重置点将长操作码序列拆分为小单元，然后将所有散列值连接成一个整体。这种方法的缺点是一个是一些重新打包的情况将大量代码作为噪声插入到原始应用程序中，另一个事实是广告库的不完整白名单，这会在操作码序列中产生大量噪声。这样的计算出的哈希值也就有很大的可能性不一样了。（1-2-3-4 加入噪声之后就是1-2-8-8-6-7-3-4这样的话哈希值就差很多，可能计算出来只有50%的相似度。）同样的罗宾的论文中的基于类目录的方法的缺点也是这样的，也是如果我通过添加一些随机的噪声类，可能不起啥作用，但还是导致hash值变换的很多。 DNADroid：就是将dex文件通过名为dex2jar的工具转换为Jar，这样他们就可以利用WALA [14]计算每种方法的静态数据依赖图（DDG）。 DDG被认为是相似性比较应用程序的主要特征。 DNADroid使用基于图形同构的算法比较预先计算的Android应用程序集群中的DDG。其实就是函数调用或者是变量调用依赖关系图，这种方法的话其实一样的，我可以添加无用的变量来实现让别的函数调用它，其实这段代码不起啥作用。 基于特征哈希的检测：首先是将dex文件根据某些预定义标准进行分组，以减少比较开销，他的特征的选择是：在程序的每个基本块内的各种操作码序列模式的k-gram被认为是特征。例如，他们选择5-gram作为大小为5的移动窗口，它在每个基本块内移动以映射并将特征标记为m位向量。然后将位向量进一步组合成特征度量以指纹每个app。 Juxtapp目前使用各种预定义的操作码序列作为特征。其实就是在代码中发现了（A_B_C_D_E这种形式的时候就把他映射成是一个向量（A是一个实例，B是一个字符串常量，C是一个方法调用这种过程）） 还是和上面一样的缺点，噪声代码的注入，怎么办？尽管可以缩小移动窗口的大小，但是这样的话就会提高误报的概率。 1.2 文章给出的评估框架： 第一个组件称为Dalvik Bytecode预处理器，它将Dalvik EXecutable（DEX）分解并转换为中间表示（IR）代码格式。第二个组件是IR Code Obfuscator，它直接用于原始程序的输出IR格式。IR Code Obfuscator试图模仿基于真实世界的混淆重新打包过程。因此，该组件从原始输入dex文件输出一组混淆版本。在此过程中，我们必须确保所有代码操作和混淆操作都是语义保留转换。在混淆之后，IR2Dex Repackager将语义等效的IR代码转换回Dalvik字节码，以便它与大多数检测器兼容，这些检测器将dex文件作为输入。 dx工具用作重打包的工具 接下来的就是介绍每个组件使用不同的工具去实现这个框架，然后通过分析不同的混淆方法来实现这个框架的评估。 2 用于自动Android恶意软件检测的深度神经网络 引用：Hou S, Saas A, Chen L, et al. Deep Neural Networks for Automatic Android Malware Detection[C]// Ieee/acm International Conference on Advances in Social Networks Analysis and Mining. ACM, 2017:803-810. 2.1 数据集来源：Comodo云安全中心的真实样本集 2.2 本文中的方法：在本文中，基于从smali文件中提取的应用程序编程接口（API）调用的分析，我们进一步将属于smali代码中的某个方法的API调用分类为块。基于生成的API调用块，我们然后探索深度神经网络（即，深度信念网络（DBN）和堆叠自动编码器（SAEs））以用于新未知的Android恶意软件检测。我们不再直接使用API调用，而是进一步对属于smali代码中相同方法的API调用进行分类,形成检测的特征样本。 2.3 提到的其他的方法： ‘W. Wu and S. Hung, “Droiddolphin: a dynamic android malware detection framework using big data and machine learning,” in RACS, 2014.’中使用动态分析框架（包括DroidBox 2和APE3）来记录收集的Android应用程序中的13个活动特征，然后应用支持向量机（SVM）构建恶意软件预测模型 ‘A. U. Z. I. Burguera and S. Nadjm-Tehrani, “Crowdroid: behavior-based malware detection system for android,” in SPSM, 2011.’将API系统调用解压缩为k-means聚类的特征集 API调用，权限和意图消息作为k-means聚类的输入特征，最后是k-NN分类 由API调用和权限请求组成的功能集，然后将它们提供给SVM，决策树和集合分类器。 本文架构 本文中提出的架构如上图所示： 恶意软件检测程序：对于每个新收集的未知Android应用程序，它将首先通过解压缩器和反编译器进行解析以获取smali代码，然后将从smali代码中提取其API调用，最后将生成API调用块作为特征向量。通过使用构建的分类模型，此应用程序将标记为良性或恶意。其实就是把API调用块映射成向量的形式。举个例子（Lorg/apache/http/HttpRequest;!addHeader” —-》&lt;520,506&gt; — &gt;\) 然后就是构建特征集（$$D = (x_{i},y_{i})_{i=1}^{n}$$x表示API调用块形成的特征向量，y表示对应的程序。 然后将上述数据集放到DBN或者是SAEs中去训练。 要使用SAE进行Android恶意软件检测，需要在顶层添加分类器。 使用反向传播（BP）和基于梯度的优化技术训练SAE深度网络是很简单的，然而，已知以这种方式训练的深度网络具有差的性能。幸运的是，Hinton等人开发的贪婪分层无监督学习算法。 [8]已经克服了这个问题。该算法的关键在于以自下而上的方式逐层预加深深层网络，然后以自上而下的方式应用BP对参数进行微调，从而获得更好的结果。 最后的实验结果是DBN优于SAEs优于浅层的学习模型如DT，SVM等。 3 HyDroid: A Hybrid Approach for Generating API Call Traces from ObfuscatedAndroid Applications for Mobile Security 引用：Khanmohammadi K, Hamou-Lhadj A. HyDroid: A Hybrid Approach for Generating API Call Traces from Obfuscated Android Applications for Mobile Security[C]// IEEE International Conference on Software Quality, Reliability and Security. IEEE, 2017:168-175. 在本文中，他给出了一种混合方法HyDroid，它结合了静态和动态分析，从应用程序服务组件的执行中生成API调用跟踪。 使用Jimple grammar将二进制文件转换为更高级别的表示。 系统框架： 这个方法的检测过程分为两部分： 静态分析部分： 这一部分是通过改变我们通过遍历服务的方法和修改if语句条件来实现程序按照所需的路径运行代码。整个条件由布尔变量替换。其次，赋值语句在if语句体内完成。最后，添加了异常处理。 这一部分是通过将反编译的二进制文件准换为Jimple语句，然后通过Jimple语法来实现if条件语句的控制和修改。下面是修改的例子。 动态分析部分： SLCS模拟服务的生命周期，以与测试应用程序中的服务进行交互。在执行的过程中把API的调用的过程找出来。保留Android API调用以及可以揭示恶意软件行为的Java库调用。 缺点： Encrvption是另一种强大的混淆技术，可用于代码的不同点，包括字符串加密，整个类的加密或应用程序资源的加密。如前所述，当字符串加密和反射可以一起使用时，我们的方法可以很好地打败字符串加密。如果整个类都是加密的，那么无法解密类的检测是不可能的。即使对于HyDroid来说，这种类型的混淆仍然是一个挑战。 加入噪声代码的话会使得这种方法生成不必要的代码来实现API轨迹的调用，这样的话就增加了不必要的负担。 数据集数据集来自Gnome。 其实这篇文章之研究了服务组件的API，但是有可能恶意代码不插入在服务组件中。 4 SAMADroid: A Novel 3-Level Hybrid MalwareDetection Model for Android Operating System 引用：Arshad S, Shah M A, Wahid A, et al. SAMADroid: A Novel 3-Level Hybrid Malware Detection Model for Android Operating System[J]. IEEE Access, 2018, PP(99):1-1. 4.1 概述这篇文章说给出了新的三层混合Android恶意软件检测模型，命名为SAMADroid。它是恶意软件分析和检测的三个级别之间的混合：(1)静态和动态分析;(2) 本地和远程主机;(3)机器学习情报 先给出来一篇论文中使用的AASandbox来进行的静态和动态相结合的恶意软件分析;然后又介绍了另一个方法DroidRanger：分两步：（1）它使用恶意软件执行预期功能所需的基本权限来过滤恶意应用程序（我觉得没啥用，因为权限的话有一些正常的软件也会有一些过分的权限需要）；（2）记录API调用及其参数，以便检测动态加载的Java代码的恶意行为。 接下来还有些别的文献的方法，基本上分为两种吧： 基于机器学习的恶意软件检测，有各种各样的特征提取方法，包括静态分析或者是动态分析提取的特征，然后进行分类。 基于本机和主机的分析：其实就是现在本机通过一定的方法进行本机的检测，然后将认定为有风险的APP通过收集APP的应用信息传到主机上进行分析或者是直接将APK传到服务器上进行详细的分析。 4.2 本文的框架本文中的方法是一个3层的检测模型 静态和动态结合分析 分析的静态的功能：API，权限，组件，请求的硬件，意图过滤器（使用到的工具是Android Asset Packaging Tool和Baksmali） 动态调用:安装应用并对系统调用跟踪进行分析（具体的是分析啥？这里没说，看看下面） 这一级的模型是他开发了一个安卓的客户端，然后对和网络还有文件操作相关的系统调用进行了跟踪。 本机和主机分析：这里的本机和主机分析其实是在本机上不执行检测，只执行安装然后跟踪系统调用日志然后上传到服务器进行仔细的静态分析过程。 主机分析的过程其实就是根据客户端传来的应用程序的标识符来在本地库中选取APK或者是从应用商店下载来执行静态分析 机器学习分析：在服务器上进行分析（特征向量的构建来自于上面收集的静态数据）。 静态的特征用一个集合表示包括6个子特征集合（如API，硬件，组件这一些），每个维度用0或者1表示，动态的特征就是应用的系统调用频率包括系统文件和网络功能的调用（一共10个特征）（文章里说恶意应用的系统调用频率更高（？？？））。然后使用SVM进行分类。而且他是静态分析得出一个结果，然后动态分析得出一个结果，两个结果相互印证。 评价指标就是用真阳性率，误报率和准确度来评价。 4.3 工具 Drebin：Drebin是一个静态分析恶意软件检测框架，可以提取应用程序行为的最大和有用信息的特征。 Monkey:用于动态的随机模拟用户操作应用程序的过程，用于动态过程 AASandbox：放置在内核中运行程序通过使用劫持系统来获取程序的运行日志然后构成分析的向量。 Cuckoo恶意软件分析器用于通过执行应用程序进行动态特征提取 LIBSVM：A Library for Support Vector Machines：获取地址：http://www.csie.ntu.edu.tw/~cjlin/libsvm/ ……等等 5 Detection of repackaged Android applications based on Apps Permissions 引用：Nisha, O. S. Jannath, and S. M. S. Bhanu. “Detection of repackaged Android applications based on Apps Permissions.” International Conference on Recent Advances in Information Technology 2018:1-8. 5.1 基本概念 每个Android应用程序由四个组件组成： 活动：单个屏幕侧重于用户操作。 服务：为应用程序执行后台服务。 广播接收器：从操作系统和应用程序中侦听消息。 内容提供商：定义数据库存储。 这些组件可以使用Intent消息在彼此之间进行通信。这些组件在“AndroidMani-fest.xml”文件中声明，该文件描述了每个组件的生命周期以及它们如何通信。 安卓的安全机制：沙箱和权限（开发人员必须要显式的声明） 5.2 本文的研究内容这篇文章其实也是用机器学习的方法来检测恶意程序的，在选择特征的时候他使用了一些特征的选择方法如卡方检验（基于统计的一种方法），MI(相互信息)来选择特定的特征，对于特征加权的时候使用术语频率法和特征排序法。术语频率方法估计文件中术语的频率，仅适用于中英文信息检索。特征排序方法基于统计和信息理论来度量特征和类变量的相关性。提取完特征之后使用分类算法来对恶意和良性应用进行分类。 架构如下： 最后就是对几种不同的分类算法得到的结果进行了比较。 代码混淆工具 SandMarks Zelix KlassMaster 方法和API调用轨迹生成工具 soot-infoflow-android APIMonitor 静态分析工具 Androguard 想法 我给APK文件中的某一些程序加密的时候随机选择这个程序中的某一个文件的hash值作为一部分秘钥。然后这样的话他是可以知道hash值是不假，但是要是全部弄出来的话增加了难度。而且我每个的方法的名字也给他命名的不一样吗，随机用字符串来做命名。从我的某一个字符串库中，或者直接就是去hash值，或者是我随意命名。 机器学习的分类：就是需要找到大样本集，然后找到合适的特征：API的调用，类目录，方法调用，权限使用等等（可以使用动态和静态方法结合的方式来提取特征，也就是通过找到动态特征向量和静态特征向量来训练模型），然后选择合适的分类器，这里的话就是看自己的选择了。其实动态特征和静态特征的提取工具有很多，可以参考文章4，里面介绍了很多的方法。 其实现在的检测的主要的方法还是基于相似性的检测，还有一部分是机器学习的检测，动态检测和自我防御。]]></content>
      <categories>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>文献阅读</tag>
        <tag>安卓重打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文献阅读20180915]]></title>
    <url>%2F2018%2F09%2F30%2FPaperRead1%2F</url>
    <content type="text"><![CDATA[文献阅读文章1. Understanding Android App Piggybacking: A Systematic Study of Malicious Code Grafting 其实这篇文章读的有点点迷糊，Piggybacking的程序指的是其中一个应用程序可能会捎带另一个应用程序以包含恶意负载的程序，他的意思是搭载了恶意负载啊 这篇文章是构建了&lt;原生,重打包&gt;应用对的数据集。然后进行相似性的分析。分析是完全相同的应用，还是类似的应用，还是添加了某些还是删除了某些方法。分析的指标： identical - 包括签名和实现在内的给定方法在两个应用程序中完全相同。 similar - 给定的方法在两个应用程序之间略微改变（在指令级别），即具有相同签名但具有不同内容的方法。 new - 在搭载应用程序中添加了一个方法，即app2中存在方法但app1中不存在。 deleted： 当一个方法包含在搭载应用程序中时，已从运营商代码中删除该方法，即方法存在于app1中但不存在于app2中。 然后就是怎么分析代码的问题了。直接分析太多了，他是把一个方法的code映射成字符串（映射规则是自定义的）。然后分析映射成的字符串的相似性。方法就是这样的，下面的文章内容是对他们数据集的分析，证明他们的分析的数据集是可靠的。 映射的一个例子： 应该是这个网站可以看映射的规则：https://ssebuild.cased.de/nightly/soot/javadoc/index.html。 2. RepDroid: An Automated Tool for Android Application Repackaging Detection这篇文章是根据构建应用程序运行时的UI布局组图（LGG）的动态跟踪来设置检测的标志（文章中称为birthMark） 直观地，两个功能等同的重新包装克隆应该向最终用户提供类似的体验（视觉呈现，用户交互等）。此外，考虑到静态分析无法精确分析加密代码，我们采用动态方法比较两个应用程序的UI跟踪，以检测应用程序市场中的重新打包（图3）： 每个应用程序的胎记都从其执行跟踪中提取。胎记是基于运行时布局及其转换构建的图，其被命名为布局组图（LGG）。 一对重新包装的应用程序的特征在于它们相似的胎记，即它们的LGG之间在某个阈值之间的相似性得分。只要主要功能和视觉信号保持不变，我们就能够检测到重新包装。 Android应用程序重新打包攻击可以分为三类[13]，懒惰攻击，业余攻击和恶意软件。懒惰的攻击者经常在不更改其代码的情况下进行一些简单的更改，例如重新打包具有不同作者姓名的应用程序。因此，它无法更改运行时UI。因此，我们的方法可以有效地检测此类攻击。业余攻击者不仅应用自动代码混淆，还会更改，添加或删除一小部分功能。如果攻击影响应用运行时UI，则可以更改LGG。 恶意软件攻击者将一些恶意负载插入到原始程序中，但仍然使重新打包的应用程序看起来和行为与原始应用程序类似，以利用原始应用程序的流行度。 在重打包的时候他们可能会添加一些视图并将其颜色设置为与背景颜色相同。但是，据我们所知，还没有用于混淆的布局保留转换工具。因此，如果攻击者想要进行此类攻击，他们必须修改布局XML文件，这对重新打包应用程序来说是一个很大的负担。 这个是动态的分析界面的layout,那能不能只分析对应于布局的XML文件，将XML文件中的布局构成树结构然后分析两颗树的相似性，就是XML文件中的FramView ,ListOut等等的遍历，然后给他加权处理。 文章中提到其他的一些方法：找到感兴趣的方向之后再看看是不是自己需要的再看： Static Birthmarks ：DroidMOSS [5]将模糊散列应用于app的每个方法作为指纹。基于两个指纹的编辑距离，他们计算相应应用的相似度。 DNADroid [8]为每个类别的应用程序中的每个方法构建程序依赖图（PDG），并通过VF2子图同构图比较图形。 AnDarwin [9]是另一种也使用PDG的工具。与DNADroid相比，AnDarwin计算PDG语义向量的局部敏感散列（LSG），从而提高了检测的可扩展性。 Juxtapp [10]使用k-gram的操作码和特征哈希来确定两个应用程序之间的相似性，并检测Android应用程序的重用。 PiggyApp [11]是一个可扩展的工具，用于检测搭载的应用程序。它应用模块解耦技术来找到比较的主要部分。它还通过解耦的主模块的语义特征提高了检测效率。 Centroid [12]构造每种方法的3D控制流图（3d-CFGs）并计算这些图的质心。然后，它定义质心差异度以测量应用之间的相似性。 Viewdroid [13]根据特定的Android API生成视图特征图，这是一个基于UI的Android应用程序胎记。为了测量图之间的相似性，它使用VF2子图同构算法。 Dynamic Birthmarks：Android API。与Viewdroid相比，它生成应用程序执行跟踪，即API调用序列，而不是视图。此外，通过测试工具Monkey在应用程序运行期间收集跟踪。工作[17]在UIAutomator的帮助下定位UI信息。它计算由相应活动创建的每个视图中的某些选定属性的频率，并将其上的向量构造为应用的胎记。为了计算应用程序之间的相似性，它使用E2LSH来查找每个应用程序中所有活动的近邻，并应用匈牙利算法来查找最近邻居中导致最高相似性得分的活动对。 Similar App Detections还有一些关于检测类似应用程序的相关工作。与应用程序重新打包不同，如果两个应用程序共享许多共同特征，即使它们是依赖开发的，它们彼此相似[29]。麦克米兰等人。 [29]通过使用语义层的概念来检测密切相关的应用程序（CLAN）来计算相似性指数。他们引入了一个与语义空间相关的新抽象，它被建模为API类和包的现有继承层次结构。 Thung等。 [30]基于CLAN检测类似的应用程序。他们使用协作标记来模拟系统，而不是API调用。 Linares等。 [31]提出了一种方法，通过分析五个语义存档来检测Android（CLANdroid）中的类似应用程序：标识符，Android API，意图，权限和传感器。 文章中自己指出的存在的一些问题： 有趣的是，我们发现一些新注入的组件带有空实现。执行组件时，它将重用其父类的实现。不幸的是，这种间接性常常在简单的静态分析方法中被忽略，从而无法分析注入组件的实际实现。 相对于原生的APP在搭载恶意程序的代码中是存在更多的重复组件。 3. Leveraging Information Asymmetry toTransform Android Apps into Self-Defending Code Against Repackaging Attacks我们发现开发人员和攻击者之间存在着独特的信息不对称。利用这种不对称性，我们新的自防御代码（SDC）方法在编译时加密部分应用程序代码，并在运行时动态解密密文代码。与以前的工作不同，关键来自信息不对称和应用程序的校验和。重新打包应用程序后，更改的校验和将使应用程序异常运行，进一步暴露重新打包。信息不对称是通过保护密钥免受攻击。 针对于重打包应用的防止方法： 方法1：许可证保护机制（包括APK文件大小，MD5哈希/校验和和签名）。一个代表性的机制是Google Play提供的许可服务[2]。通过在运行时使用许可证验证库（LVL）查询Google Play，应用程序可以获取当前用户的许可状态，然后决定是否允许进一步使用。但是，受LVL保护的应用仍然可以重新打包。 方法2： App review process. 也就是说应用在上传到应用市场之前是有检测和审批流程的，但是数量巨大，人工检测不切实际。 方法3：混淆技术：混淆技术只会增加对应用程序进行逆向工程的难度，但不能阻止攻击者重新打包。 方法4： 检测技术： Android市场的管理者会比较其市场和/或其他市场中的应用，以检测重新打包的应用。检测需要同时找到至少两个“相似”的应用程序。自动检测是可能产生误报漏报的。 本文中的方法是一种自我保护的方法，其实就是因为自我保护机制使得重打包的应用在运行时产生异常。这个自我保护机制也就是自防御代码（SDC）。 但是这种方法能够使用存在一定的前提条件： a.）信息不对称的存在。攻击者不能知道源代码中包含的所有信息，而且重打包的成本低于重新开发目标应用程序的成本。他们假设攻击者只知道编译的代码，而不是源代码。还假设，如果重新打包成本超过重新开发，攻击者宁愿重新开发目标应用程序。非对称信息是一种开发人员知道但是攻击者不知道的非对称信息 b.）可以利用信息不对称来使重新打包的应用程序异常运行(一直在说信息的不对称，到底是啥？） c.）信息不对称不应该损害合法应用程序。 还有一个缺点就是他是在恶意活动发生时让程序崩溃，并不能在恶意活动发生前阻止活动的发生，这样的话其实就恶意活动已经发生了然后你再让程序崩溃，然后在去检测原因，这样其实损失已经造成了，因为恶意活动已经发生了。 SDC利用应用程序的校验和作为加密一段代码的密钥的一部分。重新打包应用程序后，将更改校验和，这将使解密无法恢复原始代码。运行错误解密的代码将自动让应用程序异常运行，这可以通过我们确保重新打包的方法来捕获。另外，由于解密密钥也部分地来自信息不对称，因此攻击者无法弄清楚密钥。SDC的设计方式如下： 这个将代码加密的过程最终还是判断的是encrypt(加密后是否与之前加密的相等，不相等的话就解析不出encr_code)来，导致这个变量不可用，但是我要是知道这里用的变量是encr_code的话其实就可以把那些加密全部省去，然后直接使用这个变量。 在运行过程中，当触发SDC段时，将计算应用程序的校验和。具有正确校验和的原始应用程序将使应用程序照常运行。但是，具有不同校验和的重新打包应用程序将使解密无法恢复原始校验和，这将进一步让应用程序异常运行。 也就是说他的这个方法是原始的应用程序检验和作为加密密码，只有一个，并且不变。 开发人员可能会加密程序中的某些代码，使攻击者难以阅读或修改，并隐藏应用程序内的密钥。当包含所有代码的应用程序暴露给攻击者时，可以找到密钥。然后他就使用了很多的SDC段，每一个SDC段都有自己的一个秘钥，进行多次加密，然后让他找不全所有的SDC段，这样做的话就能够提高触发SDC段的概率，但是工作量变大了。 这种用法一旦别人知道了那就是在if段进行的加密，这样的话就存在一定的问题。然后他是对if块中的语句，和程序中的常量来加密的，攻击者肯定是可以看出来的，因为每一段if块都是这样的，然后通过动态执行我猜应该是可以解出这些变量的值的。能不能对if语句段进行加密和混淆，让他看不出这里是if的语句。（关于代码的加密和混淆还需要看相关文章） 攻击者可以构建运行环境（例如，特殊模拟器）来运行app并观察在环境中运行的任何代码的执行。 这篇文章给出了两个SDC的实现方式，第一种需要定制安卓的虚拟机系统，也就是说当用户用的安卓没有定制时就不可以。第二种交Twin_SDC,说是通过安卓本机来实现代码块的解密，具体的没有太看懂。 4. Evaluation of Resource-Based App Repackaging Detection in Android我们根据不同资源文件类型的个别分数尝试重新打包检测。我们使用18种文件类型作为特征向量，评估了具有这些特征的几个分类器，并发现通过分别考虑不同类型的文件来提高该方法的有效性。在最好的情况下，使用非优化的随机森林分类器，我们实现了0.9919的F-度量，大大改善了基于单一分数的方法。 其使用的方法是计算所有资源文件的哈希值，包括APK所有的文件（图形，文本，布局和多媒体内容，classes.dex，库文件和清单文件） Jressim（A，B）= |HA∩HB| / |HA∪HB|，Jressim就是它的相似性得分。HA,HB分别为A和B的哈希值。 这篇文章中给出了一些相似性的计算公式： 后面的改进就是根据文件类型对文件先进行分类，以类别作为特征，然后使用随机森林对应用进行分类，得到分类的结果。 这篇文章的做法其实就是使用机器学习来分类，实现一个分类器，这样的话其实需要找到足够多并且准确的数据集作为训练的特征。文章中找了1000多对应用作为数据集。他说这篇文章中给出了数据集：Li, L., Li, D., Bissyand?, T.F., Lo, D., Klein, J., Le Traon, Y.: Ungrafting malicious code from piggybacked Android apps.Technical report, SnT, University of Luxembourg (2016)，网址是这个：https://github.com/serval-snt-uni-lu/Piggybacking/tree/master/data，但是里面但是只看到了APP的hash值。然后这个数据集在文章1中也提到了。 其他常见的检测方法解析目录结构2012年，Li S提出采用文件目录结构对应用相似性进行评估[13]，用树结构表示应用的文件结构，计算树之间的距离，由此得到应用之间的距离，该方法可以检测重打包应用、嵌入已知恶意代码应用。但是，该方法会有较高的误判率，因为不考虑应用的程序代码信息，对包含代码的classes.dex文件并没有解压分析，只计算资源文件信息，得到的信息量太过匮乏。 基于Dalvik字节码DroidMoss基于Dalvik字节码，分别提取了官方市场和第三方市场上应用的作者信息和代码，然后计算散列值比较重打包应用的变化。DroidMoss的缺点是需要有官方应用作为参照，一旦无法区分官方应用和第三方应用，该方法将会失效。 一种新的距离指标设计的最近邻搜索算法一种新的距离指标设计的最近邻搜索算法并实现了PiggyApp，克服了可拓展性的限制，可以用于成对比较，其算法复杂度减少到O(nlogn)，该系统提出了一种Manifest App的概念，能够自动嵌入水印和提取水印，该概念指的是受保护应用的伴侣应用，如果应用程序在虚拟机上运行的时候，伴侣程序可以触发应用程序显示水印。PiggyApp采用了自动测试生成技术来产生Manifest App，所以整个过程完全自动化，不需要用户的参与。PiggyApp提供了指纹技术来提取有用的特征，并将这些有用的特征转化为特征向量，提出通过线性数值搜索算法来度量应用之间的相似度。 More随后更多的学者参与其中，提出了很多的检测方案。例如基于依赖关系图[16, 17]，基于控制依赖图[18-20]，基于系统调用图[21-23]，基于函数调用图[24, 25]，基于图着色算法[26]。目前也有很多的代码相似性检测的系统，比如JPlag[27]，Moss，Sim[28]，YAP3[29]等，这些系统大部分采用的属性计数和结构分析相结合的方案。 广告对于重打包分析的影响有的时候一个重打包的应用可能植入了很多的广告，通过代码植入的，然后这样的话就会导致重打包应用和非重打包应用有很大的差别，这样的话其实也可以通过给定阈值来分析，去除资源后的目录签名与带资源的目录签名各自给一个影响因子，综合给出判定阈值。 在之前的前一篇文章中提到过,在原始的APP中加入广告也是重打包的一种方式.一个方法的,不可能是十全十美,总会是在各种权衡下找到一个最优值.在这里,我们需要提取出Android的资源来做判断.我们想一想,一个ANDROID的广告,不管是弹框的,内嵌的,不知道还是一个条幅跑出来的.你能看的见的,这些Activity都是资源,假设一个APP被嵌入了太多的广告,这样必然会影响我们的判断准确性.所以,在判断的过程中,想要提高准确性,广告的去留是一个需要慎重考虑的因素. 数据集 这个文章给出了一组公共库，其实在做检测的时候公共库还是有影响的：Li Li, Tegawendé F. Bissyandé, Jacques Klein, Yves Le Traon, An Investigation into the Use of Common Libraries in Android Apps, The 23rd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER 2016), 2016 [[pdf]文章给出了公共库，已经star Androzoo这是一个由数个市场（包括Google Play，appchina，anzhi），开源存储库（包括F-Droid）和研究人员数据集（如MalGenome数据集）：来源于文章Kevin Allix, Tegawend´e F Bissyand´e, Jacques Klein, and Yves Le Traon. Androzoo: Collecting millions of android apps for the research community. In The 13th International Conference on Mining Software Repositories (MSR), Data Showcase Track, pages 468–471.ACM, 2016.这篇文章也可以看一下，应该是也有数据集，到时候可以看一下。 乱七八糟的想法 对于UI的组件的布局一般是没有问题的，而且这样的话是避免广告的影响，而且读取相同名字的XML的组件的布局，然后取比较序列的相似度就可以UI的相似性。 构建程序依赖图，就是把源码全部解出来，然后取分析谁调用了谁，这种方法的话难度太大了。 其实不用分析相似性，可以看成是分类，通过某种指标将应用程序分类，聚成一类的看做重打包 文章3中的SDC方法是可以加密代码的对吧，使用程序的校验和来加密某一段程序，重打包之后就会程序的校验和就会发生改变，然后恰好程序运行时若是正好调用了这部分代码，然后由于解密的时候解密错误，发生异常，程序就会报出错误，就会运行异常发生崩溃。这样的就能知道这是异常应用了。最好就是加在很多的地方，然后就出问题的地方会比较多，然后重打包的话其实一般是添加恶意代码，我们不需要知道恶意代码是什么，然后他要想把加密的东西去除，也要查找所有的代码，因为他不知道我们在哪里添加了加密的东西。然后加密密码攻击者也是不能获得的。而且为了混淆我们也可以使用不同的代码来做。 代码混淆和代码加密技术 这样还有一个问题就是重打包测试者也会测到，然后测到哪个位置后有加密的然后去删除，但是这样也是增加了难度。其实上面的想法已经有人在做了，开发人员可能会加密程序中的某些代码，使攻击者难以阅读或修改，并隐藏应用程序内的密钥。当包含所有代码的应用程序暴露给攻击者时，可以找到密钥。 遵循与基于资源的重新包装检测相同的直觉，并对图像文件应用感知散列以检测类似的图片。它侧重于将布局文件表示为树布局哈希并搜索类似的布局结构。其实这个方法是搜索布局文件并表示成树结构然后计算哈希值，求哈希值之间的相似性。 是不是能够遍历类，有哪些类是共有的，有哪些类是不一样的，有哪些呀是新的，有哪些是删除的，然后给出一个相似性的公式，就和文章1中的一样。或者是别的，比如说遍历到的UI布局，或者是权限的申请。关于UI布局和权限的申请还需要读几篇相关的文章。 总结一下吧，文章看的稀里糊涂的，刚开始看安卓的东西，一上来看的文章也都是IEEE的文章，创新性都比较强，看起来有些吃力，这两周起步的也比较晚，看的文章也不多，看完之后的想法也是乱七八糟的，先记下来，还是多看看文章，然后在回来看这些想法。 基础知识Android中的文件 .so文件是动态链接库。 Java源文件通过Java编译器生成CLASS文件，再通过dx工具转换为classes.dex文件。DEX文件从整体上来看是一个索引的结构，类名、方法名、字段名等信息都存储在常量池中，这样能够充分减少存储空间，相较于Java字节码文件更适合手机设备。 dex是Android平台上(Dalvik虚拟机)的可执行文件, 相当于Windows平台中的exe文件, 每个Apk安装包中都有dex文件, 里面包含了该app的所有源码, 通过反编译工具可以获取到相应的java源码。 Manifest文件中存储了文件的权限。 工具 开源静态分析工具Androguard soot是一个相当官方的，能够进行java代码分析的工具。当然，.apk文件也可以进行分析。 DroidMoss可以用于检测第三方应用市场的 恶意软件，可以作为辅助对比工具使用 DNADroid专注于执行应用程序代码的成对相似性比较以检测重新打包的应用程序。]]></content>
      <categories>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>文献阅读</tag>
        <tag>安卓重打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemarker基础知识总结]]></title>
    <url>%2F2018%2F08%2F20%2Ffreemarker%2F</url>
    <content type="text"><![CDATA[Freemaker FTL指令常用标签及语法注意：使用freemaker，要求所有标签必须闭合，否则会导致freemaker无法解析。 freemaker注释:&lt;#– 注释内容 –&gt;格式部分,不会输出 ———————————- 基础语法 ———————————- 1、字符输出12345$&#123;emp.name?if_exists&#125; // 变量存在，输出该变量，否则不输出$&#123;emp.name!&#125; // 变量存在，输出该变量，否则不输出$&#123;emp.name?default(&quot;xxx&quot;)&#125; // 变量不存在，取默认值xxx $&#123;emp.name!&quot;xxx&quot;&#125; // 变量不存在，取默认值xxx 常用内部函数： 12345$&#123;&quot;123&lt;br&gt;456&quot;?html&#125; // 对字符串进行HTML编码，对html中特殊字符进行转义$&#123;&quot;str&quot;?cap_first&#125; // 使字符串第一个字母大写 $&#123;&quot;Str&quot;?lower_case&#125; // 将字符串转换成小写 $&#123;&quot;Str&quot;?upper_case&#125; // 将字符串转换成大写$&#123;&quot;str&quot;?trim&#125; // 去掉字符串前后的空白字符 字符串的两种拼接方式拼接： 12$&#123;&quot;hello$&#123;emp.name!&#125;&quot;&#125; // 输出hello+变量名$&#123;&quot;hello&quot;+emp.name!&#125; // 使用+号来连接，输出hello+变量名 可以通过如下语法来截取子串: 1234567891011&lt;#assign str = &quot;abcdefghijklmn&quot;/&gt;// 方法1$&#123;str?substring(0,4)&#125; // 输出abcd// 方法2$&#123;str[0]&#125;$&#123;str[4]&#125; // 结果是ae$&#123;str[1..4]&#125; // 结果是bcde// 返回指定字符的索引$&#123;str?index_of(&quot;n&quot;)&#125; 2、日期输出1$&#123;emp.date?string(&apos;yyyy-MM-dd&apos;)&#125; //日期格式 3、数字输出(以数字20为例)12345678910111213$&#123;emp.name?string.number&#125; // 输出20$&#123;emp.name?string.currency&#125; // ￥20.00 $&#123;emp.name?string.percent&#125; // 20%$&#123;1.222?int&#125; // 将小数转为int，输出1&lt;#setting number_format=&quot;percent&quot;/&gt; // 设置数字默认输出方式(&apos;percent&apos;,百分比)&lt;#assign answer=42/&gt; // 声明变量 answer 42#&#123;answer&#125; // 输出 4,200%$&#123;answer?string&#125; // 输出 4,200%$&#123;answer?string.number&#125; // 输出 42$&#123;answer?string.currency&#125; // 输出 ￥42.00$&#123;answer?string.percent&#125; // 输出 4,200%#&#123;answer&#125; // 输出 42 123数字格式化插值可采用#&#123;expr;format&#125;形式来格式化数字,其中format可以是:mX:小数部分最小X位MX:小数部分最大X位 123456789如下面的例子:&lt;#assign x=2.582/&gt;&lt;#assign y=4/&gt;#&#123;x; M2&#125; // 输出2.58#&#123;y; M2&#125; // 输出4#&#123;x; m2&#125; // 输出2.58#&#123;y; m2&#125; // 输出4.0#&#123;x; m1M2&#125; // 输出2.58#&#123;x; m1M2&#125; // 输出4.0 4、申明变量12&lt;#assign foo=false/&gt; // 声明变量,插入布尔值进行显示,注意不要用引号$&#123;foo?string(&quot;yes&quot;,&quot;no&quot;)&#125; // 当为true时输出&quot;yes&quot;,否则输出&quot;no&quot; 申明变量的几种方式 1234567891011&lt;#assign name=value&gt; &lt;#assign name1=value1 name2=value2 ... nameN=valueN&gt; &lt;#assign same as above... in namespacehash&gt;&lt;#assign name&gt; capture this &lt;/#assign&gt;&lt;#assign name in namespacehash&gt; capture this &lt;/#assign&gt; 5、比较运算符表达式中支持的比较运算符有如下几个:= 或 == ：判断两个值是否相等.!= ：判断两个值是否不等.> 或 gt ：判断左边值是否大于右边值>= 或 gte ：判断左边值是否大于等于右边值&lt; 或 lt ：判断左边值是否小于右边值&lt;= 或 lte ：判断左边值是否小于等于右边值 6、算术运算符FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:+, - , * , / , %注意：（1）、运算符两边必须是数字（2）、使用+运算符时,如果一边是数字,一边是字符串,就会自动将数字转换为字符串再连接,如:${3 + “5”},结果是:35 7、逻辑运算符逻辑运算符有如下几个:逻辑与:&amp;&amp;逻辑或:||逻辑非:!逻辑运算符只能作用于布尔值,否则将产生错误 8、FreeMarker中的运算符优先级如下(由高到低排列):①、一元运算符:!②、内建函数:?③、乘除法:*, / , %④、加减法:- , +⑤、比较:&gt; , &lt; , &gt;= , &lt;= (lt , lte , gt , gte)⑥、相等:== , = , !=⑦、逻辑与:&amp;&amp;⑧、逻辑或:||⑨、数字范围:..实际上,我们在开发过程中应该使用括号来严格区分,这样的可读性好,出错少 9、if 逻辑判断（注意：elseif 不加空格）123456789&lt;#if condition&gt;...&lt;#elseif condition2&gt;...&lt;#elseif condition3&gt;...&lt;#else&gt;...&lt;/#if&gt; if 空值判断 123456789// 当 photoList 不为空时&lt;#if photoList??&gt;...&lt;/#if&gt; 值得注意的是,$&#123;..&#125;只能用于文本部分,不能用于表达式,下面的代码是错误的:&lt;#if $&#123;isBig&#125;&gt;Wow!&lt;/#if&gt;&lt;#if &quot;$&#123;isBig&#125;&quot;&gt;Wow!&lt;/#if&gt;// 正确写法&lt;#if isBig&gt;Wow!&lt;/#if&gt; 10、switch (条件可为数字，可为字符串)12345678910111213&lt;#switch value&gt; &lt;#case refValue1&gt; ....&lt;#break&gt; &lt;#case refValue2&gt; ....&lt;#break&gt; &lt;#case refValueN&gt; ....&lt;#break&gt; &lt;#default&gt; .... &lt;/#switch&gt; 11、集合 &amp; 循环12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 遍历集合:&lt;#list empList! as emp&gt; $&#123;emp.name!&#125;&lt;/#list&gt;// 可以这样遍历集合:&lt;#list 0..(empList!?size-1) as i&gt; $&#123;empList[i].name!&#125;&lt;/#list&gt;// 与jstl循环类似,也可以访问循环的状态。empList?size // 取集合的长度emp_index: // int类型，当前对象的索引值 emp_has_next: // boolean类型，是否存在下一个对象// 使用&lt;#break&gt;跳出循环&lt;#if emp_index = 0&gt;&lt;#break&gt;&lt;/#if&gt;// 集合长度判断 &lt;#if empList?size != 0&gt;&lt;/#if&gt; // 判断=的时候,注意只要一个=符号,而不是==&lt;#assign l=0..100/&gt; // 定义一个int区间的0~100的集合，数字范围也支持反递增,如100..2&lt;#list 0..100 as i&gt; // 等效于java for(int i=0; i &lt;= 100; i++) $&#123;i&#125;&lt;/#list&gt;// 截取子集合：empList[3..5] //返回empList集合的子集合,子集合中的元素是empList集合中的第4-6个元素// 创建集合：&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt;// 集合连接运算,将两个集合连接成一个新的集合&lt;#list [&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;] + [&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;] as x&gt;// 除此之外,集合元素也可以是表达式,例子如下:[2 + 2, [1, 2, 3, 4], &quot;whatnot&quot;]// seq_contains：判断序列中的元素是否存在&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;]&gt; $&#123;x?seq_contains(&quot;blue&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // yes$&#123;x?seq_contains(&quot;yellow&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // no$&#123;x?seq_contains(16)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // yes$&#123;x?seq_contains(&quot;16&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // no// seq_index_of：第一次出现的索引&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;, &quot;blue&quot;]&gt; $&#123;x?seq_index_of(&quot;blue&quot;)&#125; // 2// sort_by：排序（升序）&lt;#list movies?sort_by(&quot;showtime&quot;) as movie&gt;&lt;/#list&gt;// sort_by：排序（降序）&lt;#list movies?sort_by(&quot;showtime&quot;)?reverse as movie&gt;&lt;/#list&gt;// 具体介绍：// 不排序的情况：&lt;#list movies as moive&gt; &lt;a href=&quot;$&#123;moive.url&#125;&quot;&gt;$&#123;moive.name&#125;&lt;/a&gt;&lt;/#list&gt;//要是排序，则用&lt;#list movies?sort as movie&gt; &lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;&lt;/#list&gt;// 这是按元素的首字母排序。若要按list中对象元素的某一属性排序的话，则用&lt;#list moives?sort_by([&quot;name&quot;]) as movie&gt; &lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;&lt;/#list&gt;//这个是按list中对象元素的[name]属性排序的，是升序，如果需要降序的话，如下所示：&lt;#list movies?sort_by([&quot;name&quot;])?reverse as movie&gt; &lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;&lt;/#list&gt; 12、Map对象123456789// 创建map&lt;#assign scores = &#123;&quot;语文&quot;:86,&quot;数学&quot;:78&#125;&gt;// Map连接运算符&lt;#assign scores = &#123;&quot;语文&quot;:86,&quot;数学&quot;:78&#125; + &#123;&quot;数学&quot;:87,&quot;Java&quot;:93&#125;&gt;// Map元素输出emp.name // 全部使用点语法emp[&quot;name&quot;] // 使用方括号 13、FreeMarker支持如下转义字符:\” ：双引号(u0022)\’ ：单引号(u0027)\ ：反斜杠(u005C)\n ：换行(u000A)\r ：回车(u000D)\t ：Tab(u0009)\b ：退格键(u0008)\f ：Form feed(u000C)\l ：&lt;\g ：&gt;\a ：&amp;\{ ：{\xCode ：直接通过4位的16进制数来指定Unicode码,输出该unicode码对应的字符. 如果某段文本中包含大量的特殊符号,FreeMarker提供了另一种特殊格式:可以在指定字符串内容的引号前增加r标记,在r标记后的文件将会直接输出.看如下代码:${r”${foo}”} // 输出 ${foo}${r”C:/foo/bar”} // 输出 C:/foo/bar 14、include指令123456// include指令的作用类似于JSP的包含指令:&lt;#include &quot;/test.ftl&quot; encoding=&quot;UTF-8&quot; parse=true&gt;// 在上面的语法格式中,两个参数的解释如下:encoding=&quot;GBK&quot; // 编码格式parse=true // 是否作为ftl语法解析,默认是true，false就是以文本方式引入,注意:在ftl文件里布尔值都是直接赋值的如parse=true,而不是parse=&quot;true&quot; 15、import指令123// 类似于jsp里的import,它导入文件，然后就可以在当前文件里使用被导入文件里的宏组件&lt;#import &quot;/libs/mylib.ftl&quot; as my&gt;// 上面的代码将导入/lib/common.ftl模板文件中的所有变量,交将这些变量放置在一个名为com的Map对象中，&quot;my&quot;在freemarker里被称作namespace 17、compress 压缩1234// 用来压缩空白空间和空白的行 &lt;#compress&gt; ... &lt;/#compress&gt; 1234567&lt;#t&gt; // 去掉左右空白和回车换行 &lt;#lt&gt;// 去掉左边空白和回车换行 &lt;#rt&gt;// 去掉右边空白和回车换行 &lt;#nt&gt;// 取消上面的效果 18、escape,noescape 对字符串进行HTML编码1234567891011// escape指令导致body区的插值都会被自动加上escape表达式,但不会影响字符串内的插值,只会影响到body内出现的插值,使用escape指令的语法格式如下:&lt;#escape x as x?html&gt; First name: $&#123;firstName&#125; &lt;#noescape&gt;Last name: $&#123;lastName&#125;&lt;/#noescape&gt; Maiden name: $&#123;maidenName&#125; &lt;/#escape&gt;// 相同表达式First name: $&#123;firstName?html&#125; Last name: $&#123;lastName&#125; Maiden name: $&#123;maidenName?html&#125; ———————————- 高级语法 ———————————-1、global全局赋值语法123456789&lt;#global name=value&gt; &lt;#global name1=value1 name2=value2 ... nameN=valueN&gt; &lt;#global name&gt; capture this &lt;/#global&gt;// 利用这个语法给变量赋值，那么这个变量在所有的namespace中是可见的，如果这个变量被当前的assign语法覆盖如&lt;#global x=2&gt;&lt;#assign x=1&gt;在当前页面里x=2将被隐藏，或者通过$&#123;.globals.x&#125; 来访问 2、setting 语法123456789101112131415// 用来设置整个系统的一个环境 locale // zh_CN 中文环境number_format boolean_format date_format , time_format , datetime_format time_zone classic_compatible// 例1：&lt;#setting number_format=&quot;percent&quot;/&gt; // 设置数字默认输出方式(&apos;percent&apos;,百分比)// 例2：// 假如当前是匈牙利的设置，然后修改成美国$&#123;1.2&#125; // 输出1,2&lt;#setting locale=&quot;en_US&quot;&gt; $&#123;1.2&#125; // 输出1.2,因为匈牙利是采用&quot;, &quot;作为十进制的分隔符，美国是用&quot;. &quot; 3、macro宏指令例子1： 12345678910&lt;#-- 定义宏 --&gt;&lt;#macro test foo bar=&quot;Bar&quot; baaz=-1&gt; Text: $&#123;foo&#125;, $&#123;bar&#125;, $&#123;baaz&#125;&lt;/#macro&gt;&lt;#-- 使用宏 --&gt;&lt;@test foo=&quot;a&quot; bar=&quot;b&quot; baaz=5*5/&gt; // 输出：Text: a, b, 25&lt;@test foo=&quot;a&quot; bar=&quot;b&quot;/&gt; // 输出：Text: a, b, -1&lt;@test foo=&quot;a&quot; baaz=5*5-2/&gt; // 输出：Text: a, Bar, 23&lt;@test foo=&quot;a&quot;/&gt; // 输出：Text: a, Bar, -1 例子2： 1234567891011&lt;#-- 定义一个循环输出的宏 --&gt;&lt;#macro list title items&gt; $&#123;title&#125; &lt;#list items as x&gt; *$&#123;x&#125; &lt;/#list&gt; &lt;/#macro&gt; &lt;#-- 使用宏 --&gt;&lt;@list items=[&quot;mouse&quot;, &quot;elephant&quot;, &quot;python&quot;] title=&quot;Animals&quot;/&gt;// 输出Animals *mouse *elephant *python 例子3： 123456789101112131415&lt;#-- 嵌套宏 --&gt;&lt;#macro border&gt; &lt;table&gt; &lt;#nested&gt; &lt;/table&gt;&lt;/#macro&gt;&lt;#-- 嵌套宏使用 --&gt;&lt;@border&gt; &lt;tr&gt;&lt;td&gt;hahaha&lt;/td&gt;&lt;/tr&gt;&lt;/@border&gt; 输出结果：&lt;table&gt; &lt;tr&gt;&lt;td&gt;hahaha&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 例子4：在nested指令中使用循环变量时,可以使用多个循环变量,看如下代码: 12345678910111213141516&lt;#-- 循环嵌套宏 --&gt;&lt;#macro repeat count&gt; &lt;#list 1..count as x&gt; &lt;#nested x, x/2, x==count&gt; // 使用nested指令时指定了三个循环变量 &lt;/#list&gt;&lt;/#macro&gt;&lt;#-- 使用宏 --&gt;&lt;@repeat count = 4; c, halfc, last&gt; $&#123;c&#125;. $&#123;halfc&#125;&lt;#if last&gt; Last!&lt;/#if&gt;&lt;/@repeat&gt;// 输出结果：// 1. 0.5// 2. 1// 3. 1.5// 4. 2 Last! freemarker 宏嵌套nested 的使用: 4、结束macro指令1234567891011// return指令用于结束macro指令&lt;#-- 创建宏 --&gt;&lt;#macro book&gt; spring &lt;#return&gt; j2ee&lt;/#macro&gt;&lt;#-- 使用宏 --&gt;&lt;@book /&gt;// 上面的代码输出:spring,而j2ee位于return指令之后,不会输出.]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分别使用原生Ajax 和Jquery的方式发送请求]]></title>
    <url>%2F2018%2F08%2F19%2FAjaxAndJquery%2F</url>
    <content type="text"><![CDATA[分别使用原生Ajax 和Jquery的方式发送请求Ajax 是什么? “Asynchronous Javascript And XML”（异步JavaScript和XML）， 并不是新的技术，只是把原有的技术，整合到一起而已。 12341.使用CSS和XHTML来表示。2. 使用DOM模型来交互和动态显示。3.使用XMLHttpRequest来和服务器进行异步通信。4.使用javascript来绑定和调用。 有什么用? 咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。 就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。 内部原理诚如前面所说的， Ajax 并不是一项新技术。而是包装了现有的技术，然后使用他们来完成工作而已。 那么现在给大家举个例子， 还是以咱们的判断用户名是否已被注册为例。 传统方式： 123451. 输入用户名，2. 点击一个按钮，校验。3. 把数据提交给服务器4. 服务器在后台帮助我们完成校验，并且反馈信息。5. 我们在浏览器上提示用户，给出结果 Ajax方式： 123456789ajax方式与前面的方式其实从要做的事情来说，是一样的。 ajax也没有牛到，不用去访问服务器就知道你的用户名是否已被占用。那么它是如何工作的呢?1. 通过JS 获取咱们的输入框文本内容 document.getElementById(&quot;username&quot;).value2. 通过XmlHttpRequest 去执行请求。 XmlHttpRequest 其实就是 XML + http + Request 的组合。3. 请求结束后，收到结果， 再使用 js 去完成提示。 4. 可以在顺便配合 css 样式来增加提示效果。 Ajax 的请求/响应与服务器上的 Web 应用程序打交道的是 JavaScript 技术，而不是直接提交给那个应用程序的 HTML 表单。发出请求如何使用XMLHttpRequest 对象?首先–需要一个能够调用JavaScript 方法 的Web 页面 。接下来就是在所有 Ajax 应用程序中基本都雷同的流程： 1、从 Web 表单中获取需要的数据。2、建立要连接的 URL。3、打开到服务器的连接。4、设置服务器在完成后要运行的函数。5、发送请求。 数据请求 Get123456789101112131415161718192021222324252627282930313233343536373839//创建对象function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; //2.发送请求 //执行get请求 function get() &#123; //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求。 // http://localhost:8080/day16/demo01.jsp //http://localhost:8080/day16/DemoServlet01 /* 参数一： 请求类型 GET or POST 参数二： 请求的路径 参数三： 是否异步， true or false */ request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01&quot; ,true ); request.send();&#125; 12345678910111213141516171819202122如果发送请求的同时，还想获取数据，那么代码如下//执行get请求function get() &#123; //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求 request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01?name=aa&amp;age=18&quot; ,true ); //3. 获取响应数据 注册监听的意思。 一会准备的状态发生了改变，那么就执行 = 号右边的方法 request.onreadystatechange = function()&#123; //前半段表示 已经能够正常处理。 再判断状态码是否是200，已经处理请求 if(request.readyState == 4 &amp;&amp; request.status == 200)&#123; //弹出响应的信息 alert(request.responseText); &#125; &#125; request.send();&#125; 数据请求 Post1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script type=&quot;text/javascript&quot;&gt;//1. 创建对象function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125;function post() &#123; //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( &quot;POST&quot;, &quot;/day16/DemoServlet01&quot;, true ); //如果不带数据，写这行就可以了 //request.send(); //如果想带数据，就写下面的两行 //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //带数据过去 ， 在send方法里面写表单数据。 request.send(&quot;name=aobama&amp;age=19&quot;);&#125;&lt;/script&gt; 1234567891011121314151617181920//需要获取数据function post() &#123; //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( &quot;POST&quot;, &quot;/day16/DemoServlet01&quot;, true ); //想获取服务器传送过来的数据， 加一个状态的监听。 request.onreadystatechange=function()&#123; if(request.readyState==4 &amp;&amp; request.status == 200)&#123; alert(&quot;post：&quot;+request.responseText); &#125; &#125; //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //带数据过去 ， 在send方法里面写表单数据。 request.send(&quot;name=aobama&amp;age=19&quot;); &#125; JQuery的方式实现请求与相应load123&lt;a href=&quot;&quot; onclick=&quot;load()&quot;&gt;使用JQuery执行load方法&lt;/a&gt;有两次刷新， 先走 onClick的方法，取到数据回来之后，赋值显示。 接着 走 href=&quot;&quot;的路径，但是这个属性没有给值，所以会把当前的页面重新再刷新一次。所以导致看不见值。 12345//找到这个元素， 去执行加载的动作， 加载/day16/DemoServlet02 ， 得到的数据，赋值显示$(&quot;#aaa&quot;).load(&quot;/day16/DemoServlet02&quot; , function(responseText , statusTXT , xhr) &#123; //找到id为text01的元素， 设置它的value属性值为 responseText 对应的值 $(&quot;#aaa&quot;).val(responseText); &#125;); Get123$.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) &#123; $(&quot;#div01&quot;).text(data); &#125;); 赋值显示 val(“aa”); 只能放那些标签带有value属性 html(“aa”); —写html代码 text(“aa”); 其实没有什么区别，如果想针对这分数据做html样式处理，那么只能用html() post123456function post() &#123; $.post("/day16/DemoServlet02", &#123;name:"zhangsan",age:18&#125;,function(data,status) &#123; //想要放数据到div里面去。 --- 找到div $("#div01").html(data); &#125;); &#125; load &amp; get&amp;post比较 load $(“#元素id”).load(url地址); 1$(&quot;#div1&quot;).load(serlvet); ---&gt; 使用的get请求，回来赋值的时候， 使用text（）;去赋值 get 语法格式 ： $.get(URL,callback); 123使用案例： $.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) &#123; $(&quot;#div01&quot;).text(data);&#125;); post 语法格式：$.post(URL,data,callback); 123456function post() &#123; $.post(&quot;/day16/DemoServlet02&quot;, &#123;name:&quot;zhangsan&quot;,age:18&#125;,function(data,status) &#123; //想要放数据到div里面去。 --- 找到div $(&quot;#div01&quot;).html(data); &#125;);&#125; 使用JQuery去实现校验用户名1234567891011121314151617function checkUserName() &#123; //1. 获取输入框的内容 var name = $(&quot;#name&quot;).val(); //2. 发送请求 $.post(&quot;/day16/CheckUserNameServlet&quot; , &#123;name:name&#125; , function(data , status)&#123; //alert(data); if(data == 1)&#123;//用户名存在 //alert(&quot;用户名存在&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;red&apos;&gt;用户名已被注册&lt;/font&gt;&quot;); &#125;else&#123; //alert(&quot;用户名可用&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;green&apos;&gt;用户名可以使用&lt;/font&gt;&quot;); &#125; &#125; ); //3. 输出响应的数据到页面上。&#125;]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Ajax</tag>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础知识学习总结]]></title>
    <url>%2F2018%2F08%2F19%2FjQuery%2F</url>
    <content type="text"><![CDATA[jQuery基础知识学习总结什么JQuery: jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等 使用jQuery完成页面定时弹出广告定时器: setInterval clearInterval setTimeout clearTimeout 显示: img.style.display = “block” 隐藏: img.style.display = “none” img 对象 style属性: style对象 使用jQuery完成表格的隔行换色获得所有的行 table.rows[] 修改行的颜色 row.bgColor =&quot;red&quot; row.style.backgroundColor = &quot;black&quot; row.style.background = &quot;red&quot; &quot;background-color:red&quot; &quot;background:red&quot; 使用jQuery完成复选框的全选效果checked属性 如何获取所有复选框: document.getElementsByName get Elements By Name 数据库里面 使用jQuery完成省市联动效果JS中的数组: [&quot;城市&quot;] new Array() DOM树操作: 创建节点: document.createElement 创建文本节点: document.createTextNode 添加节点: appendChild 使用jQuery完成下列列表左右选择select下拉列表 multiple 允许多选 ondblclick : 双击事件 for循环遍历,一边遍历一边移除出现的问题 使用jQuery完成表单的校验(扩展)事件: 获得焦点事件: onfocus 失去焦点事件: onblur 按键抬起事件: onkeyup 鼠标移入: onmouseenter 鼠标移出: onmouseout JS引入外部文件 : script 使用jQuery完成页面定时弹出广告JQ的入门 1234567891011121314151617181920212223242526272829&lt;script&gt; //js文档加载完成的事件 window.onload = function()&#123; alert("window.onload 111"); &#125; window.onload = function()&#123; alert("window.onload 222"); &#125; /*文档加载完成的事件*/ jQuery(document).ready(function()&#123; alert("jQuery(document).ready(function()"); &#125;); /* jQuery 简写成 $ */ $(document).ready(function()&#123; alert("$(document).ready(function()"); &#125;); /* 最简单的写法 */ $(function()&#123; alert("$(function()&#123;"); &#125;); &lt;/script&gt; 【JQ中根据ID查找元素】 1234全都是根据选择器去找的#ID&#123;&#125;.类名&#123;&#125;$("#ID的名称") 【JQ和JS之间的转换】 JQ对象,只能调用JQ的属性和方法 JS对象 只能调用JS的属性和方法 12345678910111213141516171819function changeJS()&#123; var div = document.getElementById("div1");// div.innerHTML = "JS成功修改了内容" //将JS对象转成JQ对象 $(div).html("转成JQ对象来修改内容") &#125; $(function()&#123; //给按钮绑定事件 $("#btn2").click(function()&#123; //找到div1// $("#div1").html("JQ方式成功修改了内容"); //将JQ对象转成JS对象来调用 var $div = $("#div1");// var jsDiv = $div.get(0); var jsDiv = $div[0]; jsDiv.innerHTML="jq转成JS对象成功"; &#125;); &#125;); JQ的开发步骤: (将我们页面的JS代码和HTML页面代码进行分离) 123451. 导入JQ相关的文件2. 文档加载完成事件: $(function) : 页面初始化的操作: 绑定事件, 启动页面定时器3. 确定相关操作的事件4. 事件触发函数5. 函数里面再去操作相关的元素 显示和隐藏 img.style.display 【JQ中的动画效果】 1234567show()hide()slideUpslideDownfadeInfadeOutanimate : 自定义动画 步骤分析： 导入JQ的文件 编写JQ的文档加载事件 启动定时器 setTimeout(“”,3000); 编写显示广告的函数 在显示广告里面再启动一个定时器 编写隐藏广告的函数 代码实现1234567891011121314&lt;script&gt; //显示广告 function showAd()&#123; $("#img1").slideDown(2000); setTimeout("hideAd()",3000); &#125; //隐藏广告 function hideAd()&#123; $("#img1").slideUp(2000); &#125; $(function()&#123; //文档加载完成才这么做 setTimeout("showAd()",3000); &#125;);&lt;/script&gt; jQuery中的选择器让我们能够更加精确找到我们要操作的元素 基本选择器 ID选择器 : #ID的名称 类选择器: 以 . 开头 .类名 元素选择器: 标签的名称 通配符选择器: * 选择器,选择器: 选择器1,选择器2 基本选择器的案例12345678910111213141516171819202122232425262728293031323334&lt;!-- - ID选择器 : #ID的名称 - 类选择器: 以 . 开头 .类名 - 元素选择器: 标签的名称 - 通配符选择器: * - 选择器,选择器: 选择器1,选择器2 --&gt; &lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 $("#btn1").click(function()&#123; $("#two").css("background-color","palegreen"); &#125;); //找出mini类的所有元素 $("#btn2").click(function()&#123; $(".mini").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("*").css("background-color","palegreen"); &#125;); /*选择器分组*/ //找出mini类 和 span元素 $("#btn5").click(function()&#123; $(".mini,span").css("background-color","palegreen"); &#125;); &#125;); &lt;/script&gt; JQ中的层级选择器 子元素选择器: 选择器1 &gt; 选择器2 后代选择器: 选择器1 儿孙 相邻兄弟选择器 : 选择器1 + 选择器2 : 找出紧挨着的一个弟弟 找出所有弟弟: 选择器1~ 选择器2 : 找出所有的弟弟 123456789101112131415161718192021&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //找出body下面的子div $("#btn1").click(function()&#123; $("body &gt; div").css("background-color","palegreen"); &#125;); //找出body下面的所有div $("#btn2").click(function()&#123; $("body div").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("#one+div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("#two~div").css("background-color","palegreen"); &#125;); &#125;);&lt;/script&gt; JQ中的基本过滤器12345678910111213141516171819202122232425&lt;script&gt; $(function()&#123; /&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //过滤出所有div中第一个元素 $("#btn1").click(function()&#123; $("div:first").css("background-color","palegreen"); &#125;); //过滤出所有div中偶数位的div $("#btn2").click(function()&#123; $("div:even").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div:odd").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("div:gt(2)").css("background-color","palegreen"); &#125;); &#125;);&lt;/script&gt; JQ中的属性选择器123456789101112$(function()&#123;//找到有name属性的input $("#btn1").click(function()&#123; $("input[name]").attr("checked",true); &#125;); $("#btn2").click(function()&#123; $("input[name='accept']").attr("checked",true); &#125;); $("#btn3").click(function()&#123; $("input[name='newsletter'][value='Hot Fuzz']").attr("checked",true); &#125;);&#125;); JQ中的表单过滤器123456&lt;script&gt; //1.文档加载事件 $(function()&#123; $(":text").css("background-color","pink"); &#125;);&lt;/script&gt; 使用JQ完成表格的隔行换色步骤分析: 导入JQ的包 文档加载完成函数: 页面初始化 获得所有的行 : 元素选择器 根据行号去修改颜色 代码实现:123456789 $(function()&#123; //获得所有的行 : 元素选择器 $("tbody &gt; tr:even").css("background-color","#CCCCCC"); //修改基数行 $("tbody &gt; tr:odd").css("background-color","#FFF38F");// $("tbody &gt; tr").css("background-color","#FFF38F"); &#125;); 使用JQ完成省市联动效果技术分析: 准备工作 : 城市信息的数据 添加节点 : appendChild (JS) append : 添加子元素到末尾 appendTo : 给自己找一个爹,将自己添加到别人家里 prepend : 在子元素前面添加 after : 在自己的后面添加一个兄弟 遍历的操作: 步骤分析: 导入JQ的文件 文档加载事件:页面初始化 进一步确定事件: change事件 函数: 得到当前选中省份 得到城市, 遍历城市数据 将遍历出来的城市添加到城市的select中 代码实现:123456789101112131415161718$(function()&#123; $("#province").change(function()&#123;// alert(this.value); //得到城市信息 var cities = provinces[this.value]; //清空城市select中的option /*var $city = $("#city"); //将JQ对象转成JS对象 var citySelect = $city.get(0) citySelect.options.length = 0;*/ $("#city").empty(); //采用JQ的方式清空 //遍历城市数据 $(cities).each(function(i,n)&#123; $("#city").append("&lt;option&gt;"+n+"&lt;/option&gt;"); &#125;); &#125;); &#125;); 使用JQ完成下拉列表左右选择步骤分析123451. 导入JQ的文件2. 文档加载函数 :页面初始化3.确定事件 : 点击事件 onclick4. 事件触发函数1. 移动被选中的那一项到右边 代码实现123456789101112131415&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $("#a1").click(function()&#123; //找到被选中的那一项 //将被选中项添加到右边 $("#rightSelect").append($("#leftSelect option:selected")); &#125;); //将左边所有商品移动到右边 $("#a2").click(function()&#123; $("#rightSelect").append($("#leftSelect option")); &#125;); &#125;);&lt;/script&gt; 使用JQ完成表单的校验(扩展)技术分析 trigger triggerHandler is() 步骤分析 首先给必填项,添加尾部添加一个小红点 获取用户输入的信息,做相应的校验 事件: 获得焦点, 失去焦点, 按键抬起 表单提交的事件 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;link rel="stylesheet" href="../css/style.css" /&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 1. 首先给必填项,添加尾部添加一个小红点 2. 获取用户输入的信息,做相应的校验 3. 事件: 获得焦点, 失去焦点, 按键抬起 4. 表单提交的事件 Jq的方式来实现: 1. 导入JQ的文件 2. 文档加载事件: 在必填项后天加一个小红点 3. 表单校验确定事件: blur focus keyup 4. 提交表单 submit --&gt; &lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; //默认做一些页面初始化 //动态在必填项后面添加小红点 $(".bitian").after("&lt;font class='high'&gt;*&lt;/font&gt;"); //给必填项绑定事件 $(".bitian").blur(function()&#123; //首先获取用户当前输入的值 var value = this.value; //123 //清空上一次提示的信息 $(this).parent().find(".formtips").remove(); //判断当前的值是哪一项输入的值 if($(this).is("#username"))&#123; //判断是否是用户名输入项 if(value.length &lt; 6)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;用户名太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;用户名够用&lt;/span&gt;"); &#125; &#125; if($(this).is("#password"))&#123; //判断是否是密码输入项 if(value.length &lt; 6)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;,密码太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;密码够用&lt;/span&gt;"); &#125; &#125; &#125;).focus(function()&#123; $(this).triggerHandler("blur"); &#125;).keyup(function()&#123; $(this).triggerHandler("blur"); &#125;) //给表单提交绑定事件 $("form").submit(function()&#123; //触发所有必填项的校验 $(".bitian").trigger("focus"); //找到错误信息的个数 if($(".onError").length &gt; 0)&#123; return false; &#125; return true; &#125;); &#125;); /* $(function()&#123; // 在所有必填项后天加一个小红点 * $(".bitian").after("&lt;font class='high'&gt;*&lt;/font&gt;"); //事件绑定 $(".bitian").blur(function()&#123;// var value = this.value; var value = $(this).val(); //清空当前必填项后面的span // $(".formtips").remove(); $(this).parent().find(".formtips").remove(); //获得当前事件是谁的 if($(this).is("#username"))&#123; //校验用户名 if(value.length &lt; 6)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;用户名太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;用户名够用&lt;/span&gt;"); &#125; &#125; if($(this).is("#password"))&#123; //校验密码 if(value.length &lt; 3)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;密码太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;密码够用&lt;/span&gt;"); &#125; &#125; &#125;).focus(function()&#123; $(this).triggerHandler("blur"); &#125;).keyup(function()&#123; $(this).triggerHandler("blur"); &#125;); // $(".bitian").blur(function()&#123;&#125;).focus(function()&#123;&#125;).keyup(function()&#123;&#125;) //给表单绑定提交事件 $("form").submit(function()&#123; //触发必填项的校验逻辑 $(".bitian").trigger("focus"); var length = $(".onError").length if(length &gt; 0)&#123; return false; &#125; return true; &#125;); &#125;);*/ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="../index.html"&gt; &lt;div&gt; 用户名:&lt;input type="text" class="bitian" id="username" /&gt; &lt;/div&gt; &lt;div&gt; 密码:&lt;input type="password" class="bitian" id="password" /&gt; &lt;/div&gt; &lt;div&gt; 手机号:&lt;input type="tel" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 使用JQuery发送请求局部刷新页面数据交换格式: json xml 什么是JSON JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。 JSON格式 JSON对象 12&#123; key1:value&#125; &#123;"username":"zhangsan","password":"123"&#125; JSON数组 1[&#123; key1:value&#125;,&#123; key1:value&#125;,&#123; key1:value&#125;] 内容总结:定时器 动画效果: show hide slideDown slideUp fadeIn fadeOut animate 基本选择器: ID选择器: #ID名称 类选择器: .类名 元素选择器: 元素/标签名称 通配符选择器: * 找出所有页面元素 包含页面上所有的标签 选择器分组 : 选择器1, 选择器2 [选择器1,选择器2] 层级选择器: 后代选择器: 选择器1 选择器2 找出所有的后代,儿子孙子曾孙 子元素选择器: 选择器1 &gt;选择器2 找出所有儿子 相邻兄弟选择器: 选择器1+选择器2 : 找出紧挨着自己那个弟弟 兄弟选择器 : 选择器1~选择器2 : 找出所有的弟弟 属性选择器: 选择器[属性名称] 12选择器[属性名称][属性名名]选择器[属性名称='属性值'][属性名称='属性值'][属性名称='属性值'] 表单选择器: :input 找出所有的输入项 : 不单单找出input textarea select :text 找出type类型为 text :password 基本过滤器: :even :odd :gt :lt :eq :first :last 表单对象属性: :selected :checked 123456789101112131415161718$(function) : 文档加载完成的事件css() : 修改css样式prop() : 修改属性/ 获取属性html() : 修改innerHTMLappend : 给自己添加子节点appendTo : 将自己添加到别人家,给自己找一个爹prepend : 在自己最前面添加子节点after : 在自己后面添加一个兄弟empty : 清空所有子节点$(cities).each(function(i,n)&#123; &#125;)$.each(arr,function(i,n)&#123; &#125;);]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap基础知识学习]]></title>
    <url>%2F2018%2F08%2F16%2FBootStrap%2F</url>
    <content type="text"><![CDATA[BootStrap基础学习使用BootStrap开发一个响应式的页面出来BootStap概述 什么是BootStrap Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。 Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。Bootstrap一经推出后颇受欢迎，一直是GitHub上的热门开源项目，包括NASA的MSNBC（微软全国广播公司）的Breaking News都使用了该项目。国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于Bootstrap源码进行性能优化而来 BootStrap结构 全局CSS bootStrap中已经定义好了一套CSS的样式表 组件 BootStrap定义的一套按钮,导航条等组件 JS插件 BootStrap定义了一套JS的插件,这些插件已经默认实现了很多种效果 BootStrap的入门开发 引入相关的头文件 12345678910&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel="stylesheet" href="../css/bootstrap.css" /&gt;&lt;!--需要引入JQuery--&gt;&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script type="text/javascript" src="../js/bootstrap.js" &gt;&lt;/script&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; BootStrap的布局容器 .container 类用于固定宽度并支持响应式布局的容器。 123&lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt; .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。 123&lt;div class=&quot;container-fluid&quot;&gt; ...&lt;/div&gt; 校验表单扩展: trigger : 触发浏览器默认行为 triggerHandler : 不会触发 is : 判断 find : 查找 什么json: 轻量级的数据交换格式 json对象: {“username”:”zhangsan”} json数组: [ {“username”:”zhangsan”}, {“username”:”zhangsan”}, {“username”:”zhangsan”}] ajax异步请求: 同步和异步 row Bootstrap 栅格系统的工作原理： “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。 通过“行（row）”在水平方向创建一组“列（column）”。 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding BootStrap的栅格系统 响应式设计: 这种设计依赖于CSS3中的媒体查询 栅格样式: 设备分辨率大于1200 使用lg样式 设备分辨率大于992 &lt; 1200 使用md样式 设备分辨率大于768 &lt; 992 使用sm样式 设备分辨率小于768使用xs样式 BootStrap的全局CSS 定义了一套CSS 对页面中的元素进行定义 列表元素,表单,按钮,图片 简单案例实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 准备工作: &lt;meta name='viewport'&gt; 1.导入bootstrap css文件 2.导入JQuery 3.bootstrap.js 4.写一个div class = container 支持响应式的布局容器 --&gt; &lt;link rel="stylesheet" href="../css/bootstrap.min.css"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt; &lt;script src="../js/jquery-1.11.0.js"&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src="../js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-4"&gt; &lt;img src="../img/logo2.png" /&gt; &lt;/div&gt; &lt;div class="col-md-4 hidden-xs"&gt; &lt;img src="../img/header.png" /&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--菜单--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;nav class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container-fluid"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt; &lt;a href="#"&gt;手机数码&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;鞋靴箱包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;电脑办公&lt;/a&gt; &lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt;所有分类 &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu" role="menu"&gt; &lt;li&gt; &lt;a href="#"&gt;手机数码&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;鞋靴箱包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;电脑办公&lt;/a&gt; &lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;Separated link&lt;/a&gt; &lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;One more separated link&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-right" role="search"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="请输入要搜索的商品"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- /.navbar-collapse --&gt; &lt;/div&gt; &lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;img src="../img/1.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="../img/2.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="../img/3.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--最新商品这里--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;h3&gt;最新商品&lt;img src="../images/title2.jpg"/&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--商品部分 --&gt; &lt;div class="row"&gt; &lt;!--左边div--&gt; &lt;div class="col-md-2 hidden-sm hidden-xs"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%" /&gt; &lt;/div&gt; &lt;!--右边div--&gt; &lt;div class="col-md-10"&gt; &lt;!--上面部分--&gt; &lt;div class="row"&gt; &lt;!--中等广告图--&gt; &lt;div class="col-md-6"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--下面部分--&gt; &lt;div class="row"&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;img src="../products/hao/ad.jpg" width="100%" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--最新商品这里--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;h3&gt;最新商品&lt;img src="../images/title2.jpg"/&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--商品部分 --&gt; &lt;div class="row"&gt; &lt;!--左边div--&gt; &lt;div class="col-md-2 hidden-sm hidden-xs"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%" /&gt; &lt;/div&gt; &lt;!--右边div--&gt; &lt;div class="col-md-10"&gt; &lt;!--上面部分--&gt; &lt;div class="row"&gt; &lt;!--中等广告图--&gt; &lt;div class="col-md-6"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--下面部分--&gt; &lt;div class="row"&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--页脚广告--&gt; &lt;div&gt; &lt;img src="../image/footer.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--网站声明--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="http://www.itheima.com"&gt;关于我们&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;联系我们&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;招贤纳士&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;法律声明&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;友情链接&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;支付方式&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;配送方式&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;服务声明&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;广告声明&lt;/a&gt; &lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>BootStrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识学习]]></title>
    <url>%2F2018%2F08%2F16%2FjavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript基础知识学习概述JavaScript概述什么是javascript: JavaScript一种直译式脚本语言， 什么是脚本语言? java源代码 ----&gt; 编译成.class文件 -----&gt; java虚拟机中才能执行 脚本语言: 源码 -------- &gt; 解释执行 js由我们的浏览器来解释执行 HTML: 决定了页面的框架 CSS: 用来美化我们的页面 JS: 提供用户的交互的 JS的组成:ECMAScript : 核心部分 ,定义js的语法规范 DOM: document Object Model 文档对象模型 , 主要是用来管理页面的 BOM : Browser Object Model 浏览器对象模型, 前进,后退,页面刷新, 地址栏, 历史记录, 屏幕宽高 JS的语法:变量弱类型: var i = true 区分大小写 语句结束之后的分号 ,可以有,也可以没有 写在script标签 JS的数据类型: 基本类型 string number boolean undefine null 引用类型 对象, 内置对象 类型转换 js内部自动转换 JS的运算符和语句: 运算符和java 一样 “===” 全等号: 值和类型都必须相等 == 值相等就可以了 语句和java 一样 JS的输出 alert() 直接弹框 document.write() 向页面输出 console.log() 向控制台输出 innerHTML: 向页面输出 获取页面元素: document.getElementById(“id的名称”); JS声明变量: var 变量的名称 = 变量的值 JS声明函数: var 函数的名称 = function(){ } function 函数的名称(){ } JS开发步骤1231. 确定事件2. 事件要触发函数,所以我们是要声明函数3. 函数里面通常是去做一些交互才操作, 弹框, 修改页面内容,动态去添加一些东西 使用JS完成简单的数据校验使用JS完成对注册页面的简单数据校验,不允许出现用户名或密码为空的情况 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 1. 确认事件: 表单提交事件 onsubmit事件 2. 事件所要触发的函数: checkForm 3. 函数中要干点事情 1. 校验用户名, 用户不能为空, 长度不能小于6位 1.获取到用户输入的值 */ function checkForm()&#123; //获取用户名输入项 var inputObj = document.getElementById("username"); //获取输入项的值 var uValue = inputObj.value;// alert(uValue); //用户名长度不能6位 "" if(uValue.length &lt; 6 )&#123; alert("对不起,您的长度太短!"); return false; &#125; //密码长度大于6 和确认必须一致 //获取密码框输入的值 var input_password = document.getElementById("password"); var uPass = input_password.value; if(uPass.length &lt; 6)&#123; alert("对不起,您还是太短啦!"); return false; &#125; //获取确认密码框的值 var input_repassword = document.getElementById("repassword"); var uRePass = input_repassword.value; if(uPass != uRePass)&#123; alert("对不起,两次密码不一致!"); return false; &#125; //校验手机号 var input_mobile = document.getElementById("mobile"); var uMobile = input_mobile.value; // if(!/^[1][3578][0-9]&#123;9&#125;$/.test(uMobile))&#123; alert("对不起,您的手机号无法识别!"); return false; &#125; //校验邮箱: /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/ var inputEmail = document.getElementById("email"); var uEmail = inputEmail.value; if(!/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/.test(uEmail))&#123; alert("对不起,邮箱不合法"); return false; &#125; return true; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="JS开发步骤.html" onsubmit="return checkForm()"&gt; &lt;div&gt;用户名:&lt;input id="username" type="text" /&gt;&lt;/div&gt; &lt;div&gt;密码:&lt;input id="password" type="password" /&gt;&lt;/div&gt; &lt;div&gt;确认密码:&lt;input id="repassword" type="password" /&gt;&lt;/div&gt; &lt;div&gt;手机号码:&lt;input id="mobile" type="number" /&gt;&lt;/div&gt; &lt;div&gt;邮箱:&lt;input id="email" type="text" /&gt;&lt;/div&gt; &lt;div&gt;&lt;input type="submit" value="注册" /&gt;&lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 使用JS完成图片的轮播效果步骤分析:1234561. 确定事件: 文档加载完成的事件 onload2. 事件要触发 : init()3. 函数里面要做一些事情:(通常会去操作元素,提供交互) 1. 开启定时器: 执行切换图片的函数 changeImg()4. changeImg() 1. 获得要切换图片的那个元素 代码实现:1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 当页面加载完成的时候, 动态切换图片 1.确定事件: 2.事件所要触发的函数 */ var index = 1; //切换图片的函数 function changeAd()&#123; //获取要操作的img var img = document.getElementById("imgAd"); img.src = "../img/"+(index%3+1)+".jpg"; //0,1,2 //1,2,3 index++; &#125; function init()&#123; //启动定时器 setInterval("changeAd()",3000); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="init()"&gt; &lt;img src="../img/1.jpg" id="imgAd"/&gt; &lt;/body&gt;&lt;/html&gt; 完成页面定时弹出图片技术分析 定时器 setInterval : 每隔多少毫秒执行一次函数 setTimeout: 多少毫秒之后执行一次函数 clearInterval clearTimeout 显示广告 img.style.display = “block” 隐藏广告 img.style.display = “none” 步骤分析 确定事件: 页面加载完成的事件 onload 事件要触发函数: init() init函数里面做一件事: 启动一个定时器 : setTimeout() 显示一个广告 再去开启一个定时5秒钟之后,关闭广告 代码实现1234567891011121314151617181920212223&lt;script&gt; function init()&#123; setTimeout("showAD()",3000); &#125; function showAD()&#123; //首先要获取要操作的img var img = document.getElementById("img1"); //显示广告 img.style.display = "block"; //再开启定时器,关闭广告 setTimeout("hideAD()",3000); &#125; function hideAD()&#123; //首先要获取要操作的img var img = document.getElementById("img1"); //隐藏广告 img.style.display = "none"; &#125; &lt;/script&gt; 完成完成表单的校验【JS中的常用事件】 onfocus 事件: 获得焦点事件 onblur : 失去焦点 onkeyup : 按键抬起事件 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入外部的js文件 --&gt; &lt;script type="text/javascript" src="../js/regutils.js" &gt;&lt;/script&gt; &lt;script&gt; /* 1. 确定事件 : onfocus 2. 事件要驱动函数 3. 函数要干一些事情: 修改span的内容 */ function showTips(spanID,msg)&#123; //首先要获得要操作元素 span var span = document.getElementById(spanID); span.innerHTML = msg; &#125; /* 校验用户名: 1.事件: onblur 失去焦点 2.函数: checkUsername() 3.函数去显示校验结果 */ function checkUsername()&#123; //获取用户输入的内容 var uValue = document.getElementById("username").value; //对输入的内容进行校验 //获得要显示结果的span var span = document.getElementById("span_username"); if(uValue.length &lt; 6)&#123; //显示校验结果 span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,太短&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,可用&lt;/font&gt;"; return true; &#125; &#125; /* 密码校验 */ function checkPassword()&#123; //获取密码输入 var uPass = document.getElementById("password").value; var span = document.getElementById("span_password"); //对密码输入进行校验 if(uPass.length &lt; 6)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,太短&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,够用&lt;/font&gt;"; return true; &#125; &#125; /* 确认密码校验 * */ function checkRePassword()&#123; //获取密码输入 var uPass = document.getElementById("password").value; //获取确认密码输入 var uRePass = document.getElementById("repassword").value; var span = document.getElementById("span_repassword"); //对密码输入进行校验 if(uPass != uRePass)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,两次密码不一致&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = ""; return true; &#125; &#125; /* 校验邮箱 * */ function checkMail()&#123; var umail = document.getElementById("email").value; var flag = checkEmail(umail); var span = document.getElementById("span_email"); //对邮箱输入进行校验 if(flag)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,可用&lt;/font&gt;"; return true; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,邮箱格式貌似有问题&lt;/font&gt;"; return false; &#125; &#125; function checkForm()&#123; var flag = checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkRePassword() &amp;&amp; checkMail(); return flag; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="../01-自动轮播图片/图片自动轮播.html" onsubmit="return checkForm()" &gt; 用户名:&lt;input type="text" id="username" onfocus="showTips('span_username','用户名长度不能小于6')" onblur="checkUsername()" onkeyup="checkUsername()" /&gt;&lt;span id="span_username"&gt;&lt;/span&gt;&lt;br /&gt; 密码:&lt;input type="password" id="password" onfocus="showTips('span_password','密码长度不能小于6')" onblur="checkPassword()" onkeyup="checkPassword()"/&gt;&lt;span id="span_password"&gt;&lt;/span&gt;&lt;br /&gt; 确认密码:&lt;input type="password" id="repassword" onfocus="showTips('span_repassword','两次密码必须一致')" onblur="checkRePassword()" onkeyup="checkRePassword()" /&gt;&lt;span id="span_repassword"&gt;&lt;/span&gt;&lt;br /&gt; 邮箱:&lt;input type="text" id="email" onfocus="showTips('span_email','邮箱格式必须正确')" onblur="checkMail()" /&gt;&lt;span id="span_email"&gt;&lt;/span&gt;&lt;br /&gt; 手机号:&lt;input type="text" id="text" /&gt;&lt;br /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 定时器: setInterval(&quot;test()&quot;,3000) 每隔多少毫秒执行一次函数 setTimeout(&quot;test()&quot;,3000) 多少毫秒之后执行一次函数 timerID 上面定时器调用之后 clearInterval() clearTimeout() 切换图片 img.src = &quot;图片路径&quot; 事件: 文档加载完成的事件 onload事件 显示广告 : img.style.display = “block” 隐藏广告: img.style.display =”none” 引入一个外部js文件 1&lt;script src="js文件的路径" type="text/javascript"/&gt; 表单校验中常用的事件: 获得焦点事件: onfocus 失去焦点事件 onblur 按键抬起事件: onkeyup JS开发步骤 1231. 确定事件2. 事件要触发函数: 定义函数3. 函数通常都要去做一些交互: 点击, 修改图片, 动态修改innerHTML属性... innerTEXT 表格隔行换色实现步骤 确定事件: 文档加载完成 onload 事件要触发函数: init() 函数:操作页面的元素要操作表格中每一行动态的修改行的背景颜色 代码实现1234567891011121314151617&lt;script &gt; function init()&#123; //得到表格 var tab = document.getElementById("tab"); //得到表格中每一行 var rows = tab.rows; //便利所有的行,然后根据奇数 偶数 for(var i=1; i &lt; rows.length; i++)&#123; var row = rows[i]; //得到其中的某一行 if(i%2==0)&#123; row.bgColor = "yellow"; &#125;else&#123; row.bgColor = "red" &#125; &#125; &#125;&lt;/script&gt; 复选框的全选和全不选使用事件 : onclick点击事件 实现步骤全选和全不选步骤分析: 1.确定事件: onclick 单机事件2.事件触发函数: checkAll()3.函数要去做一些事情: 获得当前第一个checkbox的状态 获得所有分类项的checkbox 修改每一个checkbox的状态 代码实现123456789101112131415function checkAll()&#123;// 获得当前第一个checkbox的状态 var check1 = document.getElementById("check1"); //得到当前checked状态 var checked = check1.checked;// 获得所有分类项的checkbox// var checks = document.getElementsByTagName("input"); var checks = document.getElementsByName("checkone");// alert(checks.length); for(var i = 0; i &lt; checks.length; i++)&#123;// 修改每一个checkbox的状态 var checkone = checks[i]; checkone.checked = checked; &#125; &#125; DOM操作什么是DOM: Document Object Model : 管理我们的文档 增删改查规则 【HTML中的DOM操作】 12345678910111213141516171819202122232425262728293031一些常用的 HTML DOM 方法： getElementById(id) - 获取带有指定 id 的节点（元素） appendChild(node) - 插入新的子节点（元素） removeChild(node) - 删除子节点（元素） 一些常用的 HTML DOM 属性： innerHTML - 节点（元素）的文本值 parentNode - 节点（元素）的父节点 childNodes - 节点（元素）的子节点 attributes - 节点（元素）的属性节点 查找节点：getElementById() 返回带有指定 ID 的元素。 getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 增加节点：createAttribute() 创建属性节点。 createElement() 创建元素节点。 createTextNode() 创建文本节点。 insertBefore() 在指定的子节点前面插入新的子节点。 appendChild() 把新的子节点添加到指定节点。 删除节点：removeChild() 删除子节点。 replaceChild() 替换子节点。 修改节点：setAttribute() 修改属性setAttributeNode() 修改属性节点 简答的实例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 准备工作 : 准备数据 */ var provinces = [ ["深圳市","东莞市","惠州市","广州市"], ["长沙市","岳阳市","株洲市","湘潭市"], ["厦门市","福州市","漳州市","泉州市"] ]; /* 1. 确定事件: onchange 2. 函数: selectProvince() 3. 函数里面要搞事情了 得到当前操作元素 得到当前选中的是那一个省份 从数组中取出对应的城市信息 动态创建城市元素节点 添加到城市select中 */ function selectProvince()&#123; var province = document.getElementById("province"); //得到当前选中的是哪个省份 //alert(province.value); var value = province.value; //从数组中取出对应的城市信息 var cities = provinces[value]; var citySelect = document.getElementById("city"); //清空select中的option citySelect.options.length = 0; for (var i=0; i &lt; cities.length; i++) &#123;// alert(cities[i]); var cityText = cities[i]; //动态创建城市元素节点 &lt;option&gt;东莞市&lt;/option&gt; //创建option节点 var option1 = document.createElement("option"); // &lt;option&gt;&lt;/option&gt; //创建城市文本节点 var textNode = document.createTextNode(cityText) ;// 东莞市 //将option节点和文本内容关联起来 option1.appendChild(textNode); //&lt;option&gt;东莞市&lt;/option&gt; // 添加到城市select中 citySelect.appendChild(option1); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--选择省份--&gt; &lt;select onchange="selectProvince()" id="province"&gt; &lt;option value="-1"&gt;--请选择--&lt;/option&gt; &lt;option value="0"&gt;广东省&lt;/option&gt; &lt;option value="1"&gt;湖南省&lt;/option&gt; &lt;option value="2"&gt;福建省&lt;/option&gt; &lt;/select&gt; &lt;!--选择城市--&gt; &lt;select id="city"&gt;&lt;/select&gt; &lt;/body&gt;&lt;/html&gt; 使用JS控制下拉列表左右选择代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 步骤分析 1. 确定事件: 点击事件 :onclick事件 2. 事件要触发函数 selectOne 3. selectOne要做一些操作 (将左边选中的元素移动到右边的select中) 1. 获取左边Select中被选中的元素 2. 将选中的元素添加到右边的Select中就可以 --&gt; &lt;script&gt; function selectOne()&#123;// 1. 获取左边Select中被选中的元素 var leftSelect = document.getElementById("leftSelect"); var options = leftSelect.options; //找到右侧的Select var rightSelect = document.getElementById("rightSelect"); //遍历找出被选中的option for(var i=0; i &lt; options.length; i++)&#123; var option1 = options[i]; if(option1.selected)&#123; // 2. 将选中的元素添加到右边的Select中就可以 rightSelect.appendChild(option1); &#125; &#125; &#125; //将左边所有的商品移动到右边 function selectAll()&#123;// 1. 获取左边Select中被选中的元素 var leftSelect = document.getElementById("leftSelect"); var options = leftSelect.options; //找到右侧的Select var rightSelect = document.getElementById("rightSelect"); //遍历找出被选中的option for(var i=options.length - 1; i &gt;=0; i--)&#123; var option1 = options[i]; rightSelect.appendChild(option1); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1px" width="400px"&gt; &lt;tr&gt; &lt;td&gt;分类名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类描述&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="这里面都是手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类商品&lt;/td&gt; &lt;td&gt; &lt;!--左边--&gt; &lt;div style="float: left;"&gt; 已有商品&lt;br /&gt; &lt;select multiple="multiple" id="leftSelect" ondblclick="selectOne()"&gt; &lt;option&gt;华为&lt;/option&gt; &lt;option&gt;小米&lt;/option&gt; &lt;option&gt;锤子&lt;/option&gt; &lt;option&gt;oppo&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; &lt;a href="#" onclick="selectOne()"&gt; &amp;gt;&amp;gt; &lt;/a&gt; &lt;br /&gt; &lt;a href="#" onclick="selectAll()"&gt; &amp;gt;&amp;gt;&amp;gt; &lt;/a&gt; &lt;/div&gt; &lt;!--右边--&gt; &lt;div style="float: right;"&gt; 未有商品&lt;br /&gt; &lt;select multiple="multiple" id="rightSelect"&gt; &lt;option&gt;苹果6&lt;/option&gt; &lt;option&gt;肾7&lt;/option&gt; &lt;option&gt;诺基亚&lt;/option&gt; &lt;option&gt;波导&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; &lt;a href="#"&gt; &amp;lt;&amp;lt; &lt;/a&gt; &lt;br /&gt; &lt;a href="#"&gt; &amp;lt;&amp;lt;&amp;lt; &lt;/a&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="提交"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 知识点总结:定时器: setInterval setTimeout clearInterval clearTimeout 控制图片显示隐藏 img.style.display = &quot;block&quot; img.style.display = &quot;none&quot; 表单中常用的事件: onfocus: 获取焦点事件 onblur : 失去焦点的事件 onkeyup: 按键抬起的事件 onclick: 单击事件 ondblclick: 双击事件 表格隔行换色,鼠标移入和移除要变色: onmouseenter: 鼠标移入 onmouseout: 鼠标移出 onload: 文档加载完成事件 onsubmit: 提交 onchange: 下拉列表内容改变 checkbox.checked 选中状态 DOM的文档操作: 添加节点: appendChild 创建节点: document.createElement 创建文本节点: document.createTextNode() JS开发步骤: 1231. 确认事件2. 事件触发函数3. 函数里面要做一些交互]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS与简单的js基础知识学习]]></title>
    <url>%2F2018%2F08%2F15%2FCSS%2F</url>
    <content type="text"><![CDATA[CSS与简单的js基础知识学习学习了一段时间的后端的知识，在开发项目的时候对于前端慢慢的学看的也七七八八，现在就重新系统的学习下基础知识,也能减少查手册的时间。 CSS简单语法CSS的简单语法: 在一个style标签中,去编写CSS内容,最好将style标签写在这个head标签中 123456&lt;style&gt; 选择器&#123; 属性名称:属性的值; 属性名称2: 属性的值2; &#125;&lt;/style&gt; CSS选择器: 帮助我们找到我们要修饰的标签或者元素 元素选择: 1234元素的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; span&#123; color:blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; ID选择器: 12345以#号开头 ID在整个页面中必须是唯一的s#ID的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #div1&#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--请将JAVAEE颜色改成红色--&gt; &lt;div id=&quot;div1&quot;&gt;JAVAEE&lt;/div&gt; &lt;div&gt;IOS&lt;/div&gt; &lt;div&gt;ANDROID&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 类选择器: 12345以 . 开头 .类的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .shuiguo&#123; color: yellow; &#125; .shucai&#123; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;shuiguo&quot;&gt;香蕉&lt;/div&gt; &lt;div class=&quot;shucai&quot;&gt;黄瓜&lt;/div&gt; &lt;div class=&quot;shuiguo&quot;&gt;苹果&lt;/div&gt; &lt;div class=&quot;shucai&quot;&gt;茄子&lt;/div&gt; &lt;div class=&quot;shuiguo&quot;&gt;橘子&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 后代选择器 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; h1 &gt; em&#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; This is a &lt;em&gt;儿子&lt;/em&gt; &lt;strong&gt; &lt;em&gt;孙子&lt;/em&gt; &lt;/strong&gt; heading &lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; CSS的引入方式: ​ 外部样式: 通过link标签引入一个外部的css文件 ​ 内部样式: 直接在style标签内编写CSS代码 &lt;div class=&quot;shuiguo&quot; style=&quot;color:yellow&quot;&gt;香蕉&lt;/div&gt; ​ 行内样式: 直接在标签中添加一个style属性, 编写CSS样式 CSS浮动 : 浮动的元素会脱离正常的文档流,在正常的文档流中不占空间 123456789float属性: left rightclear属性: 清除浮动 both : 两边都不允许浮动 left: 左边不允许浮动 right : 右边不允许浮动流式布局 简单例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .logo&#123; float: left; width: 33%; /*border-width: 1px; border-style: solid; border-color: red;*/ height: 60px; line-height: 60px; /* border: 1px solid red;*/ &#125; .amenu&#123; color: white; text-decoration: none; height: 50px; line-height: 50px; &#125; .product&#123; float: left; text-align: center; width: 16%; height: 240px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 创一个最外层div 2. 第一部份: LOGO部分: 嵌套三个div 3. 第二部分: 导航栏部分 : 放置5个超链接 4. 第三部分: 轮播图 5. 第四部分: 6. 第五部分: 直接放一张图片 7. 第六部分: 抄第四部分的 8. 第七部分: 放置一张图片 9. 第八部分: 放一堆超链接 --&gt; &lt;div&gt; &lt;!--2. 第一部份: LOGO部分: 嵌套三个div--&gt; &lt;div&gt; &lt;div class="logo"&gt; &lt;img src="../img/logo2.png"/&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;img src="../img/header.png"/&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--清除浮动--&gt; &lt;div style="clear: both;"&gt;&lt;/div&gt; &lt;!--3. 第二部分: 导航栏部分 : 放置5个超链接--&gt; &lt;div style="background-color: black; height: 50px;"&gt; &lt;a href="#" class="amenu"&gt;首页&lt;/a&gt; &lt;a href="#" class="amenu"&gt;手机数码&lt;/a&gt; &lt;a href="#" class="amenu"&gt;电脑办公&lt;/a&gt; &lt;a href="#" class="amenu"&gt;鞋靴箱包&lt;/a&gt; &lt;a href="#" class="amenu"&gt;香烟酒水&lt;/a&gt; &lt;/div&gt; &lt;!--4. 第三部分: 轮播图--&gt; &lt;div&gt; &lt;img src="../img/1.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--5. 第四部分:--&gt; &lt;div&gt; &lt;div&gt;&lt;h2&gt;最新商品&lt;img src="../img/title2.jpg"/&gt;&lt;/h2&gt;&lt;/div&gt; &lt;!--左侧广告图--&gt; &lt;div style="width: 15%; height: 480px; float: left;"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%"/&gt; &lt;/div&gt; &lt;!-- 右侧商品 --&gt; &lt;div style="width: 84%; height: 480px;float: left;"&gt; &lt;div style="height: 240px; width: 50%; float: left;"&gt; &lt;img src="../products/hao/middle01.jpg" height="100%" width="100%" /&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--6. 第五部分: 直接放一张图片--&gt; &lt;div&gt; &lt;img src="../products/hao/ad.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--7. 第六部分: 抄第四部分的--&gt; &lt;div&gt; &lt;div&gt;&lt;h2&gt;最新商品&lt;img src="../img/title2.jpg"/&gt;&lt;/h2&gt;&lt;/div&gt; &lt;!--左侧广告图--&gt; &lt;div style="width: 15%; height: 480px; float: left;"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%"/&gt; &lt;/div&gt; &lt;!-- 右侧商品 --&gt; &lt;div style="width: 84%; height: 480px;float: left;"&gt; &lt;div style="height: 240px; width: 50%; float: left;"&gt; &lt;img src="../products/hao/middle01.jpg" height="100%" width="100%" /&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--8. 第七部分: 放置一张图片--&gt; &lt;div&gt; &lt;img src="../img/footer.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--9. 第八部分: 放一堆超链接--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="#"&gt;关于我们&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;a href="#"&gt;招贤纳士&lt;/a&gt; &lt;a href="#"&gt;法律声明&lt;/a&gt; &lt;a href="#"&gt;友情链接&lt;/a&gt; &lt;a href="#"&gt;支付方式&lt;/a&gt; &lt;a href="#"&gt;配送方式&lt;/a&gt; &lt;a href="#"&gt;服务声明&lt;/a&gt; &lt;a href="#"&gt;广告声明&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 扩展: CSS的优先级 按照选择器搜索精确度来编写:行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 就近原则: 哪个离得近,就选用哪个的样式 CSS: 层叠样式表 主要作用: 美化页面2. 将页面美化和HTML代码进行分离,提高代码的服用型 选择器: 元素选择器: 标签的名称{} 类选择器: 以. 开头 .类的名称 ID选择器: 以#开头 , #ID的名称 (ID必须是页面上面唯一) CSS浮动: float : left, right 不再占有正常文档流中的空间 , 流式布局 clear : both left right ​ CSS中的其它选择器 选择器分组: 选择器1,选择器2{ 属性的名称:属性的值} 属性选择器: 1234a[title]a[titile='aaa']a[href][title]a[href][title='aaa'] 后代选择器: 爷爷选择器 孙子选择器 找出所有的后代 子元素选择器: 父选择器 &gt; 儿子选择器 伪类选择器: 通常都是用在A标签上 使用DIV+CSS完成页面的优化CSS的盒子模型: 万物皆盒子 内边距: padding-top: padding-right: padding-bottom: padding-left: 1234padding:10px; 上下左右都是10pxpadding:10px 20px; 上下是10px 左右是20pxpadding: 10px 20px 30px; 上 10px 右20px 下30px 左20pxpadding: 10px 20px 30px 40px; 上右下左, 顺时针的方向 外边距: margin-top: margin-right: margin-bottom: margin-left: CSS绝对定位: ​ position: absolute ​ top: 控制距离顶部的位置 ​ left: 控制距离左边的位置 代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="../css/main.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 总共是5部分 2. 第一部分是LOGO部分 3. 第二部分是导航菜单 4. 第三部分是注册部分 5. 第四部分是FOOTER图片 6. 第五部分是一堆超链接 --&gt; &lt;div&gt; &lt;!--2. 第一部分是LOGO部分--&gt; &lt;div&gt; &lt;div class="logo"&gt; &lt;img src="../img/logo2.png" /&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;img src="../img/header.png" /&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--清除浮动--&gt; &lt;div style="clear: both;"&gt;&lt;/div&gt; &lt;!--3. 第二部分是导航菜单--&gt; &lt;div style="background-color: black; height: 50px;"&gt; &lt;a href="#" class="amenu"&gt;首页&lt;/a&gt; &lt;a href="#" class="amenu"&gt;手机数码&lt;/a&gt; &lt;a href="#" class="amenu"&gt;电脑办公&lt;/a&gt; &lt;a href="#" class="amenu"&gt;鞋靴箱包&lt;/a&gt; &lt;a href="#" class="amenu"&gt;香烟酒水&lt;/a&gt; &lt;/div&gt; &lt;!--4. 第三部分是注册部分--&gt; &lt;div style="background: url(../image/regist_bg.jpg);height: 500px;"&gt; &lt;div style="position:absolute;top:200px;left:350px;border: 5px solid darkgray;width: 50%;height: 50%;background-color: white;"&gt; &lt;table width="60%" align="center"&gt; &lt;tr&gt; &lt;td colspan="2"&gt;&lt;font color="blue" size="6"&gt;会员注册&lt;/font&gt;USER REGISTER&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type="password"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt;&lt;input type="password"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email:&lt;/td&gt; &lt;td&gt;&lt;input type="email"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt;&lt;input type="radio" name="sex"/&gt; 男 &lt;input type="radio" name="sex"/&gt; 女 &lt;input type="radio" name="sex"/&gt; 妖 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期:&lt;/td&gt; &lt;td&gt;&lt;input type="date"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="submit" value="注册"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--5. 第四部分是FOOTER图片--&gt; &lt;div&gt; &lt;img src="../img/footer.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--9. 第四部分: 放一堆超链接--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="#"&gt;关于我们&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;a href="#"&gt;招贤纳士&lt;/a&gt; &lt;a href="#"&gt;法律声明&lt;/a&gt; &lt;a href="#"&gt;友情链接&lt;/a&gt; &lt;a href="#"&gt;支付方式&lt;/a&gt; &lt;a href="#"&gt;配送方式&lt;/a&gt; &lt;a href="#"&gt;服务声明&lt;/a&gt; &lt;a href="#"&gt;广告声明&lt;/a&gt; &lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 上面用到的CSS部分的技术:​ CSS: 层叠样式表. ​ CSS作用: 美化页面,提高代码的复用性 ​ 选择器: ​ 需要掌握的: ​ 元素选择器: 标签的名称 ​ 类选择器: 以 . 开头 ​ ID选择器: 以#开头, #ID的名称 ID必须是唯一的 ​ 优先级: 按照选择精确度: 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 ​ 就近原则 ​ 扩展选择器: ​ 选择器分组: 选择器1,选择器2 以逗号隔开 ​ 后代选择器: 爷爷 孙子 中间以空格隔开 ​ 子元素选择器: 爸爸 &gt; 儿子 ​ 属性选择器: 选择器[属性的名称=’’] ​ 伪类选择器: 超链接标签上使用 ​ 浮动: float属性 left right ​ 清除浮动: clear: both left right ​ 盒子模型: 顺时针 : 上右下左 ​ padding : 内边距 ,控制的是盒子内容的距离 ​ margin : 外边距 控制盒子与盒子之间的距离 ​ 绝对定位: ​ position: absolute ​ top: ​ left:]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下重启网卡报错]]></title>
    <url>%2F2018%2F08%2F09%2FLinuxNetworkRestartError%2F</url>
    <content type="text"><![CDATA[重启网卡报Job for network.service failed because the control process exited with error code. 错误centos7下重启网卡 1systemctl restart network 然后报错 Job for network.service failed because the control process exited with error code. See “systemctl status network.service” and “journalctl -xe” for details. 解决方法： 执行 1systemctl stop NetworkManager 然后执行 1systemctl disable NetworkManager 然后重启网卡 1systemctl restart network 看一下网卡的状态 1ifconfig 如图：]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习之高并发接口优化]]></title>
    <url>%2F2018%2F08%2F09%2FSecurityOptimise%2F</url>
    <content type="text"><![CDATA[SpringBoot学习之高并发接口优化—–秒杀接口地址隐藏(验证码)+接口限流防刷秒杀接口地址隐藏思路：秒杀开始之前，先去请求接口获取秒杀地址。 123- 接口改造，带上PathVariable参数- 添加生成地址的接口- 秒杀收到请求，先验证PathVariable 随机生成一个字符串，作为地址加在url上，然后生成的时候，存入 redis缓存中，根据前端请求的url获取path。 判断与缓存中的字符串是否一致，一致就认为对的。就可以执行秒杀操作，否则失败。 对于秒杀接口，不是直接去请求秒杀的这个接口了， 而是先请求下获取path。之后拼接成秒杀地址。 前端代码： 1234567891011121314151617181920212223function getMiaoshaPath() &#123; goodsId:$("#goodsId").val(), g_showLoading(); $.ajax(&#123; url:"/miaosha/path", type:"GET", data:&#123; goodsId:$("#goodsId").val(), verifyCode:$("#verifyCode").val() &#125;, success:function (data) &#123; if(data.code == 0)&#123; var path = data.data; doMiaosha(path); &#125;else &#123; layer.msg(data.msg); &#125; &#125;, error:function() &#123; layer.msg("客户端请求错误"); &#125; &#125;);&#125; 对应的后端代码： 12345678910111213141516171819@AccessLimit(seconds = 5,maxCount = 5, needLogin = true)@RequestMapping(value = "/path",method = RequestMethod.GET)@ResponseBodypublic Result&lt;String&gt; getSecKillPath(HttpServletRequest request, SecKillUser user, @RequestParam("goodsId") long goodsId, @RequestParam(value = "verifyCode", defaultValue = "0") int verifyCode)&#123; if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; //验证码的校验 boolean check = secKillService.checkVerifyCode(user,goodsId,verifyCode); if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL); &#125; //生成path String path = secKillService.createSecKillPath(user,goodsId); return Result.success(path);&#125; 生成path，存入redis中 12345678public String createSecKillPath(SecKillUser user, Long goodsId) &#123; if (user == null || goodsId &lt;= 0)&#123; return null; &#125; String str = MD5Util.md5(UUIDUtil.uuid() + "123456"); redisService.set(SecKillKey.getPath,user.getId()+"_"+goodsId,str); return str; &#125; 秒杀接口，先拿到这个path验证一下是否正确，正确再进入下面的逻辑： 12345//验证pathboolean check = secKillService.checkPath(user,goodsId,path);if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL);&#125; 具体的验证，就是取出缓存中的path，与前端传来的path进行对比，相等，说明是这个用户发来的请求： 1234567891011121314/*** 验证秒杀接口参数* @param user* @param goodsId* @param path* @return*/public boolean checkPath(SecKillUser user, long goodsId, String path) &#123; if (user == null || path == null)&#123; return false; &#125; String pathOld = redisService.get(SecKillKey.getPath,""+user.getId()+"_"+goodsId,String.class); return path.equals(pathOld);&#125; 然后前端拼接出秒杀的地址 1234567891011121314151617181920function doMiaosha(path)&#123; $.ajax(&#123; url:"/miaosha/"+path+"/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val() &#125;, success:function(data)&#123; if(data.code == 0)&#123; // window.location.href="/order_detail.htm?orderId="+data.data.id; getMiaoShaResult($("#goodsId").val()); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 公式验证码思路：点击秒杀之前，先输入验证码，分散用户的请求 12 前端增加获取验证码显示验证码输入验证码上传。 1234567&lt;div class="row"&gt; &lt;div class="form-inline"&gt; &lt;img id="verifyCodeImg" width="80" height="32" style="display: none" onclick="refreshVerifyCode()"/&gt; &lt;input id="verifyCode" class="form-control" style="display: none"/&gt; &lt;button class="btn btn-primary" type="button" id="buyButton"onclick="getMiaoshaPath()"&gt;立即秒杀&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 增加返回验证码的接口 12345678910111213141516171819202122232425/** * 获取验证码 * @param response * @param user * @param goodsId * @return */ @RequestMapping(value = "/verifyCode",method = RequestMethod.GET) @ResponseBody public Result&lt;String&gt; getMiaoshaVerifyCode(HttpServletResponse response, SecKillUser user, @RequestParam("goodsId") long goodsId)&#123; if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; BufferedImage image = secKillService.createSecKillVerifyCode(user,goodsId); try&#123; OutputStream out = response.getOutputStream(); //输出流 ImageIO.write(image,"JPEG",out); //图片写入输出流 out.flush(); out.close(); return null; &#125;catch (Exception e)&#123; e.printStackTrace(); return Result.error(CodeMsg.SECKILL_FAILED); &#125; &#125; 在每次秒杀的时候，要先判断这个验证码是否正确 12345//验证码的校验boolean check = secKillService.checkVerifyCode(user,goodsId,verifyCode);if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL);&#125; 生成数字验证码并存入redis中，判断也是从redis中取出来判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public BufferedImage createSecKillVerifyCode(SecKillUser user, long goodsId) &#123; if (user == null || goodsId &lt;= 0)&#123; return null; &#125; int width = 80; int height = 32; //生成图片 BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = image.getGraphics(); // 背景 g.setColor(new Color(0xDCDCDC)); g.fillRect(0, 0, width, height); // 背景上生成矩形框 g.setColor(Color.black); g.drawRect(0, 0, width - 1, height - 1); // 随机数 Random rdm = new Random(); // 生成干扰点 for (int i = 0; i &lt; 50; i++) &#123; int x = rdm.nextInt(width); int y = rdm.nextInt(height); g.drawOval(x, y, 0, 0); &#125; // 生成验证码 String verifyCode = generateVerifyCode(rdm); g.setColor(new Color(0, 100, 0)); g.setFont(new Font("Candara", Font.BOLD, 24)); g.drawString(verifyCode, 8, 24); g.dispose(); //把验证码存到redis中 int rnd = calc(verifyCode); redisService.set(SecKillKey.getSecKillVerifyCode, user.getId()+","+goodsId, rnd); //输出图片 return image; &#125; private static char[] ops = new char[] &#123;'+', '-', '*'&#125;; /** * 生成验证码公式 * + - * * */ private String generateVerifyCode(Random rdm) &#123; int num1 = rdm.nextInt(10); int num2 = rdm.nextInt(10); int num3 = rdm.nextInt(10); char op1 = ops[rdm.nextInt(3)]; char op2 = ops[rdm.nextInt(3)]; String exp = ""+ num1 + op1 + num2 + op2 + num3; return exp; &#125; /** * Java ScriptEngine 解析js计算验证码 * @param exp 验证码 * @return */ private static int calc(String exp) &#123; try &#123; ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName("JavaScript"); return (Integer)engine.eval(exp); &#125;catch(Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; 前端在function getMiaoshaPath()这个函数中将结果传到后端，后端在这个获取真正秒杀链接的时候进行判断是否正确： 1verifyCode:$("#verifyCode").val() 后端接收验证码验证 123456789101112131415161718@AccessLimit(seconds = 5,maxCount = 5, needLogin = true) @RequestMapping(value = "/path",method = RequestMethod.GET) @ResponseBody public Result&lt;String&gt; getMiaoshaPath(HttpServletRequest request, SecKillUser user, @RequestParam("goodsId") long goodsId, @RequestParam(value = "verifyCode", defaultValue = "0") int verifyCode)&#123; if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; //验证码的校验 boolean check = secKillService.checkVerifyCode(user,goodsId,verifyCode); if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL); &#125; String path = secKillService.createSecKillPath(user,goodsId); return Result.success(path); &#125; redis中取出生成时存入的验证码并与前端传进来的验证码做校验 1234567891011121314151617181920/** * 验证码的验证 * @param user 用户 * @param goodsId 商品id * @param verifyCode 验证码 * @return */ public boolean checkVerifyCode(SecKillUser user, long goodsId, int verifyCode) &#123; if (user == null || goodsId &lt;= 0)&#123; return false; &#125; Integer codeOld = redisService.get(SecKillKey.getSecKillVerifyCode, user.getId()+&quot;,&quot;+goodsId, Integer.class); if (codeOld == null || codeOld - verifyCode != 0)&#123; return false; &#125; //把当前的验证码清除 redisService.delete(SecKillKey.getSecKillVerifyCode, user.getId()+&quot;,&quot;+goodsId); return true; &#125; 接口限流防刷思路：对接口做限流 可以使用拦截器减少对业务的侵入 点击秒杀之后，首先是生成path，那假如我们对这个接口进行限制：5秒之内用户只能点击5次。 这放在redis中是非常好实现的，因为redis有个自增(自减)和缓存时间，可以很好地实现这个效果。 这里使用注解的方式来实现接口的限流防刷，使用注解的话就可以做成通用的方法，在你想使用限流防刷的接口就可以添加上该注解 假设，我想在5秒内最多请求5次，并且必须要登陆：相应的注解就是这样的： 1@AccessLimit(seconds = 5,maxCount = 5,needLogin = true) 首先是实现这个注解： 12345678910111213141516171819package com.springboot.SecKill.access;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.METHOD;/** * 注解 * @author WilsonSong * @date 2018/8/9/009 */@Retention(RetentionPolicy.RUNTIME)@Target(METHOD)public @interface AccessLimit &#123; int seconds(); int maxCount(); boolean needLogin() default true;&#125; 要想这个注解能够生效，必须要配置拦截器AccessInterceptor： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.springboot.SecKill.access;import com.alibaba.fastjson.JSON;import com.springboot.SecKill.domain.SecKillUser;import com.springboot.SecKill.redis.AccessKey;import com.springboot.SecKill.redis.RedisService;import com.springboot.SecKill.result.CodeMsg;import com.springboot.SecKill.result.Result;import com.springboot.SecKill.service.SecKillUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.StringUtils;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.OutputStream;/** * 拦截器 * @author WilsonSong * @date 2018/8/9/009 */@Servicepublic class AccessInterceptor extends HandlerInterceptorAdapter&#123; @Autowired SecKillUserService secKillUserService; @Autowired RedisService redisService; //方法执行前执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if(handler instanceof HandlerMethod)&#123; SecKillUser user = getUser(request,response); UserContext.setUser(user); //把用户保存在本地线程变量中,并且该user与线程绑定一直执行到结束 HandlerMethod handlerMethod = (HandlerMethod)handler; AccessLimit accessLimit = handlerMethod.getMethodAnnotation(AccessLimit.class); //取方法上的注解 if (accessLimit == null)&#123; return true; &#125; int seconds = accessLimit.seconds(); int maxCount = accessLimit.maxCount(); boolean needLogin = accessLimit.needLogin(); String key = request.getRequestURI(); if (needLogin)&#123; if (user == null)&#123; render(response,CodeMsg.SESSION_ERROR); return false; &#125; key +="_" + user.getId(); &#125;else &#123; //da nothing &#125; //访问次数限制 访问次数存入内存 AccessKey accessKey = AccessKey.withExpires(seconds); Integer count = redisService.get(accessKey,key, Integer.class); if (count == null)&#123; redisService.set(accessKey,key, 1); &#125;else if (count &lt; maxCount)&#123; redisService.incr(accessKey,key); &#125;else &#123; render(response,CodeMsg.ACCESS_LIMIT_REACHED); return false; &#125; &#125; return true; &#125; /** * 返回客户端的错误信息 * @param response * @param cm * @throws Exception */ public void render(HttpServletResponse response,CodeMsg cm) throws Exception&#123; response.setContentType("application/json;charset=UTF-8"); //返回的数据的编码方式 OutputStream outputStream = response.getOutputStream(); String str = JSON.toJSONString(Result.error(cm)); outputStream.write(str.getBytes("UTF-8")); outputStream.flush(); outputStream.close(); &#125; /** * 通过cookie获取用户 * @param request * @param response * @return */ private SecKillUser getUser(HttpServletRequest request, HttpServletResponse response)&#123; String paramToken = request.getParameter(SecKillUserService.COOKIE_NAME_TOKEN); String cookieToken = getCookieValue(request,SecKillUserService.COOKIE_NAME_TOKEN); if (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken))&#123; return null; &#125; String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken; return secKillUserService.getByToken(response,token); &#125; /** * 获取cookie * @param request * @param cookieName * @return */ private String getCookieValue(HttpServletRequest request,String cookieName)&#123; Cookie[] cookies = request.getCookies(); if(cookies == null || cookies.length &lt;= 0)&#123; return null; &#125; for (Cookie cookie : cookies)&#123; if (cookie.getName().equals(cookieName))&#123; return cookie.getValue(); &#125; &#125; return null; &#125;&#125; 要想这个拦截器工作，我们要重写WebMvcConfigurerAdapter中的addInterceptors方法，将我们的拦截器添加进去就可以了： 123public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(accessInterceptor);&#125; 这样，利用注解和拦截器就实现了接口通用的限流功能。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>接口优化，秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习之秒杀接口优化]]></title>
    <url>%2F2018%2F08%2F08%2FAPIIOptimise%2F</url>
    <content type="text"><![CDATA[使用RabbitMQ改写秒杀功能实现思路思路：减少数据库访问 具体的实现流程就是 1234567891.系统初始化，把商品库存数量加载到Redis2.收到请求，Redis预减库存，库存不足，直接返回，否则33.请求入队，立即返回排队中4.请求出队，生成订单，减少库存5.客户端轮询，是否秒杀成功 其中4和5是同时并发处理的。 具体实现系统初始化，把商品库存数量加载到Redis如何在初始化的时候就将库存数据存入缓存中 通过实现InitializingBean接口中的一个方法:afterPropertiesSet() 系统初始化会首先调用该函数： 12345678910111213141516/** * 系统初始化会调用该函数 * @throws Exception */ @Override public void afterPropertiesSet() throws Exception &#123; List&lt;GoodsVo&gt; goodsVoList = goodsService.listGoodsVo(); if (goodsVoList == null)&#123; return; &#125; for (GoodsVo goodsVo:goodsVoList)&#123; //预先把商品库存加载到redis中 redisService.set(GoodsKey.getSeckillGoodsStock,""+goodsVo.getId(),goodsVo.getStockCount()); localOverMap.put(goodsVo.getId(),false); &#125; &#125; 收到请求，Redis预减库存，库存不足，直接返回，否则请求入队，立即返回排队中首先需要一个RabbitMQ的队列 使用Direct交换机模式 12345678/** * Direct 交换机模式 */ //队列 @Bean public Queue secKill_QUEUE() &#123; return new Queue(SECKILL_QUEUE,true); &#125; 队列消息的发送 123456public void sendSecKillMessage(SecKillMessage secKillMessage) &#123; String msg = RedisService.Bean2String(secKillMessage); logger.info(&quot;send SecKill message: &quot; + msg); amqpTemplate.convertAndSend(MQConfig.SECKILL_QUEUE, msg); &#125; 秒杀的实现 1234567891011121314151617//预先减库存long stock = redisService.decr(GoodsKey.getSeckillGoodsStock,""+goodsId);if (stock &lt; 0)&#123;localOverMap.put(goodsId,true);return Result.error(CodeMsg.SECKILL_OVER);&#125;//判断是否已经秒杀到了SecKillOrder order = orderService.getOrderByUserIdGoodsId(user.getId(),goodsId);if (order != null)&#123;return Result.error( CodeMsg.SECKILL_REPEATE);&#125;//压入RabbitMQ队列SecKillMessage secKillMessage = new SecKillMessage();secKillMessage.setUser(user);secKillMessage.setGoodsId(goodsId);mqSender.sendSecKillMessage(secKillMessage);return Result.success(0); //排队中 请求出队，生成订单，减少库存其实就是RabbitMQ的队列出队去处理相关的业务 1234567891011121314151617181920212223@RabbitListener(queues = MQConfig.SECKILL_QUEUE) public void receive(String message)&#123; logger.info("receive message" + message); SecKillMessage secKillMessage = RedisService.String2Bean(message,SecKillMessage.class); SecKillUser user = secKillMessage.getUser(); long goodsId = secKillMessage.getGoodsId(); //判断库存 GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId); int stock = goods.getStockCount(); if (stock &lt;= 0)&#123; return; &#125; //判断是否已经秒杀到了 SecKillOrder order = orderService.getOrderByUserIdGoodsId(user.getId(),goodsId); if (order != null)&#123; return; &#125; //减库存 下订单 写入秒杀订单 //订单的详细信息 OrderInfo orderInfo = secKillService.secKill(user, goods); &#125; 客户端轮询，是否秒杀成功123456789101112131415161718192021//秒杀的结果 /** * orderId:秒杀成功 * -1： 秒杀失败 * 0：排队中 * @param model * @param user * @param goodsId * @return */ @RequestMapping(value = "/result",method = RequestMethod.GET) @ResponseBody public Result&lt;Long&gt; miaoshaResult(Model model, SecKillUser user, @RequestParam("goodsId") long goodsId)&#123; model.addAttribute("user",user); if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; long result = secKillService.getSecKillResult(user.getId(),goodsId); return Result.success(result); &#125; secKillService.getSecKillResult(): 1234567891011121314151617181920212223//获取结果 /** * orderId :成功 * -1:失败 * 0： 排队中 * @param userId * @param goodsId * @return */ public long getSecKillResult(Long userId, long goodsId) &#123; SecKillOrder order = orderService.getOrderByUserIdGoodsId(userId,goodsId); if (order != null)&#123; return order.getOrderId(); &#125;else &#123; boolean isOver = getGoodsOver(goodsId); if (isOver)&#123; return -1; &#125;else &#123; return 0; &#125; &#125; &#125; 这里涉及到了redis的访问，就是redis中有商品的数量，通过该参数判断卖没卖完，当一次性来了多于商品数目的请求的时候，redis预减库存，减为负数，其实在这个时候在来商品购买请求的时候就不需要在访问redis了。因为商品已经卖完了，这个时候就做一个标记，先判断内存这个标记，如果库存已经小于0了，就不再访问redis，这样就减少了redis的访问次数。 没有订单有两种情况，卖完了失败，和排队中, 在上面的秒杀那做个标记。这个商品是否秒杀完了。存入redis中。 之后去判断是否存在这个key就知道是哪种情况,这样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//事务，原子性操作 @Transactional public OrderInfo secKill(SecKillUser user, GoodsVo goods) &#123; //减库存 下订单 写入秒杀订单 必须是同时完成的 boolean success = goodsService.reduceStock(goods); //减库存成功了才进行下订单 if (success) &#123; return orderService.createOrder(user, goods); &#125;else&#123; //说明商品秒杀完了。做一个标记 setGoodsOver(goods.getId()); return null; &#125; &#125; //获取结果 /** * orderId :成功 * -1:失败 * 0： 排队中 * @param userId * @param goodsId * @return */ public long getSecKillResult(Long userId, long goodsId) &#123; SecKillOrder order = orderService.getOrderByUserIdGoodsId(userId,goodsId); if (order != null)&#123; return order.getOrderId(); &#125;else &#123; boolean isOver = getGoodsOver(goodsId); if (isOver)&#123; return -1; &#125;else &#123; return 0; &#125; &#125; &#125; public void setGoodsOver(Long goodsId) &#123; redisService.set(SecKillKey.isGoodsOver,""+goodsId,true); &#125; public boolean getGoodsOver(Long goodsId) &#123; return redisService.exists(SecKillKey.isGoodsOver,""+goodsId); &#125;&#125; 相对应的前端的修改 原来的detail页面中秒杀事件函数： 12345678910111213141516171819function doMiaosha()&#123; $.ajax(&#123; url:"/miaosha/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; window.location.href="/order_detail.htm?orderId="+data.data.id; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 秒杀到商品就直接返回，现在后端改为消息队列，所以需要增加函数进行判断，必要时需要轮询： 12345if(data.code == 0)&#123; window.location.href="/order_detail.htm?orderId="+data.data.id;&#125;else&#123; layer.msg(data.msg);&#125; 所以将其改为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//其他的部分省略...if(data.code == 0)&#123; //window.location.href="/order_detail.htm?orderId="+data.data.id; //秒杀到商品的时候，这个时候不是直接返回成功，后端是进入消息队列，所以前端是轮询结果，显示排队中 getMiaoshaResult($("#goodsId").val());&#125;else&#123; layer.msg(data.msg);&#125;...function getMiaoshaResult(goodsId) &#123; g_showLoading(); $.ajax(&#123; url:"/miaosha/result", type:"GET", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; var result = data.data; //失败--- -1 if(result &lt;= 0)&#123; layer.msg("对不起，秒杀失败！"); &#125; //排队等待，轮询--- 0 else if(result == 0)&#123;//继续轮询 setTimeout(function () &#123; getMiaoshaResult(goodsId); &#125;,50); &#125; //成功---- 1 else &#123; layer.msg("恭喜你，秒杀成功，查看订单?",&#123;btn:["确定","取消"]&#125;, function () &#123; window.location.href="/order_detail.htm?orderId="+result; &#125;, function () &#123; layer.closeAll(); &#125; ); &#125; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 压测测试环境 1g + 4核 + 50000个请求]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之安装RabbitMQ（踩坑）及RabbitMQ原理和使用详解]]></title>
    <url>%2F2018%2F08%2F08%2FRabbitMQ%2F</url>
    <content type="text"><![CDATA[SpringBoot之安装RabbitMQ（踩坑）及RabbitMQ原理和使用详解安装RabbitMQ安装环境centos7 + RabbitMQ 3.7.7 + OTP 21.0 Source File 1.安装erlang: （1）.下载: http://www.erlang.org/downloads （2）.安装依赖yum install ncurses-devel （3）.解压tar xf otp_src_21.0.tar.gz （4）.安装目录./configure –prefix=/usr/local/erlang –without-javac （5）编译make （6）安装make install （7）验证安装是否成功 ​ cd /usr/local/erlang/bin/ 执行./erl 2.安装rabbitmq rabbitmq解压即可用 （1）解压xz -d rabbitmq-server-generic-unix-3.7.7.tar.xz tar xf rabbitmq-server-generic-unix-3.7.7.tar （2）安装依赖: 123yum install python -yyum install xmlto -yyum install python-simplejson -y （3）启动: cd rabbitmq/sbin/ ./rabbitmq-server 正常到这里就完成安装了，但是我的并没有，报错了 踩坑（报错四部曲）（1）启动报错啊 显示./rabbitmq-server:行85: erl: 未找到命令 解决办法执行 vim /etc/profile 在文件中添加: ERL_HOME=/usr/local/erlang export PATH=$PATH:$ERL_HOME/bin （2）再启动还报错 显示错误如下： 123456789101112Error description: init:do_boot/3 init:start_em/1 rabbit:start_it/1 line 450 rabbit:broker_start/0 line 324 rabbit_plugins:prepare_plugins/1 line 289 rabbit_plugins:ensure_dependencies/1 line 263throw:&#123;error,&#123;missing_dependencies,[crypto,ssl], [amqp10_client,cowboy,cowlib,rabbitmq_aws, rabbitmq_management, rabbitmq_management_agent,rabbitmq_shovel, rabbitmq_trust_store]&#125;&#125; 解决方法： 应该是缺少依赖，openssl的两个包 看一下自己的Linux下有没有 which openssl 我的里面是有的，显示 /usr/bin/openssl 看一下版本 openssl version 版本有点老，可能是这个原因。 重新安装spenssl https://www.openssl.org/source/ 安装的话就找个教程就完事了 （3）安装完再启动还报错 错误信息： 1/usr/local/openssl/bin/openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory 其实就是找不到libssl.so.1.1 可以做一个软连接 假如你的libssl.so.1.1 文件在/usr/local/openssl/lib/下面，可以这样做 ln -s /usr/local/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1 ln -s /usr/local/openssl/lib/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1 完成后看一下当前版本 openssl version 显示OpenSSL 1.1.0g 2 Nov 2017 然后重启一般就可以了 （4）还报错，和2一样的错误 然而我的还是还是不行，怎么办，重装erlang, 然后启动rabbitmq就好使了。 会看到log tail -f /usr/local/rabbitmq/var/log/rabbitmq/rabbit@localhost.log 看一下启动起来没有,一般是在5672端口启动的，可以看一下5672端口有没有在监听 netstat -nap | grep 5672 也可以执行 ps -ef | gerp rabbitmq 看RabbitMQ相关的服务有没有启动 关闭RabbitMQ ./rabbitmqctl stop 把rabbitmq-server 写到环境变量中 vim /etc/profile 在文件中写入 export PATH=$PATH:/usr/local/ruby/bin:/usr/local/erlang/bin:/usr/local/rabbitmq/sbin 怎么让RabbitMQ在后台运行: ./rabbitmq-server -detached RabbitMQ基本原理讲解基础概念的前面，我们先来整体构造一个结构图，这样会方便们更好地去理解RabbitMQ的基本原理。 通过上面这张应用相结合的结构图既能够清晰的看清楚整体的send Message到Receive Message的一个大致的流程。当然上面有很多名词都相比还没有介绍到，不要着急接下来我们就开始对其进行详细的讲解。 QueueQueue（队列）RabbitMQ的作用是存储消息，队列的特性是先进先出。上图可以清晰地看到Client A和Client B是生产者，生产者生产消息最终被送到RabbitMQ的内部对象Queue中去，而消费者则是从Queue队列中取出数据。可以简化成表示为： 生产者Send Message “A”被传送到Queue中，消费者发现消息队列Queue中有订阅的消息，就会将这条消息A读取出来进行一些列的业务操作。这里只是一个消费正对应一个队列Queue，也可以多个消费者订阅同一个队列Queue，当然这里就会将Queue里面的消息平分给其他的消费者，但是会存在一个一个问题就是如果每个消息的处理时间不同，就会导致某些消费者一直在忙碌中，而有的消费者处理完了消息后一直处于空闲状态，因为前面已经提及到了Queue会平分这些消息给相应的消费者。这里我们就可以使用prefetchCount来限制每次发送给消费者消息的个数。详情见下图所示： 这里的prefetchCount=1是指每次从Queue中发送一条消息来。等消费者处理完这条消息后Queue会再发送一条消息给消费者。 Exchange我们在开篇的时候就留了一个坑，就是那个应用结构图里面，消费者Client A和消费者Client B是如何知道我发送的消息是给Queue1还是给Queue2，有没有过这个问题，那么我们就来解开这个面纱，看看到底是个什么构造。首先明确一点就是生产者产生的消息并不是直接发送给消息队列Queue的，而是要经过Exchange（交换器），由Exchange再将消息路由到一个或多个Queue，当然这里还会对不符合路由规则的消息进行丢弃掉，这里指的是后续要谈到的Exchange Type。那么Exchange是怎样将消息准确的推送到对应的Queue的呢？那么这里的功劳最大的当属Binding，RabbitMQ是通过Binding将Exchange和Queue链接在一起，这样Exchange就知道如何将消息准确的推送到Queue中去。简单示意图如下所示： 在绑定（Binding）Exchange和Queue的同时，一般会指定一个Binding Key，生产者将消息发送给Exchange的时候，一般会产生一个Routing Key，当Routing Key和Binding Key对应上的时候，消息就会发送到对应的Queue中去。那么Exchange有四种类型，不同的类型有着不同的策略。也就是表明不同的类型将决定绑定的Queue不同，换言之就是说生产者发送了一个消息，Routing Key的规则是A，那么生产者会将Routing Key=A的消息推送到Exchange中，这时候Exchange中会有自己的规则，对应的规则去筛选生产者发来的消息，如果能够对应上Exchange的内部规则就将消息推送到对应的Queue中去。那么接下来就来详细讲解下Exchange里面类型。 Exchange Typefanout fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。 上图所示，生产者（P）生产消息1将消息1推送到Exchange，由于Exchange Type=fanout这时候会遵循fanout的规则将消息推送到所有与它绑定Queue，也就是图上的两个Queue最后两个消费者消费。 direct direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中 当生产者（P）发送消息时Rotuing key=booking时，这时候将消息传送给Exchange，Exchange获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的Queue，这时发现Queue1和Queue2都符合，就会将消息传送给这两个队列，如果我们以Rotuing key=create和Rotuing key=confirm发送消息时，这时消息只会被推送到Queue2队列中，其他Routing Key的消息将会被丢弃。 topic 前面提到的direct规则是严格意义上的匹配，换言之Routing Key必须与Binding Key相匹配的时候才将消息传送给Queue，那么topic这个规则就是模糊匹配，可以通过通配符满足一部分规则就可以传送。它的约定是： routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit” binding key与routing key一样也是句点号“. ”分隔的字符串 binding key中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个） 当生产者发送消息Routing Key=F.C.E的时候，这时候只满足Queue1，所以会被路由到Queue中，如果Routing Key=A.C.E这时候会被同是路由到Queue1和Queue2中，如果Routing Key=A.F.B时，这里只会发送一条消息到Queue2中。 headers headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。 总结成表格： 类型名称 类型描述 Fandout 把所有发送到该Exchange的消息路由到所有与它绑定的Queue中 Direct Routing Key==Binding Key Topic 模糊匹配 Headers Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 Binding所谓绑定就是将一个特定的 Exchange 和一个特定的 Queue 绑定起来。Exchange 和Queue的绑定可以是多对多的关系。 通信过程假设P1和C1注册了相同的Broker，Exchange和Queue。P1发送的消息最终会被C1消费。基本的通信流程大概如下所示： P1生产消息，发送给服务器端的Exchange Exchange收到消息，根据ROUTINKEY，将消息转发给匹配的Queue1 Queue1收到消息，将消息发送给订阅者C1 C1收到消息，发送ACK给队列确认收到消息 Queue1收到ACK，删除队列中缓存的此条消息 Consumer收到消息时需要显式的向rabbit broker发送basic.ack消息或者consumer订阅消息时设置auto_ack参数为true。在通信过程中，队列对ACK的处理有以下几种情况： 如果consumer接收了消息，发送ack,rabbitmq会删除队列中这个消息，发送另一条消息给consumer。 如果cosumer接受了消息, 但在发送ack之前断开连接，rabbitmq会认为这条消息没有被deliver,在consumer在次连接的时候，这条消息会被redeliver。 如果consumer接受了消息，但是程序中有bug,忘记了ack,rabbitmq不会重复发送消息。 rabbitmq2.0.0和之后的版本支持consumer reject某条（类）消息，可以通过设置requeue参数中的reject为true达到目地，那么rabbitmq将会把消息发送给下一个注册的consumer。 SpringBoot集成RabbitMQ(1)添加依赖 12345&lt;!--rabbitmq--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; (2)添加配置 1234567891011121314151617181920212223#rabbitmqspring.rabbitmq.host=192.168.78.133spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/#消费者数量#消费者队列的数量spring.rabbitmq.listener.simple.concurrency= 10spring.rabbitmq.listener.simple.max-concurrency= 10#消费者每次从队列获取的消息数量spring.rabbitmq.listener.simple.prefetch= 1#消费者自动启动spring.rabbitmq.listener.simple.auto-startup=true#消费失败，自动重新入队spring.rabbitmq.listener.simple.default-requeue-rejected= true#启用发送重试#队列的发送者，队列满了就重置spring.rabbitmq.template.retry.enabled=truespring.rabbitmq.template.retry.initial-interval=1000 spring.rabbitmq.template.retry.max-attempts=3spring.rabbitmq.template.retry.max-interval=10000spring.rabbitmq.template.retry.multiplier=1.0 配置去这里找： https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/ 每个配置的详细信息是什么： https://github.com/spring-projects/spring-boot/blob/v2.0.4.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java 配置完成之后，RabbitMQ有4种交换机模式，下面分别实现下。 4种交换机模式实现Direct、Topic、Fanout和Headers模式的实现如下： （1）初始化队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.springboot.SecKill.rabbitmq;import org.springframework.amqp.core.*;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.retry.annotation.Backoff;import java.util.HashMap;import java.util.Map;/** * rabbitMQ配置初始化 * @author WilsonSong * @date 2018/8/8 */@Configurationpublic class MQConfig &#123; public static final String QUEUE = "queue"; public static final String TOPIC_QUEUE1 = "topic.queue1"; public static final String TOPIC_QUEUE2 = "topic.queue2"; public static final String FANOUT_QUEUE1 = "fanout.queue1"; public static final String FANOUT_QUEUE2 = "fanout.queue2"; public static final String HEADERS_QUEUE = "headers.queue"; public static final String TOPIC_EXCHANGE = "topicExchange"; public static final String FANOUT_EXCHANGE = "fanoutExchange"; public static final String HEADERS_EXCHANGE = "headersExchange"; /** * Direct 交换机模式 */ //队列 @Bean public Queue queue() &#123; return new Queue(QUEUE,true); &#125; /** * Topic 交换机模式 */ @Bean public Queue topicQueue1()&#123; return new Queue(TOPIC_QUEUE1,true); &#125; @Bean public Queue topicQueue2()&#123; return new Queue(TOPIC_QUEUE2,true); &#125; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(TOPIC_EXCHANGE); &#125; /** * 绑定Exchange和queue */ @Bean public Binding topicBinding1()&#123; return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with("topic.key1"); &#125; @Bean public Binding topicBinding2()&#123; return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with("topic.#"); //# 通配符，代表多个单词 &#125; /** * Fanout模式 交换机Exchange */ @Bean public Queue fanoutQueue1()&#123; return new Queue(FANOUT_QUEUE1,true); &#125; @Bean public Queue fanoutQueue2()&#123; return new Queue(FANOUT_QUEUE2,true); &#125; @Bean public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(FANOUT_EXCHANGE); &#125; @Bean public Binding fanoutBinding1()&#123; return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange()); &#125; @Bean public Binding fanoutBinding2()&#123; return BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange()); &#125; /** * Header模式 交换机Exchange */ @Bean public HeadersExchange headersExchange()&#123; return new HeadersExchange(HEADERS_EXCHANGE); &#125; @Bean public Queue headersQueue()&#123; return new Queue(HEADERS_QUEUE,true); &#125; @Bean public Binding headersBinding()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("header1","value1"); map.put("header2","value2"); return BindingBuilder.bind(headersQueue()).to(headersExchange()).whereAll(map).match(); &#125;&#125; (2)消息发送者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.springboot.SecKill.rabbitmq;import com.springboot.SecKill.redis.RedisService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessageProperties;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * @author WilsonSong * @date 2018/8/8 */@Servicepublic class MQSender &#123; private static final Logger logger = LoggerFactory.getLogger(MQReceiver.class); @Autowired AmqpTemplate amqpTemplate; /** * Direct 交换机模式 */ //消息发送到队列 public void send(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send topic message: " + msg); amqpTemplate.convertAndSend(MQConfig.QUEUE, msg); &#125; /** * Topic 交换机模式 */ public void sendTopic(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send topic message: " + msg); amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE,"topic.key1",msg+"1"); amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE,"topic.key2",msg+"1"); &#125; /** * Fanout模式 交换机Exchange */ public void sendFanout(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send fanout message: " + msg); amqpTemplate.convertAndSend(MQConfig.FANOUT_EXCHANGE,"",msg+"1"); &#125; /** * Header模式 交换机Exchange *"header1","value1"要与队列初始化的时候一样 */ public void sendHeaders(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send headers message: " + msg); MessageProperties properties = new MessageProperties(); properties.setHeader("header1","value1"); properties.setHeader("header2","value2"); Message obj = new Message(msg.getBytes(),properties); amqpTemplate.convertAndSend(MQConfig.HEADERS_EXCHANGE,"",obj); &#125;&#125; (3)消息接收 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.springboot.SecKill.rabbitmq;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Service;/** * @author WilsonSong * @date 2018/8/8 */@Servicepublic class MQReceiver &#123; private static final Logger logger = LoggerFactory.getLogger(MQReceiver.class); /** * Direct 交换机模式 */ @RabbitListener(queues = MQConfig.QUEUE) public void receive(String message)&#123; logger.info("receive message" + message); &#125; /** * Topic 交换机模式 */ @RabbitListener(queues = MQConfig.TOPIC_QUEUE1) public void receiveTopic1(String message)&#123; logger.info("receive topic queue1 message: " + message); &#125; @RabbitListener(queues = MQConfig.TOPIC_QUEUE2) public void receiveTopic2(String message)&#123; logger.info("receive topic queue2 message: " + message); &#125; /** * Fanout模式 交换机Exchange */ @RabbitListener(queues = MQConfig.FANOUT_QUEUE1) public void receiveFanout1(String message)&#123; logger.info("receive fanout queue1 message: " + message); &#125; @RabbitListener(queues = MQConfig.FANOUT_QUEUE2) public void receiveFanout2(String message)&#123; logger.info("receive fanout queue2 message: " + message); &#125; /** * Header模式 交换机Exchange */ @RabbitListener(queues = MQConfig.HEADERS_QUEUE) public void receiveFanout2(byte[] message)&#123; logger.info("receive headers queue message: " + new String(message)); &#125;&#125; 启动程序，报错了 1Caused by: com.rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN. For details see the broker logfile. 其实就是拒绝我们访问啊，因为我们定义的时候就是默认的用户名和密码 12spring.rabbitmq.username=guestspring.rabbitmq.password=guest 为什么默认的是这俩？ 看一下rabbitMQ的变量定义就知道了: 123456789/** * Login user to authenticate to the broker. */ private String username = "guest"; /** * Login to authenticate against the broker. */ private String password = "guest"; 怎么改呢？ 官网这么说的 “guest” user can only connect via localhost By default, the guest user is prohibited from connecting to the broker remotely; it can only connect over a loopback interface (i.e. localhost). This applies both to AMQP 0-9-1 and to any other protocols enabled via plugins. Any other users you create will not (by default) be restricted in this way. The recommended way to address this in production systems is to create a new user or set of users with the permissions to access the necessary virtual hosts. This can be done using CLI tools, HTTP API or definitions import. This is configured via the loopback_users item in the configuration file. If you wish to allow the guest user to connect from a remote host, you should set the loopback_users configuration to none. A complete RabbitMQ config file which does this would look like: loopback_users = none Or, in the classic config file format (rabbitmq.config): [{rabbit, [{loopback_users, []}]}]. 其实第二种就是在usr/local/rabbitmq/etc/rabbitmq下新建rabbitmq.config文件，添加 [{rabbit, [{loopback_users, []}]}]. 重启rabbitmq在运行程序就可以了]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2踩坑之SpringWebContext方法过时]]></title>
    <url>%2F2018%2F08%2F05%2FSpringWebContext%2F</url>
    <content type="text"><![CDATA[SpringWebContext方法过时今天在做项目的时候，为了优化访问速度，应对高并发，想把页面信息全部获取出来存到redis缓存中，这样每次访问就不用客户端进行渲染了，速度能快不少。 想用thymeleafViewResolver.getTemplateEngine().process(&quot;goodslist.html&quot;,ctx);函数实现，里面有一个ctx参数，这个参数就是WebContext 然后定义这个变量 SpringWebContext ctx = new SpringWebContext（......） 哎，这个方法在SpringBoot1.X的时候还能有，在org.thymeleaf.spring4.context这个package下，在、SpringBoot2.X +thymeleaf3.0.9 中没有，想去找一下用什么来代替，直接去org.thymeleaf.spring4下面去找，没找到相同类型的，然后取找thymeleaf.spring5的API，还找不到，只能找到thymeleaf.spring4的API,。想想还要用，怎么办啊，总不能把版本切换了吧，那有些别的说不定也得改，自己写吧，自力更生艰苦奋斗。 找了之前的一个项目，然后找到了那里面的SpringWebContext是怎么写的，超过来就完了， 但是不行SpringWebContext继承的是org.thymeleaf.context下的WebContext方法，在SpringBoot2.0+thymeleaf3.0.9中定义成final类型的，不能继承，想想要不把库的代码改了，还是算了，再往上找，找到这个WebContext extends AbstractContext implements IWebContext，没有final，所以一层一层的找到之后，按照他的源码改了一下，自己重写了SpringWebContext方法，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.springboot.SecKill.util;import org.springframework.context.ApplicationContext;import org.thymeleaf.context.AbstractContext;import org.thymeleaf.context.IWebContext;import javax.servlet.ServletContext;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.Locale;import java.util.Map;import java.util.HashMap;import java.util.concurrent.ConcurrentHashMap;/** * @author WilsonSong * @date 2018/8/5 */public class SpringWebContextUtil extends AbstractContext implements IWebContext &#123; private final HttpServletRequest request; private final HttpServletResponse response; private final ServletContext servletContext; public static final String BEANS_VARIABLE_NAME = "beans"; private static final ConcurrentHashMap&lt;ApplicationContext, HashMap&lt;String, Object&gt;&gt; variableMapPrototypes = new ConcurrentHashMap(); private final ApplicationContext applicationContext; public SpringWebContextUtil(final HttpServletRequest request, final HttpServletResponse response, final ServletContext servletContext, final Locale locale, final Map&lt;String, Object&gt; variables, final ApplicationContext appctx)&#123; super(locale,addSpringSpecificVariables(variables, appctx)); this.request = request; this.response = response; this.servletContext = servletContext; this.applicationContext = appctx; &#125; private static Map&lt;String, Object&gt; addSpringSpecificVariables(Map&lt;String, ?&gt; variables, ApplicationContext appctx) &#123; HashMap&lt;String, Object&gt; variableMapPrototype = (HashMap)variableMapPrototypes.get(appctx); if (variableMapPrototype == null) &#123; variableMapPrototype = new HashMap(20, 1.0F); ContexBeans beans = new ContexBeans(appctx); variableMapPrototype.put("beans", beans); variableMapPrototypes.put(appctx, variableMapPrototype); &#125; Map newVariables; synchronized(variableMapPrototype) &#123; newVariables = (Map)variableMapPrototype.clone(); &#125; if (variables != null) &#123; newVariables.putAll(variables); &#125; return newVariables; &#125; public ApplicationContext getApplicationContext() &#123; return this.applicationContext; &#125; public HttpServletRequest getRequest() &#123; return this.request; &#125; public HttpSession getSession() &#123; return this.request.getSession(false); &#125; public HttpServletResponse getResponse() &#123; return this.response; &#125; public ServletContext getServletContext() &#123; return this.servletContext; &#125;&#125; 其中的ContexBeans是自己定义的，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.springboot.SecKill.util;/** * @author WilsonSong * @date 2018/8/5 */import java.util.Arrays;import java.util.Collection;import java.util.LinkedHashSet;import java.util.Map;import java.util.Set;import java.util.Map.Entry;import org.springframework.context.ApplicationContext;import org.thymeleaf.util.Validate;public class ContexBeans implements Map&lt;String, Object&gt; &#123; private final ApplicationContext ctx; public ContexBeans(ApplicationContext ctx) &#123; Validate.notNull(ctx, &quot;Application Context cannot be null&quot;); this.ctx = ctx; &#125; public boolean containsKey(Object key) &#123; Validate.notNull(key, &quot;Key cannot be null&quot;); return this.ctx.containsBean(key.toString()); &#125; public Object get(Object key) &#123; Validate.notNull(key, &quot;Key cannot be null&quot;); return this.ctx.getBean(key.toString()); &#125; public Set&lt;String&gt; keySet() &#123; return new LinkedHashSet(Arrays.asList(this.ctx.getBeanDefinitionNames())); &#125; public int size() &#123; return this.ctx.getBeanDefinitionCount(); &#125; public boolean isEmpty() &#123; return this.ctx.getBeanDefinitionCount() &lt;= 0; &#125; public boolean containsValue(Object value) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;containsValue\&quot; not supported in Beans object&quot;); &#125; public Object put(String key, Object value) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;put\&quot; not supported in Beans object&quot;); &#125; public void putAll(Map&lt;? extends String, ?&gt; m) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;putAll\&quot; not supported in Beans object&quot;); &#125; public Object remove(Object key) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;remove\&quot; not supported in Beans object&quot;); &#125; public void clear() &#123; throw new UnsupportedOperationException(&quot;Method \&quot;clear\&quot; not supported in Beans object&quot;); &#125; public Collection&lt;Object&gt; values() &#123; throw new UnsupportedOperationException(&quot;Method \&quot;values\&quot; not supported in Beans object&quot;); &#125; public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() &#123; throw new UnsupportedOperationException(&quot;Method \&quot;entrySet\&quot; not supported in Beans object&quot;); &#125;&#125; 这样就能用了。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2之秒杀页面优化及解决超卖问题]]></title>
    <url>%2F2018%2F08%2F05%2FSecKillPageOptimise%2F</url>
    <content type="text"><![CDATA[页面缓存+URL缓存+对象缓存页面缓存其实系统访问某个页面的时候，并不是直接使用系统渲染，而是先从缓存中获取找到数据之后就然后返回给客户端，要是没有找到就手动渲染这个模板，渲染完成之后再把数据返回给客户端，同时把数据缓存到redis中。 其实流程很简单：（1）取缓存 （2）手动渲染模板 （3）结果输出 关于手动渲染，官方的介绍是这么说的; If you use Thymeleaf, you also have a ThymeleafViewResolver named ‘thymeleafViewResolver’. It looks for resources by surrounding the view name with a prefix and suffix. The prefix is spring.thymeleaf.prefix, and the suffix is spring.thymeleaf.suffix. The values of the prefix and suffix default to ‘classpath:/templates/’ and ‘.html’, respectively. You can override ThymeleafViewResolver by providing a bean of the same name. 就是 Thymeleaf,的模板引擎的时候需要用ThymeleafViewResolver来实现资源的渲染，用的时候注入就可以了。 1234567891011121314151617181920212223/商品列表页 不返回页面，直接返回HTML的代码 @RequestMapping(value = "/to_list", produces = "text/html") @ResponseBody public String list(HttpServletRequest request, HttpServletResponse response, Model model, SecKillUser user)&#123; model.addAttribute("user",user); //查询商品列表 List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo(); model.addAttribute("goodsList", goodsList); //取缓存 String html = redisService.get(GoodsKey.getGoodsList,"",String.class); if (!StringUtils.isEmpty(html))&#123; return html; &#125; //缓存中没有数据的时候手动渲染 SpringWebContextUtil ctx = new SpringWebContextUtil(request, response, request.getServletContext(),request.getLocale(),model.asMap(),applicationContext); html = thymeleafViewResolver.getTemplateEngine().process("goodslist.html",ctx); if(!StringUtils.isEmpty(html))&#123; redisService.set(GoodsKey.getGoodsList,"",html); &#125; return html; &#125; 这里还踩到一个小坑，取页面信息的SpringWebContext在org.thymeleaf.spring5.context这个包下面已经没有了，被删除了;在org.thymeleaf.spring4.context下面是有的，自己重写了SpringWebContext这个类。为什么非要要重写，我单独写篇博客写一下，更清晰一些。 URL缓存其实说是URL缓存，真的是有点不太准确哈，其实和页面缓存是一样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@RequestMapping(value = "/to_detail/&#123;goodsId&#125;", produces = "text/html") @ResponseBody public String detail(HttpServletRequest request, HttpServletResponse response,Model model, SecKillUser user, @PathVariable("goodsId") long goodsId)&#123; model.addAttribute("user",user); //取缓存 String html = redisService.get(GoodsKey.getGoodsDetail,""+goodsId,String.class); if (!StringUtils.isEmpty(html))&#123; return html; &#125; //手动渲染 GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId); model.addAttribute("goods",goods); //秒杀的详细信息 long startAt = goods.getStartDate().getTime(); long endAt = goods.getEndDate().getTime(); long now = System.currentTimeMillis(); //当前的时间 int SecKillStatus = 0; int remainSeconds = 0; if (now &lt; startAt)&#123; //秒杀未开始 SecKillStatus = 0; remainSeconds = (int)((startAt - now)/1000); &#125;else if (now &gt; endAt)&#123; //秒杀结束 SecKillStatus = 2; remainSeconds = -1; &#125;else &#123; SecKillStatus = 1; remainSeconds = 0; &#125; model.addAttribute("miaoshaStatus",SecKillStatus); model.addAttribute("remainSeconds",remainSeconds); //缓存中没有数据的时候手动渲染 SpringWebContextUtil ctx = new SpringWebContextUtil(request, response, request.getServletContext(), request.getLocale(),model.asMap(),applicationContext); html = thymeleafViewResolver.getTemplateEngine().process("goods_detail.html",ctx); if(!StringUtils.isEmpty(html))&#123; redisService.set(GoodsKey.getGoodsDetail,""+goodsId ,html); &#125; return html;&#125; 对象缓存对象缓存其实就是把缓存数据和对象放在缓存中，这样每次访问的时候从缓存中读取就可以了，就相应的减少了读取数据库的次数，从而提高了网站访问的速度 。 上面的页面缓存是设置有有效期的，因为页面信息可能随时会变，一直在缓存中中就页面的信息每次读出来就不一样了，但是对象就不一样了，这个不设置有效期，或者把有效期设置的很长。 这里做个简单的例子，把做秒杀商品的用户对象放在内存中 1234567891011121314public SecKillUser getUserById(long id)&#123; //取缓存 SecKillUser user = redisService.get(SecKillUserKey.getById,""+id, SecKillUser.class); if (user !=null)&#123; return user; &#125; //缓存中没有从数据库中取出来放入缓存中 user = secKillUserDao.getUserById(id); if (user != null)&#123; redisService.set(SecKillUserKey.getById,""+id, user); &#125; return user; &#125; 因为设置缓存中的对象数据永不过期，那有人更新了自己的密码或者用户名或者其他的信息怎么办，缓存也要随着更新,要不然就缓存数据不一致了。 1234567891011121314151617public boolean updatePassword(String token,long id, String formPasswordNew)&#123; SecKillUser user = getUserById(id); if (user == null)&#123; throw new GlobalException(CodeMsg.MOBILE_NOT_EXITS); &#125; SecKillUser user2Update = new SecKillUser(); user2Update.setId(id); user2Update.setPassword(MD5Util.fromPass2DBPass(formPasswordNew,user.getSalt())); secKillUserDao.update(user2Update); //修改缓存 redisService.delete(SecKillUserKey.getById,""+id); //更新缓存中的token user.setPassword(user2Update.getPassword()); redisService.set(SecKillUserKey.token,token, user); return true; &#125; 做了部分优化，测试一下，测试的Linux服务器为1g+4核。 没有优化之前 优化之后 可以看到并发已经上去了，QPS从1267上升到2218了。 页面静态优化 前后端分离先想一下我们在平常的开发中前后端交互的流程：其实服务端为动态页面作用很单一就是提供了网站需要展示的数据而已，服务端是不会创造一个新页面的。服务端提供的数据的类型也是很统一，要不就是服务端语言提供的基本数据类型例如：字符、数字、日期等等，要不就是复杂点的数据类型例如数组、列表、键值对等等，不过归属服务端的动态页面还需要服务端语言帮助做一件事情，那就是把服务端提供的数据整合到页面里，最终产生一个浏览器可以解析的html网页，这个操作无非就是使用服务端语言可以构造文件的能力构建一个符合要求的html文件而已。不过一个页面里需要动态变化的往往只是其中一部分，所以做服务端的动态页面开发时候我们可以直接写html代码，这些html代码就等于在构造页面展示的模板而已，而模板的空白处则是使用服务端数据填充，因此在java的web开发里视图层技术延生出了Thymeleaf，freemark这样的技术，我们将其称之为模板语言的由来。 由此可见，服务端MVC框架里抢夺的web前端的工作就是抢占了构建html模板的工作，那么我们在设计web前端的MVC框架时候对于和服务端对接这块只需要让服务端保持提供数据的特性即可。从这些论述里我们发现了，其实前端MVC框架要解决的核心问题应该有这两个,它们分别是： 核心问题一：让模板技术交由浏览器来做，让服务端只提供单纯的数据服务。 核心问题二：模板技术交由浏览器来承担，那么页面的动态性体现也就是根据不同的服务端数据进行页面部分刷新来完成的。 而这两个核心问题解决办法那就是使用ajax技术，ajax技术天生就符合解决这些问题的技术手段了。 简答来讲就是其实就是将页面缓存到客户的浏览器上，当用户访问页面的时候，仅从与服务器取数据，从本地缓存中取页面，节省网络流量。 12345678910111213141516171819202122232425262728293031//商品详情页 @RequestMapping(value="/detail/&#123;goodsId&#125;") @ResponseBody public Result&lt;GoodsDetailVo&gt; detail(HttpServletRequest request, HttpServletResponse response, Model model, SecKillUser user, @PathVariable("goodsId") long goodsId)&#123; GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId); //秒杀的详细信息 long startAt = goods.getStartDate().getTime(); long endAt = goods.getEndDate().getTime(); long now = System.currentTimeMillis(); //当前的时间 int secKillStatus = 0; int remainSeconds = 0; if (now &lt; startAt)&#123; //秒杀未开始 secKillStatus = 0; remainSeconds = (int)((startAt - now)/1000); &#125;else if (now &gt; endAt)&#123; //秒杀结束 secKillStatus = 2; remainSeconds = -1; &#125;else &#123; secKillStatus = 1; remainSeconds = 0; &#125; GoodsDetailVo vo = new GoodsDetailVo(); vo.setRemainSeconds(remainSeconds); vo.setSecKillStatus(secKillStatus); vo.setGoods(goods); vo.setUser(user); return Result.success(vo); &#125; 之前我们是把数据通过model.addAttributes()传递给页面的，然后返回的是HTML页面，这里直接就是@ResponseBody，返回的是页面上需要的一些数据，不需要整合把数据整合到页面中。 对应的前端HTML的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;!DOCTYPE HTML&gt;&lt;html &gt;&lt;head&gt; &lt;title&gt;商品详情&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;!-- jquery --&gt; &lt;script type="text/javascript" src="./js/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- bootstrap --&gt; &lt;link rel="stylesheet" type="text/css" href="./bootstrap/css/bootstrap.min.css" /&gt; &lt;script type="text/javascript" src="./bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;!-- jquery-validator --&gt; &lt;script type="text/javascript" src="./jquery-validation/jquery.validate.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./jquery-validation/localization/messages_zh.min.js"&gt;&lt;/script&gt; &lt;!-- layer --&gt; &lt;script type="text/javascript" src="./layer/layer.js"&gt;&lt;/script&gt; &lt;!-- md5.js --&gt; &lt;script type="text/javascript" src="./js/md5.min.js"&gt;&lt;/script&gt; &lt;!-- common.js --&gt; &lt;script type="text/javascript" src="./js/common.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;秒杀商品详情&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;span id="userTip"&gt; 您还没有登录，请登陆后再操作&lt;br/&gt;&lt;/span&gt; &lt;span&gt;没有收货地址的提示。。。&lt;/span&gt; &lt;/div&gt; &lt;table class="table" id="goodslist"&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td colspan="3" id="goodsName"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td colspan="3"&gt;&lt;img id="goodsImg" width="200" height="200" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;秒杀开始时间&lt;/td&gt; &lt;td id="startTime"&gt;&lt;/td&gt; &lt;td &gt; &lt;input type="hidden" id="remainSeconds" /&gt; &lt;span id="miaoshaTip"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;button class="btn btn-primary btn-block" type="button" id="buyButton"onclick="doMiaosha()"&gt;立即秒杀&lt;/button&gt; &lt;input type="hidden" name="goodsId" id="goodsId" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品原价&lt;/td&gt; &lt;td colspan="3" id="goodsPrice"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;秒杀价&lt;/td&gt; &lt;td colspan="3" id="miaoshaPrice"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;库存数量&lt;/td&gt; &lt;td colspan="3" id="stockCount"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;function doMiaosha()&#123; $.ajax(&#123; url:"/miaosha/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; window.location.href="/order_detail.htm?orderId="+data.data.id; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125;function render(detail)&#123; var miaoshaStatus = detail.secKillStatus; var remainSeconds = detail.remainSeconds; var goods = detail.goods; var user = detail.user; if(user)&#123; $("#userTip").hide(); &#125; $("#goodsName").text(goods.goodsName); $("#goodsImg").attr("src", goods.goodsImg); $("#startTime").text(new Date(goods.startDate).format("yyyy-MM-dd hh:mm:ss")); $("#remainSeconds").val(remainSeconds); $("#goodsId").val(goods.id); $("#goodsPrice").text(goods.goodsPrice); $("#miaoshaPrice").text(goods.miaoshaPrice); $("#stockCount").text(goods.stockCount); countDown();&#125;$(function()&#123; //countDown(); getDetail();&#125;);function getDetail()&#123; var goodsId = g_getQueryString("goodsId"); $.ajax(&#123; url:"/goods/detail/"+goodsId, type:"GET", success:function(data)&#123; if(data.code == 0)&#123; render(data.data); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125;function countDown()&#123; var remainSeconds = $("#remainSeconds").val(); var timeout; if(remainSeconds &gt; 0)&#123;//秒杀还没开始，倒计时 $("#buyButton").attr("disabled", true); $("#miaoshaTip").html("秒杀倒计时："+remainSeconds+"秒"); timeout = setTimeout(function()&#123; $("#countDown").text(remainSeconds - 1); $("#remainSeconds").val(remainSeconds - 1); countDown(); &#125;,1000); &#125;else if(remainSeconds == 0)&#123;//秒杀进行中 $("#buyButton").attr("disabled", false); if(timeout)&#123; clearTimeout(timeout); &#125; $("#miaoshaTip").html("秒杀进行中"); &#125;else&#123;//秒杀已经结束 $("#buyButton").attr("disabled", true); $("#miaoshaTip").html("秒杀已经结束"); &#125;&#125;&lt;/script&gt;&lt;/html&gt; 可以看到这里把html中的原来的依赖于Thymeleaf的部分全部重写，直接从浏览器的缓存中取数据，填充页面。其实还需要做一个配置，就是把application.properties中添加上spring对于静态资源的配置，就是SPRING RESOURCES HANDLING的配置 12345678#staticspring.resources.add-mappings=truespring.resources.chain.cache=truespring.resources.cache.period=3600spring.resources.chain.enabled=truespring.resources.chain.gzipped=truespring.resources.chain.html-application-cache=truespring.resources.static-locations=classpath:/static/ 这样就完成了前后端的分离。 静态资源优化代码压缩 最常规的优化手段之一。 我们在平时开发的时候，JS脚本文件和CSS样式文件中的代码，都会依据一定的代码规范（比如javascript-standard-style）来提高项目的可维护性，以及团队之间合作的效率。 但是在项目发布现网后， 这些代码是给客户端（浏览器）识别的，此时代码的命名规范、空格缩进都已没有必要，我们可以使用工具将这些代码进行混淆和压缩，减少静态文件的大小 文件合并 在npm流行的今天，前端在进行项目开发的时候，往往会使用很多第三方代码库，比如jQuery，axios，weixin-js-sdk，lodash，bootstrap等等，每个库都有属于自己的脚本或者样式文件。 按照最老的方式的话，我们会用一些标签分别引入这些库文件，导致在打开一个页面的时候会发起几十个请求，这对于移动端来说是不可接受的。在减少文件请求数量方面大致有以下三方面：1、合并js脚本文件2、合并css样式文件3、合并css引用的图片，使用sprite雪碧图。 GZip 开启GZip，精简JavaScript，移除重复脚本，图像优化 CDN优化 简介：CDN（内容发布网络）,是一个加速用户获取数据的系统；既可以是静态资源，又可以是动态资源，这取决于我们的决策策略。经常大部分视频加速都依赖于CDN，比如优酷，爱奇艺等，据此加速； 原理：CDN部署在距离用户最近的网络节点上，用户上网的时候通过网络运营商（电信，长城等）访问距离用户最近的要给城域网网络地址节点上，然后通过城域网跳到主干网上，主干网则根据访问IP找到访问资源所在服务器，但是，很大一部分内容在上一层节点已经找到，此时不用往下继续查找，直接返回所访问的资源即可，减小了服务器的负担。一般互联网公司都会建立自己的CDN机群或者租用CDN。 这些就了解下原理，毕竟大部分是前端的。 关于这个还找到了一篇博客啊，仅供参考。 https://blog.csdn.net/zhangjs712/article/details/51166748 超卖问题超发的原因假设某个抢购场景中，我们一共只有100个商品，在最后一刻，我们已经消耗了99个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。（同文章前面说的场景） 在上面的这个图中，就导致了并发用户B也“抢购成功”，多让一个人获得了商品。这种场景，在高并发的情况下非常容易出现。 1.数据库唯一索引 就是分表，秒杀的订单和正常的订单是两张表，在数据库中建立用户id和商品id的唯一索引，防止用户插入重复的记录。 2. 悲观锁思路 解决线程安全的思路很多，可以从“悲观锁”的方向开始讨论。 悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。 虽然上述的方案的确解决了线程安全的问题，但是，别忘记，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。 3. FIFO队列思路 那好，那么我们稍微修改一下上面的场景，我们直接将请求放入队列中的，采用FIFO（First Input First Output，先进先出），这样的话，我们就不会导致某些请求永远获取不到锁。看到这里，是不是有点强行将多线程变成单线程的感觉哈。 然后，我们现在解决了锁的问题，全部请求采用“先进先出”的队列方式来处理。那么新的问题来了，高并发的场景下，因为请求很多，很可能一瞬间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时候还是会大幅下降，系统还是陷入异常。 4. 乐观锁思路 这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。 有很多软件和服务都“乐观锁”功能的支持，例如Redis中的watch就是其中之一。通过这个实现，我们保证了数据的安全。 就是采用计数器的方式，用一个集合，存放每个商品以及其对应的数量，如果只是单纯的decr函数或者是incr函数，不能解决秒杀这种问题。因为有可能在并发的情况下，两个请求取到的数都是0，然后都加1，结果为1，实际上应该是2。那么这个时候建议利用乐观锁，实现自己的decr函数。 乐观锁的机制如同版本控制，如果修改的时候，要修改的value在redis中的值已经跟取出来时不一样，则修改失败。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>秒杀， 页面优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习之Windows和Linux下的JMeter压测和redis压测]]></title>
    <url>%2F2018%2F08%2F04%2FJMeter%2F</url>
    <content type="text"><![CDATA[SpringBoot学习之JMeter压测JMeter入门jmeter是apache公司基于java开发的一款开源压力测试工具，体积小，功能全，使用方便，是一个比较轻量级的测试工具，使用起来非常简单。因为jmeter是java开发的，所以运行的时候必须先要安装jdk才可以。jmeter是免安装的，拿到安装包之后直接解压就可以使用，同时它在linux/windows/macos上都可以使用。 jmeter可以做接口测试和压力测试。其中接口测试的简单操作包括做http脚本（发get/post请求、加cookie、加header、加权限认证、上传文件）、做webservice脚本、参数化、断言、关联（正则表达式提取器和处理json-json path extractor）和jmeter操作数据库等等。JMeter的官方网站：http://jmeter.apache.org/JMeter的参考手册：http://jmeter.apache.org/usermanual/get-started.html具体的使用参考官网就可以了。## Windows下的压测### Jmeter-http接口脚本一般分五个步骤:（1）添加线程组 （2）添加http请求 （3）在http请求中写入接入url、路径、请求方式和参数 （4）添加聚合报告 （5）调用接口、查看返回值（1）添加线程组：（2）添加http请求：（3）在http请求中写入接入url、路径、请求方式和参数 ：（4）添加聚合报告和图形结果或查看结果树：聚合报告只是总体的进行解析压测结果。（5）调用接口、查看返回值：同时启动1000个线程:### JMeter 自定义变量新建http请求，添加token:压测之后能够看到自己添加的token，还能看到返回的数据## JMeter读取自定义文件模拟多用户需要在线程组里面添加配置元件-CSV Data Set Config，添加文件和自定义文件中对应的变量名其中遇到文件结束符再次循环（Recycle on EOF）:设置True后，允许循环取值引入${userToken}，与你定义的变量名相同。## Linux下使用JMeter压测首先在Windows下创建一个压测，然后存为.jmx文件。上传至Linux下执行1./apache-jmeter-4.0/bin/jmeter.sh -n -t goods_list.jmx -l result.jtl 这样就可以得到 result.jtl数据了，可以查看结果 当然也可以直接在Linux下直接测试，我这是为了方便就这么做了。 redis 压测看一下redis服务是否在运行 12ps -ef | grep redis 执行： 1redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000 -c 100 就是100个并发 -n 100000 就是100000个请求。 看一下其中的一个结果 100000个请求在2.38s内完成，有4.12%的请求在1ms内完成，一秒大概完成41963.91个请求。以3字节大小测试。 再看这条命令： 1redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100 -q 就是quiet，输出少一些，-d 100是存取数据包为100字节大小的数据包，上面默认是3 字节存取的。看一下输出 只测试某些命令的性能 1redis-benchmark -t set,lpush -q -n 10000 -t set,lpush 是只测试set和lpush命令。 只测试某些数据存取的性能： 1redis-benchmark -q -n 10000 script load &quot;redis.call(&apos;set&apos;,&apos;foo&apos;,&apos;bar&apos;)&quot; 只对’set’,’foo’,’bar’该命令做压测。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用JSR303参数校验并进行全局异常处理]]></title>
    <url>%2F2018%2F08%2F02%2FJSR303%2F</url>
    <content type="text"><![CDATA[SpringBoot使用JSR303参数校验开发web项目有时候我们需要对controller层传过来的参数进行一些基本的校验，比如非空，非null，整数值的范围，字符串的个数，日期，邮箱等等。最常见的就是我们直接写代码校验，这样以后比较繁琐，而且不够灵活。 不能总是写繁琐的代码来实现吧。 使用JSR303来做参数校验就方便并且整洁很多了。 pop引入依赖12345&lt;!--JSR303校验的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; Controller中使用12345@RequestMapping("/login")//@Valid是JSR303校验public Result&lt;Boolean&gt; login(@Valid LoginVo loginVo)&#123; &#125; 校验实体123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.springboot.SecKill.vo;import com.springboot.SecKill.validator.IsMobile;import org.hibernate.validator.constraints.Length;import javax.validation.constraints.NotNull;/** * @author WilsonSong * @date 2018/8/2/002 */public class LoginVo &#123; @NotNull @IsMobile private String mobile; @NotNull @Length(min=32) private String password; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "LoginVo&#123;" + "mobile='" + mobile + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 自定义校验JSR303中给我们定义了一些常用的校验注解，如本文最后常用常用注解中所示，但是要是还不能满足学习怎么去自己定义注解呢？ 参照@NotNull这个校验注解的定义方法，@NotNull是这么定义的 12345678910111213141516171819202122232425262728293031323334353637//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package javax.validation.constraints;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import javax.validation.Constraint;import javax.validation.Payload;@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)@Repeatable(NotNull.List.class)@Documented@Constraint( validatedBy = &#123;&#125;)public @interface NotNull &#123; String message() default "&#123;javax.validation.constraints.NotNull.message&#125;"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; @Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface List &#123; NotNull[] value(); &#125;&#125; 参照上面，我们实现自己的注解 12345678910111213141516171819202122232425262728package com.springboot.SecKill.validator;import javax.validation.Constraint;import javax.validation.Payload;import java.lang.annotation.*;/** * @author WilsonSong * @date 2018/8/2/002 */@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint( validatedBy = &#123;IsMobileValidator.class&#125;)public @interface IsMobile &#123; boolean required() default true; //校验不通过，提示默认的错误信息 String message() default "手机号码格式错误"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 实现具体校验器上面只是实现了自己定义的校验器的接口，具体的实现类如下： 123456789101112131415161718192021222324252627282930313233343536package com.springboot.SecKill.validator;import com.springboot.SecKill.util.ValidatorUtil;import org.springframework.util.StringUtils;import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;/** * JSR303具体的校验器 * @author WilsonSong * @date 2018/8/2/002 */public class IsMobileValidator implements ConstraintValidator&lt;IsMobile, String&gt; &#123; public boolean required = false; //初始化 @Override public void initialize(IsMobile constraintAnnotation) &#123; required = constraintAnnotation.required(); &#125; //校验 @Override public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) &#123; if(required)&#123; //值是必须的就判断是否合法 return ValidatorUtil.isMobile(s); //不为空就判断格式 &#125;else &#123; //若不必须就判断是否有值 if (StringUtils.isEmpty(s))&#123; return true; &#125;else &#123; return ValidatorUtil.isMobile(s); //不为空就判断格式 &#125; &#125; &#125;&#125; 异常处理参数校验不通过就会产生错误信息，显示一大串例如 1&#123;"timestamp":"2018-08-02T13:07:50.890+0000","status":400,"error":"Bad Request","errors":[&#123;"codes":["IsMobile.loginVo.mobile","IsMobile.mobile","IsMobile.java.lang.String","IsMobile"],"arguments":[&#123;"codes":["loginVo.mobile","mobile"],"arguments":null,"defaultMessage":"mobile","code":"mobile"&#125;,true],"defaultMessage":"手机号码格式错误","objectName":"loginVo","field":"mobile","rejectedValue":"22111111111","bindingFailure":false,"code":"IsMobile"&#125;],"message":"Validation failed for object='loginVo'. Error count: 1","path":"/login/do_login"&#125; 为了方便查看，统一进行异常处理 1234567891011121314151617181920212223242526272829303132333435363738package com.springboot.SecKill.exception;import com.springboot.SecKill.result.CodeMsg;import com.springboot.SecKill.result.Result;import org.springframework.validation.ObjectError;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import org.springframework.validation.BindException;import java.util.List;/** * @author WilsonSong * @date 2018/8/2/002 */@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = Exception.class) //拦截所有的异常 public Result&lt;String&gt; exceptionHandler(HttpServletRequest httpServletRequest, Exception e)&#123; // 参数校验异常 if(e instanceof BindException)&#123; BindException ex = (BindException)e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); ObjectError error= errors.get(0); String msg = error.getDefaultMessage(); return Result.error(CodeMsg.BIND_ERROR.fillArgs(msg)); &#125;else &#123; //其他异常 return Result.error(CodeMsg.SERVER_ERROR); &#125; &#125;&#125; 全局的异常处理上面的知识参数检验时候的异常处理，但是在工程中很多的异常，用全局的异常处理更加方便维护。 首先定义一个全局的异常 1234567891011121314151617181920212223242526272829303132package com.springboot.SecKill.exception;import com.springboot.SecKill.result.CodeMsg;/** * @author WilsonSong * @date 2018/8/2/002 */public class GlobalException extends RuntimeException &#123; private static final long serialVersionUID = 1L; private CodeMsg cm; public GlobalException (CodeMsg cm)&#123; super(cm.toString()); this.cm = cm; &#125; public static long getSerialVersionUID() &#123; return serialVersionUID; &#125; public CodeMsg getCm() &#123; return cm; &#125; public void setCm(CodeMsg cm) &#123; this.cm = cm; &#125;&#125; 然后在全局异常处理器中添加这个全局的异常，也就是在GlobalExceptionHandler类中添加 1234if(e instanceof GlobalException)&#123; GlobalException ex = (GlobalException) e; return Result.error(ex.getCm()); &#125; 然后在产生异常的地方直接抛出全局异常就可以了 123if (loginVo == null)&#123; throw new GlobalException(CodeMsg.SERVER_ERROR); &#125; CodeMsg.SERVER_ERROR是自己定义的异常信息。 常用注解1234567891011121314151617@Null 被注释的元素必须为null@NotNull 被注释的元素不能为null@AssertTrue 被注释的元素必须为true@AssertFalse 被注释的元素必须为false@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max,min) 被注释的元素的大小必须在指定的范围内。@Digits(integer,fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Pattern(value) 被注释的元素必须符合指定的正则表达式。@Email 被注释的元素必须是电子邮件地址@Length 被注释的字符串的大小必须在指定的范围内@NotEmpty 被注释的字符串必须非空@Range 被注释的元素必须在合适的范围内]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JSR303</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.0集成Redis详解及踩过的坑（Could not get a resource from the pool）]]></title>
    <url>%2F2018%2F08%2F02%2FRedis%2F</url>
    <content type="text"><![CDATA[SpringBoot2.0集成Redis首先安装的过程就不提了。上一个项目的redis是配置在Windows下的，集成很简单，也没有做什么配置。这次为了进行测试，装在了linux下。在SpringBoot集成的过程中遇到了一些小坑，分享一下。 pom文件中添加依赖12345678910111213&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入Json依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; 可以看到除了Redis我还加入了JSON的依赖，这是因为我之后读取出来的数据要转换成JSON串的格式，数据可读，方便开发。 application.properties文件中添加配置12345678910111213#redis配置#Linux主机地址spring.redis.host=192.168.78.131#端口spring.redis.port=6379#超时时间，msspring.redis.timeout=3000#连接池的最大连接数spring.redis.jedis.pool.max-active=10#链接的最大等待时间msspring.redis.jedis.pool.max-wait=3000#连接池中的最大的等待数量spring.redis.jedis.pool.max-idle=10 在SpringBoot2.0的版本中timeout变成了Duration类型的，从其源码中我们可以看一下是怎么定义的: 123public void setTimeout(Duration timeout) &#123; this.timeout = timeout; &#125; 所以正常的写法应该是： 1spring.redis.timeout=3000ms 但是这样也带来了一个问题，下面再说这个问题是什么，这里先按照初始的定义，不会报错的 正常的人可能还会在配置文件中添加redis的密码的配置，没有密码的话就不要添加这个配置，就算默认为空也会导致出现错误，不能实现OAuth认证，要是有密码的话就添加上并写上自己的密码。 1spring.redis.password= Redis的自定义初始化首先写redisConfig的文件，读取application.properties文件中yml的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.springboot.SecKill.redis;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.stereotype.Component;/** * Redis的配置 * @author WilsonSong * @date 2018/8/1/001 *///作为组件扫描进来@Component//读取配置文件@Configuration@ConfigurationProperties(prefix = "spring.redis")public class RedisConfig &#123; private String host; //主机 private int port; //端口 private int timeout; //超时时间 @Value("$&#123;spring.redis.jedis.pool.max-active&#125;") private int maxActive; //连接池最大线程数 @Value("$&#123;spring.redis.jedis.pool.max-wait&#125;") private long maxWait; //等待时间 @Value("$&#123;spring.redis.jedis.pool.max-idle&#125;") private int maxIdle;//最大空闲连接 public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public int getTimeout() &#123; return timeout; &#125; public void setTimeout(int timeout) &#123; this.timeout = timeout; &#125; public int getMaxActive() &#123; return maxActive; &#125; public void setMaxActive(int maxActive) &#123; this.maxActive = maxActive; &#125; public long getMaxWait() &#123; return maxWait; &#125; public void setMaxWait(long maxWait) &#123; this.maxWait = maxWait; &#125; public int getMaxIdle() &#123; return maxIdle; &#125; public void setMaxIdle(int maxIdle) &#123; this.maxIdle = maxIdle; &#125;&#125; 上面用了两种方式来读取application.properties中的配置，一种是直接设置@ConfigurationProperties(prefix = “spring.redis”)，然后变量名与application.properties中的变量名一样，这样就可以读出来了，然后像max-wait这种变量名没法定义啊，所以又用了@Value(“${spring.redis.jedis.pool.max-idle}”)这种注解的方式来读取，当然你可以全部影注解的方式来读取，注意过程中的每一个变量的基本数据类型定义准确。maxWait和timeout这两个本来都是Duration类型的，但是这里分别写成long和int类型的。一会儿再解释这个问题。 过程中需要从redis连接池中获取redis服务，所以这里初始化jedisPool的配置 123456789101112131415161718192021222324252627282930313233package com.springboot.SecKill.redis;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Service;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * @author WilsonSong * @date 2018/8/1/001 */@Servicepublic class RedisPoolFactory &#123; @Autowired RedisConfig redisConfig; /** * redis连接池的一些配置 * @return */ @Bean public JedisPool JedisPoolFactory()&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(redisConfig.getMaxIdle()); poolConfig.setMaxTotal(redisConfig.getMaxActive()); poolConfig.setMaxWaitMillis((redisConfig.getMaxWait())); JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),redisConfig.getPort(),redisConfig.getTimeout()); return jedisPool; &#125;&#125; 这里解释下maxWait和timeout这两个数据类型的问题。首先 1poolConfig.setMaxWaitMillis((redisConfig.getMaxWait())); 用到了maxWait这个变量，看一下setMaxWaitMillis（）函数的源码 123public void setMaxWaitMillis(long maxWaitMillis) &#123; this.maxWaitMillis = maxWaitMillis; &#125; maxWaitMillis这个变量是long类型的，所以执勤才那么定义。 同理 1JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),redisConfig.getPort(),redisConfig.getTimeout()); 这里面有用到redisConfig.getTimeout()，看一下JedisPool是怎么初始化的 123public JedisPool(GenericObjectPoolConfig poolConfig, String host, int port, int timeout) &#123; this(poolConfig, host, port, timeout, (String)null, 0, (String)null); &#125; 可以看到timeout是int类型的，你要一开始定义成Duration类型的，然后可能过程中会涉及到数据类型的强制准换，会不会报错不知道，有兴趣的可以试一下。 最后就是初始化redis的方法如get,set等等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package com.springboot.SecKill.redis;import com.alibaba.fastjson.JSON;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;/** * @author WilsonSong * @date 2018/8/1 */@Servicepublic class RedisService &#123; private static final Logger logger = LoggerFactory.getLogger(RedisService.class); @Autowired JedisPool jedisPool; public &lt;T&gt; T get(KeyPrefix prefix, String key, Class&lt;T&gt; clazz)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; String str = jedis.get(realKey); T t = String2Bean(str, clazz); return t; &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; public &lt;T&gt; boolean set(KeyPrefix prefix,String key, T value)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); String value_new = Bean2String(value); if (value_new == null || value_new.length() &lt;0)&#123; return false; &#125; //生成real key String realKey = prefix.getPrefix() + key; //过期时间 int seconds = prefix.expireSeconds(); if (seconds &lt;= 0)&#123; jedis.set(realKey, value_new); &#125;else &#123; jedis.setex(realKey,seconds,value_new); &#125; return true; &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return false; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //key 是否存在 public &lt;T&gt; Boolean exists(KeyPrefix prefix, String key)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; return jedis.exists(realKey); &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //增加key对应的值 public &lt;T&gt; Long incr(KeyPrefix prefix, String key)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; return jedis.incr(realKey); &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //减少key对应的对象的值 public &lt;T&gt; Long decr(KeyPrefix prefix, String key)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; return jedis.decr(realKey); &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //bean对象准换为String private &lt;T&gt; String Bean2String(T value) &#123; if (value == null)&#123; return null; &#125; Class&lt;?&gt; clazz = value.getClass(); if (clazz == int.class || clazz == Integer.class)&#123; return ""+value; &#125;else if (clazz == String.class)&#123; return (String)value; &#125;else if (clazz == long.class || clazz == Long.class)&#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125; &#125; //String转换为bean private &lt;T&gt; T String2Bean(String str, Class&lt;T&gt; clazz) &#123; if (str == null || str.length() &lt;0 || clazz == null)&#123; return null; &#125; if (clazz == int.class || clazz == Integer.class)&#123; return (T)Integer.valueOf(str); &#125;else if (clazz == String.class)&#123; return (T)str; &#125;else if (clazz == long.class || clazz == Long.class)&#123; return (T)Long.valueOf(str); &#125;else &#123; return JSON.toJavaObject(JSON.parseObject(str),clazz); &#125; &#125;&#125; 最后在controller中编写一个方法实现对service层的调用即可，就不赘述了。 踩过的坑运行程序发现报出异常 Could not get a resource from the pool。 其实也就是在执行 jedis = jedisPool.getResource();这一步时出错了 首先第一种可能是你的redis服务没开启，检查下。 确认开启了之后就修改你的redis.conf文件，把bind 127.0.0.1改成bind 0.0.0.0， ​ 也就是把redis的访问权限有只能本机访问改成所有的都能访问。 最后可能的原因有你的Linux的防火墙没有开放Redis的端口，可以配置打开，也可以直接关掉防火墙，我这里直接关掉了Linux的防火墙。 我用的是centos7 永久关闭防火墙的方法 1234//临时关闭systemctl stop firewalld//禁止开机启动systemctl disable firewalld 这样你再测试下，要是还不能用还有别的原因，可以自己上网去看一下具体怎么解决。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表设计思想及实现]]></title>
    <url>%2F2018%2F07%2F01%2FHashTable%2F</url>
    <content type="text"><![CDATA[哈希表设计思想及实现定义哈希表在《算法4》这本书中是这么介绍的：哈希表其实又叫散列表，是算法在时间和空间上做出权衡的经典例子。如果一个表所有的键都是小整数，我们就可以用一个数组来实现无序的符号表，将键作为数组的索引而数组中i出存储的值就是它对应的值。其实散列表的思想也是这样的，只不过他的键的类型更加复杂，是这种简易方法的一种扩展。 使用散列查找分为两步： 用散列函数将被查找的键转换为数组的一个索引。理想情况下，不同的键值都会转换成为不同的索引值，但是一般情况下我们会遇到多个键对应相同的索引值，这也就是所谓的散列冲突。 处理碰撞冲突的情况，常用得方法有两种：拉链法（链地址法）和线性探测法，下面也会介绍这两种方法。 哈希函数其实要设计一个哈希表首先要做的就是散列函数的计算，通过散列函数就可以将键转换为数组的索引。其实哈希函数的设计是一个非常常见的一个研究方向，就像在我们的网络安全的密码设计的过程中，散列函数就是一个非常重要的理论。但是这里介绍的是最一般的哈希函数的设计思想。 哈希函数其实就是将键准换为索引，那么这里的键可以用什么数据类型呢？其实常见的基本数据类型都可以，甚至是我们自己定义的数据类型也是可以的。下面将分开展开介绍。 正整数对于小正整数的话直接用就可以了，对于小负整数的话进行一定的偏移就可以了，例如-100 - 100 —&gt; 0 - 200 对于大整数散列最常用的方法是除留余数法。 例如一个身份证号：332112200007076666这个的话取模，让他模10000，取后4位6666作为索引，这样带来好处是节省空间，因为我们显然不可能开辟那么大的空间去让身份证号称为索引，太浪费空间了。但是这样也带来了一定的问题就是碰撞冲突的问题。还有一个问题就是直接取模的话容易造成键值的分布不均匀。所以一般采用的方式是模一个大素数，为什么是模一个素数就可以避免不均匀的情况，这个其实是数论里的问题，不探讨，知道方法就可以了。 关于上面的情况举个例子介绍下： 1234510 % 4 = 2 10 % 7 = 320 % 4 = 0 20 % 7 = 630 % 4 = 2 30 % 7 = 240 % 4 = 0 40 % 7 = 550 % 4 = 2 50 % 7 = 1 那素数怎么取呢？给出一般的参考的取值 浮点数浮点数的话其实也是转换成为整数，然后使用除留余数法。 那浮点数怎么转换成为整数呢？我们知道浮点数其实在计算机中是二进制数存在的，将二进制数变为整数就可以了。 字符串其实字符串我们也可以将其看成是大整数来处理。 举个例子：$$166 = 1 10^2 + 6 10^1+ 6*10^0$$ $$code = cB^3+oB^2+dB^1+eB^0$$ $$hash(code) =(cB^3+oB^2+dB^1+eB^0)\%M$$ $$hash(code) =((((cB)+o)B+d)*B+e))\%M$$ $$hash(code) =((((c\%M)B+o)\%MB+d)\%M*B+e))\%M$$ 其实左后就准换成为上面公式的样子，其中B表示进制，M表示模的素数。 其实转换成代码就是下面这样的： 123int hash = 0;for(int i = 0; i &lt; s.length(); i++ ) hash = (hash * B + s.charAt(i))%M 组合类型所谓的组合类型也就是自定义的数据类型，也是可以转换成为大整数来处理。 例如我定义了一个Student的数据类型 Student：name , number,score: 计算student的散列值如下：$$hash(student) = (((student.name\%M)B + student.number)\%MB + student.socre)\%M$$ 链地址法（拉链法）链地址法的原理时如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。下面从百度上截取来一张图片，可以很清晰明了反应下面的结构。比如说我有一堆数据{1,12,26,337,353…}，而我的哈希算法是H(key)=key mod 16，第一个数据1的哈希值f(1)=1，插入到1结点的后面，第二个数据12的哈希值f(12)=12，插入到12结点，第三个数据26的哈希值f(26)=10，插入到10结点后面，第4个数据337，计算得到哈希值是1，遇到冲突，但是依然只需要找到该1结点的最后链结点插入即可，同理353。 把一个值得hash值转换为一个数组的索引的代码如下： 123private int hash(K key)&#123; return (key.hashCode() &amp; 0x7ffffff)%M;&#125; 通过&amp; 0x7ffffff这种方式就可以将符号位屏蔽，也就是说我们就算是传入负数也没有关系。 上面的图是每个地址存的是一个链表，在java8中当冲突达到一定的数量的时候就会将链表转换为红黑树，我们下面的实现用地址存一个TreeMap（java中的TreeMap的底层其实就是用红黑树来实现的）来具体的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; private TreeMap&lt;K, V&gt;[] hashtable; private int size; private int M; public HashTable(int M)&#123; this.M = M; size = 0; hashtable = new TreeMap[M]; for(int i = 0 ; i &lt; M ; i ++) hashtable[i] = new TreeMap&lt;&gt;(); &#125; public HashTable()&#123; this(97); &#125; private int hash(K key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public int getSize()&#123; return size; &#125; public void add(K key, V value)&#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(map.containsKey(key)) map.put(key, value); else&#123; map.put(key, value); size ++; &#125; &#125; public V remove(K key)&#123; V ret = null; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(map.containsKey(key))&#123; ret = map.remove(key); size --; &#125; return ret; &#125; public void set(K key, V value)&#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(!map.containsKey(key)) throw new IllegalArgumentException(key + " doesn't exist!"); map.put(key, value); &#125; public boolean contains(K key)&#123; return hashtable[hash(key)].containsKey(key); &#125; public V get(K key)&#123; return hashtable[hash(key)].get(key); &#125;&#125; 动态空间处理我们上实现的时候把M的值取成了固定值，这个时候我们来分析下他的时间复杂度： 如果放入哈希表中的元素的个数使N，每个地址中存放的元素的个数是N/M的，然后每个地址中存放的是TreeMap，也就是底层是红黑树，对于一个红黑树的查询一个元素的时间复杂度是O(logN/M)的。然而对于哈希表其实是查询的复杂度应该是O(1)的复杂度，因为底层就是数组，直接索引一个数组中的值也就是O(1)的复杂度。 但是这里明显不符合啊？其实就是开辟的空间是固定的导致的，我们需要进行动态空间处理。怎么处理呢？其实就是把和动态数组的处理是一样的。当元素的个数大于阈值的时候就扩大空间，小于阈值时就压缩空间，具体如下： 当平均每个地址承载的元素多过一定程度时就扩容：n/M &gt;= upperTol; 当平均每个地址承载的元素少于一定程度时就缩容：n/M &lt; lowerTol; 扩容的时候怎么去扩大，扩大成多少呢？因为空间的大小其实也就是我们要模的那个值，所以选取扩大空间大小是有要求的。其实扩大的参考值就是上面给出素数取值时一般参考的取值。 具体的实现如下： 123456789101112131415private void resize(int newM)&#123; TreeMap&lt;K, V&gt;[] newHashTable = new TreeMap[newM]; for(int i = 0 ; i &lt; newM ; i ++) newHashTable[i] = new TreeMap&lt;&gt;(); int oldM = M; this.M = newM; for(int i = 0 ; i &lt; oldM ; i ++)&#123; TreeMap&lt;K, V&gt; map = hashtable[i]; for(K key: map.keySet()) newHashTable[hash(key)].put(key, map.get(key)); &#125; this.hashtable = newHashTable; &#125; 开放地址法实现哈希表的另一种方式就是用大小为M的数组保存N个键值对，其中M &gt; N。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法给统称为开放地址散列表。 其实就是使用开放地址法来解决碰撞冲突的问题。具体的开放地址法是怎么来解决碰撞冲突的，书上给出的解释是这样的： 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.util.TreeMap;public class HashTable&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; private final int[] capacity = &#123;53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469, 12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741&#125;; private static final int upperTol = 10; private static final int lowerTol = 2; private int capacityIndex = 0; private TreeMap&lt;K, V&gt;[] hashtable; private int size; private int M; public HashTable()&#123; this.M = capacity[capacityIndex]; size = 0; hashtable = new TreeMap[M]; for(int i = 0 ; i &lt; M ; i ++) hashtable[i] = new TreeMap&lt;&gt;(); &#125; private int hash(K key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public int getSize()&#123; return size; &#125; public void add(K key, V value)&#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(map.containsKey(key)) map.put(key, value); else&#123; map.put(key, value); size ++; if(size &gt;= upperTol * M &amp;&amp; capacityIndex + 1 &lt; capacity.length)&#123; capacityIndex ++; resize(capacity[capacityIndex]); &#125; &#125; &#125; public V remove(K key)&#123; V ret = null; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(map.containsKey(key))&#123; ret = map.remove(key); size --; if(size &lt; lowerTol * M &amp;&amp; capacityIndex - 1 &gt;= 0)&#123; capacityIndex --; resize(capacity[capacityIndex]); &#125; &#125; return ret; &#125; public void set(K key, V value)&#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(!map.containsKey(key)) throw new IllegalArgumentException(key + " doesn't exist!"); map.put(key, value); &#125; public boolean contains(K key)&#123; return hashtable[hash(key)].containsKey(key); &#125; public V get(K key)&#123; return hashtable[hash(key)].get(key); &#125; private void resize(int newM)&#123; TreeMap&lt;K, V&gt;[] newHashTable = new TreeMap[newM]; for(int i = 0 ; i &lt; newM ; i ++) newHashTable[i] = new TreeMap&lt;&gt;(); int oldM = M; this.M = newM; for(int i = 0 ; i &lt; oldM ; i ++)&#123; TreeMap&lt;K, V&gt; map = hashtable[i]; for(K key: map.keySet()) newHashTable[hash(key)].put(key, map.get(key)); &#125; this.hashtable = newHashTable; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树思想详解及实现]]></title>
    <url>%2F2018%2F06%2F27%2FRedBlackTree%2F</url>
    <content type="text"><![CDATA[红黑树思想详解及实现从2-3树开始2-3树定义2-3树在《算法4》这本树中的定义是这样子的： 一棵2-3查找树或为一棵空树，或由以下节点组成： 2-节点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该节点，右链接指向的2-3树中的节点值都大于该节点。 3-节点，含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该节点，中连接指向的2-3树中的键值位于两个键值之间，右链接指向的2-3树的节点都大于该节点。 其实2-3树是一个绝对平衡的二分查找树，什么叫绝对平衡？就是叶子节点的高度是相同的，或者说任一节点到空节点的距离是相同的。 下图就是一棵2-3树： 2-3树如何维持绝对平衡2-3树维持平衡的过程其实就是当来一个一个节点的时候先与其要存储的位置的父亲节点进行融合，组成一个2节点，然后在来一个元素的话继续融合，然后这个时候其实这个节点是一个4节点，我们的2-3树中是没有4节点的，这个时候就将这个4节点退化成3个2节点。每次添加元素的时候都是这样的操作，当一个子节点添加成为4节点然后退化的时候成3个两节点的时候就需要将该根节点并到其父亲节点上。这样就可以保持树的平衡。 具体的的实现如下动画所示： 红黑树与2-3 树的等价性红黑树顾名思义红色和黑色的树，其实就是树中存在红色的节点和黑色的节点。那红色的节点和黑色的节点给带变什么意思呢？ 其实一个黑色的节点表示2-3树中的2-节点，一个黑色的节点加上其左孩子为红色的节点这两个节点表示3-节点。其实也就是黑色节点和作为其左孩子的红色节点是在树上的一层的。 然后看一个2-3树与红黑树等价的例子： 红黑树的性质 每个节点或者是红色的，或者是黑色的 根节点是黑色的 每一个叶子节点（最后的空节点）是黑色的 如果一个节点是红色的，其孩子节点都是黑色的 从任意一个节点到叶子节点经过的黑色的节点的数量是相同的 怎么理解这些性质呢？ 首先每个节点是红色或者黑色，红黑树中就这两种颜色的节点，没啥可说的。 然后是根节点是黑色的，为什么说根节点是黑色的呢？可以从2-3树的角度来理解，比方说2-3树的根节点是2-节点的，肯定是黑色的，然后手机3节点的也会退化成一个黑色节点带一个红色左孩子的节点，就算是空树，我们知道最后的空节点也是黑色的。这就与第3条性质吻合。 然后是叶子节点都是黑色的，也就是最后的空节点都是黑色的，其实他就是定义空的是黑色的。 接着是一个红色节点的两个孩子节点都是黑色的，首先反推一下，你想两个红色节连在一起，然后其父亲节点一定是有个黑色节点，那这样就对应成了2-3树中的4节点，明显是不成立的。然后正向看一下，对应2-3树中，一个红色节点肯定是一个3节点，其孩子节点要么是一个2节点要么是一个3节点，2节点的话肯定是黑色的，3节点的话也会是一个黑色节点带一个红色的左孩子节点，那链接在黑色节点上的肯定也是黑色的节点。 最后一条性质，从任意一个节点到叶子节点经过的黑色的节点的数量是相同的，红黑树是一颗绝对黑平衡的树，其实即使黑色节点构成的树是绝对平衡的，然后也可以从2-3树的角度理解，2-3树是一颗绝对平衡的树，不管2节点还是3-节点，其一定是由一个黑色节点的，所以黑色节点树就是绝对平衡的。所以从任意一个节点到叶子节点经过的黑色的节点的数量是相同的。 通过以上的定义我们就可以初始化一棵红黑树了 12345678910111213141516171819202122232425262728293031323334public class RedBlackTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; private static final boolean BLACK = false; private static final boolean RED = true; /** * 树节点的底层实现 */ private class Node&#123; public K key; public V value; public boolean color; public Node leftNode; public Node rightnode; public Node(K key, V value)&#123; this.key = key; this.value = value; color = RED; //从红黑树的定义来看，每个节点初始化都是红色节点 leftNode = null; rightnode = null; &#125; &#125; private Node root; private int size; /** * 构造函数 */ public RedBlackTree()&#123; root = null; size = 0; &#125; 向红黑树中添加元素首先我们从2-3是树开始去理解添加元素的操作，要是向2-节点添加元素的话就是直接添加形成一个3-节点，要是向3-节点添加元素的话就是先形成4节点，然后退化成3个两节点，而且添加的话都是添加的红色的节点，然后通过一些列的变换可以让其变成符合要求的红黑树。 那向红黑树中添加元素需要考虑哪些问题呢？ 首先某一棵树中的根节点是黑色的，然后来一个元素，比他小，按照二分搜索树的规则，我们把它插入到根节点的左侧，并且是红色的节点，其实现在就相当于2-3树中的3-节点。正好满足要求不需要任何处理，直接添加即可。 当要插入的元素是大于黑色节点的话，需要将这个红色的节点插入到黑色节点的右侧，这时候是不满足红黑树的原则的，需要进行左旋转来让其满足红黑树的要求。 左旋转左旋转的具体过程如下： 其实就是将根节点作为原来孩子的左孩子节点。通过左旋转之后就可以使红黑树满足要求，但是还是需要对节点的颜色进行改变，因为当前的节点旋转之后节点的位置发生了改变，具体的就是让x节点的颜色变为原来节点的颜色，因为现在x是根节点了，原来根节点是什么颜色，现在x就是什么颜色。然后让原来的节点颜色变为红色，因为旋转之后还是3节点，为了保持其实3节点，所以就将原来的节点颜色变为红色。 具体代码实现如下： 123456789101112131415161718192021/** * 为了保持红黑树性质进行左旋转 // node x // / \ 左旋转 / \ // T1 x ---------&gt; node T3 // / \ / \ // T2 T3 T1 T2 * @param node node * @return */ private Node leftRotate(Node node)&#123; Node x = node.rightnode; node.rightnode = x.leftNode; x.leftNode = node; //变更节点的颜色，现在的根节点的颜色要与原来根节点颜色相同， //原来的根节点现在变成孩子节点，颜色是红色 x.color = node.color; node.color = RED; return x; &#125; 颜色反转插入元素的时候并不只会发生上面一种情况使其不满足红黑树的要求，例如向3节点中插入元素的时候，插入元素之后形成了具体就像下面这种情况： 那怎么去处理这样的情况呢？其实按照定义，这个4节点会退化成3个两节点，也就是让所有的树的节点的颜色变为黑色就可以了，但是3个两节点之后根节点我们还会向上去合并，所有将根节点变为红色。其实也就是我们将树节点的颜色反转一下就可以让其满足了红黑树的要求： 具体如下： 代码实现： 123456789/** * 颜色反转 * @param node node */ private void flipColors(Node node)&#123; node.leftNode.color = BLACK; node.rightnode.color = BLACK; node.color = RED; &#125; 右旋转还有一种添加元素导致的情况如下图： 其实也就是新添加的元素是添加在红色节点的左孩子上，这个时候就不满足红黑树中红色节点的左右孩子都是黑色的性质了，这个时候就需要右旋转处理。具体如下： 其实我们看右旋转完成之后，以为节点的颜色发生变化，还是和左旋转一样的方法去改变旋转后改变的节点的颜色。然后改变完成之后我们发现其是这时候树的样式是和颜色反转时候的情况是一样的，所以这时候进行一下颜色的反转就可以了。 具体的代码如下： 123456789101112131415161718192021/** * 为了保持红黑树性质进行右旋转 // node x // / \ 右旋转 / \ // x T2 -------&gt; y node // / \ / \ // y T1 T1 T2 * @param node node * @return */ private Node rightRotate(Node node)&#123; Node x = node.leftNode; // 右旋转 node.leftNode = x.rightnode; x.rightnode = node; x.color = node.color; node.color = RED; return x; &#125; 整合流程其实在添加元素的时候还有一种情况是需要考虑的，就是添加的元素添加的位置是红色节点的右孩子，这显然也是不满足红黑树的性质的。 这种情况怎么去处理呢？其实可以先37节点左旋转——&gt;然后42右旋转—-&gt;调整节点颜色——&gt;颜色反转其实完成了整个的操作，是添加进新的元素后的树也是满足红黑树的性质的。 具体的过程如下： 其实这个过程是组合了上面讨论的所有情况，所以既然这中情况是所有的问题都会考虑到的话，那其实就可以添加元素的时候组合成下面的过程： 也就是每次添加元素的时候只需要判断出现了那种情况，然后依次跳转到其需要进行的操作上去就可以了，不需要每个都进行重复的流程操作。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177package RedBlackTree;/** * 红黑树的底层简单实现 * @author WilsonSong * @date 2018/6/26 */public class RedBlackTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; private static final boolean BLACK = false; private static final boolean RED = true; /** * 树节点的底层实现 */ private class Node&#123; public K key; public V value; public boolean color; public Node leftNode; public Node rightnode; public Node(K key, V value)&#123; this.key = key; this.value = value; color = RED; //从红黑树的定义来看，每个节点初始化都是红色节点 leftNode = null; rightnode = null; &#125; &#125; private Node root; private int size; /** * 构造函数 */ public RedBlackTree()&#123; root = null; size = 0; &#125; /** * 获取某个key对应的node * @param node node * @param key key * @return Node node */ public Node getNode(Node node,K key)&#123; if (node == null)&#123; return null; &#125; if (node.key.equals(key))&#123; return node; &#125;else if (node.key.compareTo(key) &gt; 0)&#123; return getNode(node.leftNode, key); &#125;else &#123; return getNode(node.rightnode, key); &#125; &#125; /** * 判断节点是否为红色 * @param node node * @return */ public boolean isRed(Node node)&#123; if (node == null)&#123; return BLACK; &#125; return node.color; &#125; /** * 为了保持红黑树性质进行左旋转 // node x // / \ 左旋转 / \ // T1 x ---------&gt; node T3 // / \ / \ // T2 T3 T1 T2 * @param node node * @return */ private Node leftRotate(Node node)&#123; Node x = node.rightnode; node.rightnode = x.leftNode; x.leftNode = node; //变更节点的颜色，现在的根节点的颜色要与原来根节点颜色相同， //原来的根节点现在变成孩子节点，颜色是红色 x.color = node.color; node.color = RED; return x; &#125; /** * 为了保持红黑树性质进行右旋转 // node x // / \ 右旋转 / \ // x T2 -------&gt; y node // / \ / \ // y T1 T1 T2 * @param node node * @return */ private Node rightRotate(Node node)&#123; Node x = node.leftNode; // 右旋转 node.leftNode = x.rightnode; x.rightnode = node; x.color = node.color; node.color = RED; return x; &#125; /** * 颜色反转 * @param node node */ private void flipColors(Node node)&#123; node.leftNode.color = BLACK; node.rightnode.color = BLACK; node.color = RED; &#125; /** * 添加元素 * @param key key * @param value value */ public void add(K key, V value)&#123; root = add(root, key, value); root.color = BLACK; //根节点的颜色一定是黑色的 &#125; /** * 递归的向以node为根节点的树中添加元素 * @param node node * @param key key * @param value value * @return 返回添加元素后的子树的根 */ private Node add(Node node, K key, V value)&#123; if (node == null)&#123; node = new Node(key, value); size ++; return node; &#125; if (node.key.compareTo(key) &gt; 0)&#123; node = add(node.leftNode, key, value); &#125;else if (node.key.compareTo(key) &lt; 0)&#123; node = add(node.rightnode, key, value); &#125;else &#123; node.value =value; &#125; //下面的每一步都要进行判断的，其实就是一个连接整合的过程 //右子树红色，左子树是黑色 if (isRed(node.rightnode) &amp;&amp; !isRed(node.leftNode)) node = leftRotate(node); //左子树为红色，左子树的左子树也为红色，右旋转 if (isRed(node.leftNode) &amp;&amp; isRed(node.leftNode.leftNode)) node = rightRotate(node); //左右子树均为红色，只要颜色反转即可 if (isRed(node.leftNode) &amp;&amp; isRed(node.rightnode)) flipColors(node); return node; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树， 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树的思想及实现]]></title>
    <url>%2F2018%2F06%2F21%2FAVLTree%2F</url>
    <content type="text"><![CDATA[AVL树的思想及实现定义AVL树是高度平衡的二叉搜索树，按照二叉搜索树（Binary Search Tree）的性质，AVL首先要满足： 若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。 AVL树的性质： 左子树和右子树的高度之差的绝对值不超过1 树中的每个左子树和右子树都是AVL树 每个节点都有一个平衡因子(balance factor–bf),任一节点的平衡因子是-1,0,1之一，(每个节点的平衡因子bf 等于右子树的高度减去左子树的高度 ) 下图就是一棵AVL Tree： 如下图，这棵树是非AVL树，因为其平衡因子是不满足要求的。 初始化AVL TreeAVL树是高度平衡的二分搜索树，所以其初始化的时候和二分搜索树是一样的，只不过因为要计算平衡因子，所以需要记录每个节点的高度。 1234567891011121314151617181920212223242526272829303132public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; /** * 节点私有类初始化 */ private class Node&#123; public K key; public V value; public int height; public Node leftNode; public Node rightNode; public Node(K key, V value)&#123; this.key = key; this.value = value; height = 1; leftNode = null; rightNode = null; &#125; &#125; private int size; //树空间 private Node root; //根节点 /** * 构造函数 */ public AVLTree()&#123; root = null; size = 0; &#125; 计算高度和平衡因子节点在初始化的时候的高度为1，然后树的初始化过程中会维护树的高度，所以获取节点的高度的话直接返回该节点的高度值就可以了。 平衡因子其实就是左子树的高度减去右子树的高度。 具体的实现如下： 123456789101112131415161718192021222324/** * 获取某一个节点的高度值 * @param node * @return */ public int getHeight(Node node)&#123; if (node == null)&#123; return 0; &#125; return node.height; &#125; /** * 获取某个节点的平衡因子 * 平衡因子其实就是左孩子的高度减去右孩子的高度,有正负 * @param node * @return */ public int balanceFactor(Node node)&#123; if (node == null)&#123; return 0; &#125; return getHeight(node.leftNode) - getHeight(node.rightNode); &#125; 验证二分搜索树的性质和平衡性AVL树是一颗高度平衡的二分搜索树，所以要满足二分搜索树的性质，也要满足平衡性。 验证是否是二分搜索树的话，二分搜索树的中序遍历之后的元素是满足顺序从大到小的顺序性的，所以可以用该性质来测试是否是二分搜索树。 平衡性就是判断平衡因子的绝对值是否大于0就可以了。 具体如下： 12345678910111213141516171819202122232425262728293031323334353637/** * 中序遍历 * @param node 以node为根的子树 * @param keys keys */ private void inOrder(Node node, ArrayList&lt;K&gt; keys)&#123; if (node == null)&#123; return; &#125; inOrder(node.leftNode, keys); //执行到node.leftNode == null的时候就跳出这一次的inOrder,执行下面的语句 keys.add(node.key); inOrder(node.rightNode,keys); &#125; /** * 是否是一颗平衡树 * @return */ public boolean isBalanced()&#123; return isBalanced(root); &#125; /** * 判断以node为根节点的树是否平衡 * 其实就是看树中每个节点的平衡因子的绝对值是否大于1 * @param node node * @return */ private boolean isBalanced(Node node)&#123; if (node == null)&#123; return true; &#125; if (balanceFactor(node) &gt; 1 || balanceFactor(node) &lt; -1)&#123; return false; &#125; return isBalanced(node.leftNode) &amp;&amp; isBalanced(node.rightNode); &#125; 维护平衡有的时候给树中添加或者删除元素的时候可能会破坏树的平衡，那怎么去维护书的平衡呢？ 右旋转当插入的元素位于不平衡节点的左侧的左侧的时候： 这个时候需要对8这个节点进行右旋转。 右旋转的具体的实现完成如下： 其实过程很简单就是将y的做节点换成x的有节点，然后x的右孩子指向y. 具体的过程如下： 12345678910111213141516171819202122232425/** * 对以node为根节点的树进行右旋转 // 对节点y进行向右旋转操作，返回旋转后新的根节点x // y x // / \ / \ // x T4 向右旋转 (y) z y // / \ - - - - - - - -&gt; / \ / \ // z T3 T1 T2 T3 T4 // / \ // T1 T2 * @param node node * @return 旋转后新的子树的根节点 */ public Node rightRoate(Node node)&#123; Node x = node.leftNode; Node T3 = x.rightNode; x.rightNode = node; node.leftNode = T3; //旋转完成之后更新树的高度,其实只有x和y的高度发生变化 x.height = Math.max(getHeight(x.leftNode), getHeight(x.rightNode)) + 1; node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; return x; &#125; 左旋转当插入的元素位于不平衡节点的右侧的右侧的时候，需要进行左旋转，其实和右旋转是一个对称的过程，不在赘述，具体如下： 123456789101112131415161718192021222324/** * 对以node为根节点的树进行左旋转 // 对节点y进行向左旋转操作，返回旋转后新的根节点x // y x // / \ / \ // T1 x 向左旋转 (y) y z // / \ - - - - - - - -&gt; / \ / \ // T2 z T1 T2 T3 T4 // / \ // T3 T4 * @param node node * @return 返回旋转后新的子树的根 */ public Node leftRoate(Node node)&#123; Node x = node.rightNode; Node T2 = x.leftNode; x.leftNode = node; node.rightNode = T2; //旋转完成之后更新树的高度，其实只有x和y的高度发生变化 x.height = Math.max(getHeight(x.leftNode), getHeight(x.rightNode)) + 1; node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; return x; &#125; 先左旋转后右旋转当插入的元素位于不平衡元素的左侧的右侧的时候需要先左旋转然后进行右旋转，为什么是这样的？ 如下图的情况： 对X进行了左旋转之后变成了上面介绍的需要进行右旋转的情况，这时候只需要在进行右旋转就可以维持平衡了。 先右旋转后左旋转当插入的元素位于不平衡元素的右侧的左侧的时候需要先左旋转然后进行右旋转，为什么是这样的？ 如下图的情况： 对X进行了右旋转之后变成了上面介绍的需要进行左旋转的情况，这时候只需要在进行左旋转就可以维持平衡了。 插入元素其实插入元素的过程是和二分搜索树是一样的，只不过AVL树多了一些操作，插入元素之后需要更新节点的高度，需要判断是否平衡，不平衡的话属于那种不平衡的情况需要进行什么操作来维护平衡？其实就是逻辑上的判断。 具体的实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 插入元素 * @param key * @param value */ public void add(K key, V value)&#123; root = add(root, key, value); &#125; /** * 向以node为根节点的树上插入 * @param node node * @param key key * @param value value * @return */ private Node add(Node node, K key, V value)&#123; if (node == null)&#123; node = new Node(key,value); size ++; return node; &#125; if (node.key.compareTo(key) &gt; 0)&#123; node.leftNode = add(node.leftNode, key, value); &#125;else if (node.key.compareTo(key) &lt; 0)&#123; node.rightNode = add(node.rightNode, key, value); &#125;else&#123; node.value = value; &#125; //更新树的高度 node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; //LL if (balanceFactor(node) &gt; 1 &amp;&amp; (balanceFactor(node.leftNode) &gt; 0))&#123; node = rightRoate(node); &#125; //RR if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode ) &gt; 0))&#123; node = leftRoate(node); &#125; //LR // y - y x // / \ / \ / \ // x T4 向左旋转(x) z T4 向右旋转 (y) z y // / \ - - - - - &gt; / \ - - - - - - - -&gt; / \ / \ // z T3 x T3 T1 T2 T3 T4 // / \ / \ // T1 T2 T1 T2 if (balanceFactor(node) &gt; 1 &amp;&amp; (balanceFactor(node.leftNode) &lt; 0))&#123; node.leftNode = leftRoate(node.leftNode); node = rightRoate(node); &#125; //RL // y - y z // / \ / \ / \ // T1 x 向右旋转(x) T1 z 向左旋转 (y) y x // / \ - - - - - &gt; / \ - - - - - - - -&gt; / \ / \ // z T4 T2 x T1 T2 T3 T4 // / \ / \ // T2 T3 T3 T4 if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode) &gt; 0))&#123; node.rightNode = rightRoate(node.rightNode); node = leftRoate(node); &#125; return node; &#125; 删除元素其实删除元素的过程是和二分搜索树是一样的，删除叶子节点的话直接删除皆可以了，然后删除节点话需要找到该叶子节点的右子树中的最小值来重新成为该树的根节点，还有AVL树还多了一些操作，删除元素之后需要更新节点的高度，需要判断是否平衡，不平衡的话属于那种不平衡的情况需要进行什么操作来维护平衡？其实也还是逻辑上的判断。 具体实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * 删除某个节点对应的元素 * @param key * @return */ public V remove(K key)&#123; Node node = getNode(root,key); if (node == null)&#123; throw new IllegalArgumentException("Error"); &#125; root = remove(root, key); return node.value; &#125; /** * 返回树中最小的元素的节点 * @param node * @return */ public Node minimum(Node node)&#123; if (node == null)&#123; return null; &#125; if (node.leftNode == null)&#123; return node; &#125; return minimum(node.leftNode); &#125; /** * 删除node为节点的树中key的元素 * @param node * @param key * @return */ private Node remove(Node node, K key)&#123; if (node == null)&#123; return null; &#125; Node retNode; if (node.key.compareTo(key) &gt; 0)&#123; node.leftNode = remove(node.leftNode, key); retNode = node; &#125;else if (node.key.compareTo(key) &lt; 0)&#123; node.rightNode = remove(node.rightNode, key); retNode = node; &#125;else &#123; //左子树为空 if (node.leftNode == null)&#123; Node right = node.rightNode; node.rightNode = null; retNode = right; size--; &#125; //右子树为空 else if (node.rightNode == null)&#123; Node left = node.leftNode; node.leftNode = null; retNode = left; size --; &#125; //左右子树均不为空的时候 else &#123; // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.rightNode); successor.rightNode = remove(node.rightNode, successor.key); successor.leftNode = node.leftNode; node.leftNode = node.rightNode = null; retNode = successor; &#125; if (retNode == null)&#123; return null; &#125; retNode.height = Math.max(getHeight(retNode.rightNode), getHeight(retNode.leftNode)); //LL if (balanceFactor(retNode) &gt; 1 &amp;&amp; (balanceFactor(retNode.leftNode) &gt; 0))&#123; retNode = rightRoate(retNode); &#125; //RR if (balanceFactor(retNode) &lt; -1 &amp;&amp; (balanceFactor(retNode.rightNode ) &gt; 0))&#123; retNode = leftRoate(retNode); &#125; //LR if (balanceFactor(retNode) &gt; 1 &amp;&amp; (balanceFactor(retNode.leftNode) &lt; 0))&#123; retNode.leftNode = leftRoate(retNode.leftNode); retNode = rightRoate(retNode); &#125; //RL if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode) &gt; 0))&#123; retNode.rightNode = rightRoate(retNode.rightNode); retNode = leftRoate(retNode); &#125; &#125; return retNode; &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413package AVLTree;import java.util.ArrayList;/** * @author WilsonSong * @date 2018/6/20 */public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; /** * 节点私有类初始化 */ private class Node&#123; public K key; public V value; public int height; public Node leftNode; public Node rightNode; public Node(K key, V value)&#123; this.key = key; this.value = value; height = 1; leftNode = null; rightNode = null; &#125; &#125; private int size; //树空间 private Node root; //根节点 /** * 构造函数 */ public AVLTree()&#123; root = null; size = 0; &#125; /** * size * @return */ public int getSize()&#123; return size; &#125; /** * 树是否为空 * @return */ public boolean isEmpty()&#123; return size == 0; &#125; /** * 是否是二分搜索树 * 其实就是根据二分搜索树的性质中序遍历后是从小到大顺序排序，不满足该条件即不是二分搜索树 * @return */ public boolean isBST()&#123; ArrayList&lt;K&gt; keys = new ArrayList(); inOrder(root, keys); for ( int i = 1; i &lt; keys.size(); i++ )&#123; if (keys.get(i-1).compareTo(keys.get(i)) &gt; 0)&#123; return false; &#125; &#125; return true; &#125; /** * 中序遍历 * @param node 以node为根的子树 * @param keys keys */ private void inOrder(Node node, ArrayList&lt;K&gt; keys)&#123; if (node == null)&#123; return; &#125; inOrder(node.leftNode, keys); //执行到node.leftNode == null的时候就跳出这一次的inOrder,执行下面的语句 keys.add(node.key); inOrder(node.rightNode,keys); &#125; /** * 是否是一颗平衡树 * @return */ public boolean isBalanced()&#123; return isBalanced(root); &#125; /** * 判断以node为根节点的树是否平衡 * 其实就是看树中每个节点的平衡因子的绝对值是否大于1 * @param node node * @return */ private boolean isBalanced(Node node)&#123; if (node == null)&#123; return true; &#125; if (balanceFactor(node) &gt; 1 || balanceFactor(node) &lt; -1)&#123; return false; &#125; return isBalanced(node.leftNode) &amp;&amp; isBalanced(node.rightNode); &#125; /** * 获取某一个节点的高度值 * @param node * @return */ public int getHeight(Node node)&#123; if (node == null)&#123; return 0; &#125; return node.height; &#125; /** * 获取某个节点的平衡因子 * 平衡因子其实就是左孩子的高度减去右孩子的高度,有正负 * @param node * @return */ public int balanceFactor(Node node)&#123; if (node == null)&#123; return 0; &#125; return getHeight(node.leftNode) - getHeight(node.rightNode); &#125; /** * 对以node为根节点的树进行右旋转 // 对节点y进行向右旋转操作，返回旋转后新的根节点x // y x // / \ / \ // x T4 向右旋转 (y) z y // / \ - - - - - - - -&gt; / \ / \ // z T3 T1 T2 T3 T4 // / \ // T1 T2 * @param node node * @return 旋转后新的子树的根节点 */ public Node rightRoate(Node node)&#123; Node x = node.leftNode; Node T3 = x.rightNode; x.rightNode = node; node.leftNode = T3; //旋转完成之后更新树的高度,其实只有x和y的高度发生变化 x.height = Math.max(getHeight(x.leftNode), getHeight(x.rightNode)) + 1; node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; return x; &#125; /** * 对以node为根节点的树进行左旋转 // 对节点y进行向左旋转操作，返回旋转后新的根节点x // y x // / \ / \ // T1 x 向左旋转 (y) y z // / \ - - - - - - - -&gt; / \ / \ // T2 z T1 T2 T3 T4 // / \ // T3 T4 * @param node node * @return 返回旋转后新的子树的根 */ public Node leftRoate(Node node)&#123; Node x = node.rightNode; Node T2 = x.leftNode; x.leftNode = node; node.rightNode = T2; //旋转完成之后更新树的高度，其实只有x和y的高度发生变化 x.height = Math.max(getHeight(x.leftNode), getHeight(x.rightNode)) + 1; node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; return x; &#125; /** * 插入元素 * @param key * @param value */ public void add(K key, V value)&#123; root = add(root, key, value); &#125; /** * 向以node为根节点的树上插入 * @param node node * @param key key * @param value value * @return */ private Node add(Node node, K key, V value)&#123; if (node == null)&#123; node = new Node(key,value); size ++; return node; &#125; if (node.key.compareTo(key) &gt; 0)&#123; node.leftNode = add(node.leftNode, key, value); &#125;else if (node.key.compareTo(key) &lt; 0)&#123; node.rightNode = add(node.rightNode, key, value); &#125;else&#123; node.value = value; &#125; //更新树的高度 node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; //LL if (balanceFactor(node) &gt; 1 &amp;&amp; (balanceFactor(node.leftNode) &gt; 0))&#123; node = rightRoate(node); &#125; //RR if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode ) &gt; 0))&#123; node = leftRoate(node); &#125; //LR // y - y x // / \ / \ / \ // x T4 向左旋转(x) z T4 向右旋转 (y) z y // / \ - - - - - &gt; / \ - - - - - - - -&gt; / \ / \ // z T3 x T3 T1 T2 T3 T4 // / \ / \ // T1 T2 T1 T2 if (balanceFactor(node) &gt; 1 &amp;&amp; (balanceFactor(node.leftNode) &lt; 0))&#123; node.leftNode = leftRoate(node.leftNode); node = rightRoate(node); &#125; //RL // y - y z // / \ / \ / \ // T1 x 向右旋转(x) T1 z 向左旋转 (y) y x // / \ - - - - - &gt; / \ - - - - - - - -&gt; / \ / \ // z T4 T2 x T1 T2 T3 T4 // / \ / \ // T2 T3 T3 T4 if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode) &gt; 0))&#123; node.rightNode = rightRoate(node.rightNode); node = leftRoate(node); &#125; return node; &#125; /** * 返回以node为根的子树的key所在的节点 * @param node * @param key * @return */ private Node getNode(Node node, K key)&#123; if (node == null)&#123; return null; &#125; if (node.key.equals(key))&#123; return node; &#125;else if (node.key.compareTo(key) &gt; 0)&#123; return getNode(node.leftNode, key); &#125;else &#123; return getNode(node.rightNode, key); &#125; &#125; /** * 是否包含k这个节点 * @param key key * @return */ public boolean contains(K key)&#123; return getNode(root, key) != null; &#125; /** * 返回key节点对应的value * @param key key * @return */ public V get(K key)&#123; Node node = getNode(root, key); return node == null? null : node.value; &#125; /** * 更新某个节点的值 * @param key * @param value */ public void set(K key, V value)&#123; Node node = getNode(root, key); if (node == null)&#123; throw new IllegalArgumentException("This key does not contains"); &#125; node.value = value; &#125; /** * 删除某个节点对应的元素 * @param key * @return */ public V remove(K key)&#123; Node node = getNode(root,key); if (node == null)&#123; throw new IllegalArgumentException("Error"); &#125; root = remove(root, key); return node.value; &#125; /** * 返回树中最小的元素的节点 * @param node * @return */ public Node minimum(Node node)&#123; if (node == null)&#123; return null; &#125; if (node.leftNode == null)&#123; return node; &#125; return minimum(node.leftNode); &#125; /** * 删除node为节点的树中key的元素 * @param node * @param key * @return */ private Node remove(Node node, K key)&#123; if (node == null)&#123; return null; &#125; Node retNode; if (node.key.compareTo(key) &gt; 0)&#123; node.leftNode = remove(node.leftNode, key); retNode = node; &#125;else if (node.key.compareTo(key) &lt; 0)&#123; node.rightNode = remove(node.rightNode, key); retNode = node; &#125;else &#123; //左子树为空 if (node.leftNode == null)&#123; Node right = node.rightNode; node.rightNode = null; retNode = right; size--; &#125; //右子树为空 else if (node.rightNode == null)&#123; Node left = node.leftNode; node.leftNode = null; retNode = left; size --; &#125; //左右子树均不为空的时候 else &#123; // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.rightNode); successor.rightNode = remove(node.rightNode, successor.key); successor.leftNode = node.leftNode; node.leftNode = node.rightNode = null; retNode = successor; &#125; if (retNode == null)&#123; return null; &#125; retNode.height = Math.max(getHeight(retNode.rightNode), getHeight(retNode.leftNode)); //LL if (balanceFactor(retNode) &gt; 1 &amp;&amp; (balanceFactor(retNode.leftNode) &gt; 0))&#123; retNode = rightRoate(retNode); &#125; //RR if (balanceFactor(retNode) &lt; -1 &amp;&amp; (balanceFactor(retNode.rightNode ) &gt; 0))&#123; retNode = leftRoate(retNode); &#125; //LR if (balanceFactor(retNode) &gt; 1 &amp;&amp; (balanceFactor(retNode.leftNode) &lt; 0))&#123; retNode.leftNode = leftRoate(retNode.leftNode); retNode = rightRoate(retNode); &#125; //RL if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode) &gt; 0))&#123; retNode.rightNode = rightRoate(retNode.rightNode); retNode = leftRoate(retNode); &#125; &#125; return retNode; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>AVL Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集详解及底层实现]]></title>
    <url>%2F2018%2F06%2F16%2FUnionFind%2F</url>
    <content type="text"><![CDATA[并查集详解及底层实现定义并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 并查集（Union/Find）从名字可以看出，主要涉及两种基本操作:合并和查找。这说明，初始时并查集中的元素是不相交的，经过一系列的基本操作(Union)，最终合并成一个大的集合。 而在某次合并之后，有一种合理的需求：某两个元素是否已经处在同一个集合中了？因此就需要Find操作。 并查集的基本的数据表示：每个元素id的对应一个集合。 然后这种结构使用数组来存储，这样的话Find操作就是索引其中的某个位置的元素，事件复杂度是O(1)。 然后Union操作的话需要遍历整个数组一遍，事件复杂度是O(n)的，时间复杂度大，对于存储的元素数据量变得很大的时候，就比较鸡肋了。 然后这里可以使用树结构来作为并查集的数据存储结构，其实就是将每个元素看做是一个节点，然后是一个集合中的元素就存储在一个树中，然后拥有相同的根节点。具体的如下： 基于这种树结构实现的Find和Union操作的时间复杂度都是O(logn)的，综合来说好一些。 Quick Union如何使用树结构来初始化并查集并且实现Quick Union操作，具体实现如下： 初始化的时候就是每个元素都是一棵树，并且根节点是指向自己的，表示每个元素是属于不同的集合的。 Union其实就是要将合并的元素指向其中某一个元素，由该元素作为根节点，指向同一个根节点的所有元素都是属于同一个集合的。 然后这样的Union操作其实是存在问题的，在合并的时候是可能将将树初始化成一个链表的如下如，这样的话树结构的优势就失去了。 我们并不希望出现这样的问题，那如何来完善呢？ 基于size的union优化我们可以新建一个空间来存储每棵树的size的大小，然后合并的时候讲size小的树合并到size大的树的根节点上，具体就如下图： 而不是这样去合并： 基于rank的union优化上面这样的方式其实避免了合并的时候合并成了链表，但是还有一个问题，就是如下图的合并： 明显还是有问题的，我们希望的合并其实是将左边的树合并到右边的树上，而不是像上面这样，这样其实也是增加了树的深度，我们的union操作的时间复杂度是和树的深度有关系的。我们希望的合并方式是如下图的： 这就是基于rank的合并方式。 我们需要新建一个存储空间，用rank(i)表示已i为根节点的树的深度。 路径压缩在find操作的时候，对于一个树，我们查找的时间复杂度其实也是和树的深度相关的，对于下面右边的树我们要find(4)也就是找4所在树（集合）的根节点，需要从末尾遍历到根部，但还是对于右边的话我们就不需要了，然后这两棵树是代表一样的集合。这就是路径压缩。 具体的实现其实就是将每次查找的元素的指向的节点指向其父亲节点的父亲节点。具体如下： 最后就是觉得上面压缩的还不是最优的，压缩成下面才是最优的，但是这种实现是需要递归的去实现，其实递归的过程本身也是需要付出代价的。所以这里讨论上面那种压缩的具体的实现。 其实这两种路径压缩的实现具体的实现上的不同之处就在于： 1234567891011private int find(int p)&#123; if (p &lt; 0 || p &gt; parent.length)&#123; throw new IllegalArgumentException("p is illegal"); &#125; while (parent[p] != p)&#123; parent[p] = parent[parent[p]]; p = parent[p]; //第一种压缩// parent[p] = find(parent[p]); //第二种压缩 &#125; return parent[p]; &#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package UnionFind;/** * 基于树结构并查集 * @author WilsonSong * @date 2018/6/15 */public class UnionFind implements UF &#123; private int[] parent; private int[] rank; /** * 并查集的初始化 * @param size */ public UnionFind(int size)&#123; parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; size; i++)&#123; parent[i] = i; rank[i] = 1; &#125; &#125; /** * 找到p所在的集合 * @param p 节点 * @return */ private int find(int p)&#123; if (p &lt; 0 || p &gt; parent.length)&#123; throw new IllegalArgumentException("p is illegal"); &#125; while (parent[p] != p)&#123; parent[p] = parent[parent[p]]; p = parent[p];// parent[p] = find(parent[p]); &#125; return parent[p]; &#125; /** * 查看元素p和元素q是否所属一个集合 * @param p * @param q * @return */ @Override public boolean isConnected(int p, int q)&#123; return find(p) == find(q); &#125; /** * 合并两个集合 * @param p * @param q */ @Override public void UnionElements(int p, int q)&#123; if (p &lt; 0 || q &lt; 0 || p &gt; parent.length || q &gt; parent.length)&#123; throw new IllegalArgumentException("index is illegal"); &#125; int pRoot = find(p); int qRoot = find(q); if (rank[pRoot] &gt; rank[qRoot])&#123; parent[qRoot] = pRoot; &#125;else if (rank[pRoot] &lt; rank[qRoot])&#123; parent[pRoot] = qRoot; &#125;else &#123; parent[pRoot] = pRoot; rank[pRoot] += 1; &#125; &#125;&#125; 时间复杂度其实我上面所说的O(logn)的是不准确的，具体的如下：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集， 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[segment tree(线段树)详解]]></title>
    <url>%2F2018%2F06%2F12%2FSegmentTree%2F</url>
    <content type="text"><![CDATA[segment tree(线段树)详解什么是线段树线段树是一棵平衡搜索树，但是不是完全二叉树，其实也是一棵二分搜索树，它储存的是一个区间的信息。 每个节点以结构体的方式存储，结构体包含以下几个信息： 区间左端点、右端点；（这两者必有） 区间内要维护的信息（实际情况而定，数目不等）。 一个具体的线段树如下所示，这里是一数组作为底层数据结构来阐述线段树，所以就简单的将线段树看为满二叉树，这样的话肯定是会造成空间的浪费，但是这里就是为了理解线段树这种数据结构，不去考虑其更高层的实现，要想空间不浪费的话就动态的创建线段树就可以了。 构建二叉树其实只要涉及到树的一些操作就避免不了使用递归的思想来创建树，以为每一棵树都是有一棵棵子树构成的. 主体的思路就是: 对于二分到的每一个结点，给它的左右端点确定范围。 如果是叶子节点，存储要维护的信息。 子树合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class SegmentTree&lt;E&gt; &#123; private E[] data; private E[] tree; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger)&#123; this.merger = merger; data = (E[]) new Object[arr.length]; for (int i = 0; i &lt; arr.length; i++)&#123; data[i] = arr[i]; &#125; tree = (E[])new Object[arr.length * 4 ]; //为保证树是一个满二叉树，包含n个节点最差的情况需要的空间是4n的，所以其中肯定有为空的节点 //其实线段是一颗平衡二叉树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1 buildSegmentTree(0,0,arr.length-1); //创建线段树 &#125; /** * 创建表示data区间[l...r]的线段树 * @param treeIndex 以treeIndex为起点 * @param L L * @param R R */ public void buildSegmentTree(int treeIndex, int L, int R)&#123; if ( L == R)&#123; tree[treeIndex] = data[L]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); int mid = L + (R - L)/2; buildSegmentTree(leftTreeIndex, L, mid); buildSegmentTree(rightTreeIndex, mid + 1, R); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; ** * 返回左孩子节点的索引值 * @param index * @return */ public int leftChild(int index)&#123; return 2 * index + 1; &#125; /** * 返回右孩子节点的索引值 * @param index * @return */ public int rightChild(int index)&#123; return 2 * index + 2; &#125; 上面初始化树的空间的时候使用的空间大小是要存储的数组的大小的4倍，具体是怎么来的？ 对于一棵满二叉树，其第h层的元素有2^h-1个节点，并且第h层元素的节点的个数等于前1—&gt;h-1 层元素个数的总和。那么来看存储n个元素的时候需要多大的空间？需要4n的空间，具体如下图： 这里实现了Merger的接口，这个结接口就是用来应对对线段树的不同操作而设置的，用户可以根据自己想要实现的功能自己进行这个接口的具体实现。 123public interface Merger&lt;E&gt; &#123; E merge(E a, E b);&#125; 树的查询操作查询一个线段树其实使用递归的思想来实现，例如说我们要查询[2,5]这个区间内的元素，然后从根节点开始递归，[2,5]是在[0,7]之内的，然后求出根的左右孩子和中间分割点mid，查询区间的左右边界与mid比较，然后根据其满足的条件看需要在左子树还是右子树继续查询，不断递归直到找到要查询的区间。说的有点啰嗦了，具体看下面： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 返回区间[queryL, queryR]的值 * @param queryL queryL * @param queryR queryR * @return */ public E query(int queryL, int queryR)&#123; return query(0,0,data.length-1, queryL,queryR); &#125; /** * 以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值 * @param index * @param L * @param R * @param queryL * @param queryR * @return */ public E query(int index, int L, int R, int queryL, int queryR)&#123; if (queryL &lt; 0 || queryR &lt; 0|| queryL &gt; queryR || queryL &gt; data.length || queryR &gt; data.length)&#123; throw new IllegalArgumentException("Index is illegal"); &#125; if (L == queryL &amp;&amp; R == queryR)&#123; return tree[index]; &#125; int mid = L + (R - L)/2; int leftChildIndex = leftChild(index); int rightChildIndex = rightChild(index); if (queryL &gt; mid)&#123; return query(rightChildIndex, mid +1, R, queryL,queryR); &#125;else if (queryR &lt;= mid)&#123; return query(leftChildIndex, L, mid, queryL, queryR); &#125; E leftResult = query(leftChildIndex,L,mid, queryL, mid); E rightResult = query(rightChildIndex, mid+1, R, mid +1, queryR); return merger.merge(leftResult,rightResult); &#125; 树中元素的更新更新操作其实与查询操作的实现差不多，但是有一点区别的是，更新某个节点的匀速之后其父节点的元素也需要更新，因为其父节点也是包含该元素的，因此更新操作需要返回更新后状态。 具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637/** * 把索引为index位置的值更新为e * @param index index * @param e e */ public void set(int index, E e)&#123; data[index] = e; set(0, 0,data.length-1, index, e); &#125; /** * 更新以treeIndex为根节点的[L...R]区间内的index位置的元素的值 * @param treeIndex * @param L * @param R * @param index * @param e */ public void set(int treeIndex, int L, int R, int index, E e)&#123; if (index &lt; 0 || index &gt; R || index &lt; L ||index &gt; data.length-1)&#123; throw new IllegalArgumentException("Index is illegal"); &#125; if (L == R)&#123; tree[treeIndex] = e; &#125; int mid = L + (R - L)/2; int leftTreeChild = leftChild(treeIndex); int rightTreeChild = rightChild(treeIndex); if (index &lt;= mid)&#123; set(leftTreeChild, L, mid, index, e); &#125;else if (index &gt; mid )&#123; set(rightTreeChild, mid +1, R, index, e); &#125; tree[treeIndex] = merger.merge(tree[leftTreeChild], tree[rightTreeChild]); &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package SegmentTree;/** * 以数组作为底层的线段树的实现 * @author WilsonSong * @date 2018/6/12 */public class SegmentTree&lt;E&gt; &#123; private E[] data; private E[] tree; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger)&#123; this.merger = merger; data = (E[]) new Object[arr.length]; for (int i = 0; i &lt; arr.length; i++)&#123; data[i] = arr[i]; &#125; tree = (E[])new Object[arr.length * 4 ]; //为保证树是一个满二叉树，包含n个节点最差的情况需要的空间是4n的，所以其中肯定有为空的节点 //其实线段是一颗平衡二叉树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1 buildSegmentTree(0,0,arr.length-1); //创建线段树 &#125; /** * 创建表示data区间[l...r]的线段树 * @param treeIndex 以treeIndex为起点 * @param L L * @param R R */ public void buildSegmentTree(int treeIndex, int L, int R)&#123; if ( L == R)&#123; tree[treeIndex] = data[L]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); int mid = L + (R - L)/2; buildSegmentTree(leftTreeIndex, L, mid); buildSegmentTree(rightTreeIndex, mid + 1, R); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; /** * 获取线段树的大小 * @return */ public int getSize()&#123; return data.length; &#125; /** * 获取元素 * @param index 元素索引 * @return */ public E get(int index)&#123; if (index &lt; 0 || index &gt; data.length)&#123; throw new IllegalArgumentException("index is illegal"); &#125; return data[index]; &#125; /** * 返回左孩子节点的索引值 * @param index * @return */ public int leftChild(int index)&#123; return 2 * index + 1; &#125; /** * 返回右孩子节点的索引值 * @param index * @return */ public int rightChild(int index)&#123; return 2 * index + 2; &#125; /** * 返回区间[queryL, queryR]的值 * @param queryL queryL * @param queryR queryR * @return */ public E query(int queryL, int queryR)&#123; return query(0,0,data.length-1, queryL,queryR); &#125; /** * 以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值 * @param index * @param L * @param R * @param queryL * @param queryR * @return */ public E query(int index, int L, int R, int queryL, int queryR)&#123; if (queryL &lt; 0 || queryR &lt; 0|| queryL &gt; queryR || queryL &gt; data.length || queryR &gt; data.length)&#123; throw new IllegalArgumentException("Index is illegal"); &#125; if (L == queryL &amp;&amp; R == queryR)&#123; return tree[index]; &#125; int mid = L + (R - L)/2; int leftChildIndex = leftChild(index); int rightChildIndex = rightChild(index); if (queryL &gt; mid)&#123; return query(rightChildIndex, mid +1, R, queryL,queryR); &#125;else if (queryR &lt;= mid)&#123; return query(leftChildIndex, L, mid, queryL, queryR); &#125; E leftResult = query(leftChildIndex,L,mid, queryL, mid); E rightResult = query(rightChildIndex, mid+1, R, mid +1, queryR); return merger.merge(leftResult,rightResult); &#125; /** * 把索引为index位置的值更新为e * @param index index * @param e e */ public void set(int index, E e)&#123; data[index] = e; set(0, 0,data.length-1, index, e); &#125; /** * 更新以treeIndex为根节点的[L...R]区间内的index位置的元素的值 * @param treeIndex * @param L * @param R * @param index * @param e */ public void set(int treeIndex, int L, int R, int index, E e)&#123; if (index &lt; 0 || index &gt; R || index &lt; L ||index &gt; data.length-1)&#123; throw new IllegalArgumentException("Index is illegal"); &#125; if (L == R)&#123; tree[treeIndex] = e; &#125; int mid = L + (R - L)/2; int leftTreeChild = leftChild(treeIndex); int rightTreeChild = rightChild(treeIndex); if (index &lt;= mid)&#123; set(leftTreeChild, L, mid, index, e); &#125;else if (index &gt; mid )&#123; set(rightTreeChild, mid +1, R, index, e); &#125; tree[treeIndex] = merger.merge(tree[leftTreeChild], tree[rightTreeChild]); &#125;&#125; 应用在LeetCode上有这么一道题： Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: 12345Given nums = [1, 3, 5]sumRange(0, 2) -&gt; 9update(1, 2)sumRange(0, 2) -&gt; 8 Note: The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly. 这道题目其实就是动态查询某个数组区间内的和，一般的想法是进行预处理，就是把前i个元素的和求出来，然后每次求的时候就可以借助这个和来进行sumRange的操作，然后更新操作的话就是初始化一个新的数组存放原来nums的值，然后对其进行跟新，这样更新的话同时sum的和也需要更新，就是从更新的那个元素开始后面的元素的和全部要更新。事件复杂度nO(n)的，超时了。 然后这里要是使用线段树来做的话实现复杂度就是nO(logn)的，能够运行通过，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175class NumArray &#123; private interface Merger&lt;E&gt; &#123; E merge(E a, E b); &#125; private class SegmentTree&lt;E&gt; &#123; private E[] tree; private E[] data; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger)&#123; this.merger = merger; data = (E[])new Object[arr.length]; for(int i = 0 ; i &lt; arr.length ; i ++) data[i] = arr[i]; tree = (E[])new Object[4 * arr.length]; buildSegmentTree(0, 0, arr.length - 1); &#125; // 在treeIndex的位置创建表示区间[l...r]的线段树 private void buildSegmentTree(int treeIndex, int l, int r)&#123; if(l == r)&#123; tree[treeIndex] = data[l]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); // int mid = (l + r) / 2; int mid = l + (r - l) / 2; buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; public int getSize()&#123; return data.length; &#125; public E get(int index)&#123; if(index &lt; 0 || index &gt;= data.length) throw new IllegalArgumentException("Index is illegal."); return data[index]; &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index)&#123; return 2*index + 1; &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index)&#123; return 2*index + 2; &#125; // 返回区间[queryL, queryR]的值 public E query(int queryL, int queryR)&#123; if(queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) throw new IllegalArgumentException("Index is illegal."); return query(0, 0, data.length - 1, queryL, queryR); &#125; // 在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值 private E query(int treeIndex, int l, int r, int queryL, int queryR)&#123; if(l == queryL &amp;&amp; r == queryR) return tree[treeIndex]; int mid = l + (r - l) / 2; // treeIndex的节点分为[l...mid]和[mid+1...r]两部分 int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(queryL &gt;= mid + 1) return query(rightTreeIndex, mid + 1, r, queryL, queryR); else if(queryR &lt;= mid) return query(leftTreeIndex, l, mid, queryL, queryR); E leftResult = query(leftTreeIndex, l, mid, queryL, mid); E rightResult = query(rightTreeIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult); &#125; // 将index位置的值，更新为e public void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= data.length) throw new IllegalArgumentException("Index is illegal"); data[index] = e; set(0, 0, data.length - 1, index, e); &#125; // 在以treeIndex为根的线段树中更新index的值为e private void set(int treeIndex, int l, int r, int index, E e)&#123; if(l == r)&#123; tree[treeIndex] = e; return; &#125; int mid = l + (r - l) / 2; // treeIndex的节点分为[l...mid]和[mid+1...r]两部分 int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(index &gt;= mid + 1) set(rightTreeIndex, mid + 1, r, index, e); else // index &lt;= mid set(leftTreeIndex, l, mid, index, e); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append('['); for(int i = 0 ; i &lt; tree.length ; i ++)&#123; if(tree[i] != null) res.append(tree[i]); else res.append("null"); if(i != tree.length - 1) res.append(", "); &#125; res.append(']'); return res.toString(); &#125; &#125; private SegmentTree&lt;Integer&gt; segTree; public NumArray(int[] nums) &#123; if(nums.length != 0)&#123; Integer[] data = new Integer[nums.length]; for(int i = 0 ; i &lt; nums.length ; i ++) data[i] = nums[i]; segTree = new SegmentTree&lt;&gt;(data, (a, b) -&gt; a + b); &#125; &#125; public void update(int i, int val) &#123; if(segTree == null) throw new IllegalArgumentException("Error"); segTree.set(i, val); &#125; public int sumRange(int i, int j) &#123; if(segTree == null) throw new IllegalArgumentException("Error"); return segTree.query(i, j); &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * obj.update(i,val); * int param_2 = obj.sumRange(i,j); */]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>SegmentTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆树详解及使用最大堆实现优先队列]]></title>
    <url>%2F2018%2F06%2F12%2FMaxHeapAndPriorityQueue%2F</url>
    <content type="text"><![CDATA[堆树详解及使用最大堆实现优先队列定义堆树的定义如下： 堆树是一颗完全二叉树； 堆树中某个节点的值总是不大于或不小于其孩子节点的值； 堆树中每个节点的子树都是堆树。 当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。 构造二叉堆这里是一自定义的动态数组作为底层来实现最大堆这种数据结构，使用数组存储二叉堆具有如下性质，如下如所示： 就是通过其中的任何一个节点可以找到其父节点或者是左孩子和右孩子节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; /** * 最大堆初始化 * @param capacity */ public MaxHeap(int capacity)&#123; data = new Array&lt;&gt;(capacity); &#125; /** * f返回某一节点的父节点 * @param index node * @return */ private int parent(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException(&quot;index has no parent node&quot;); &#125; return (index-1)/2; &#125; /** * 返回当前节点的左孩子节点 * @param index node * @return */ public int leftChild(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException(&quot;index has no parent node&quot;); &#125; return index * 2 + 1; &#125; /** * 返回当前节点的右孩子节点 * @param index * @return */ public int rightChild(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException(&quot;index has no parent node&quot;); &#125; return index * 2 + 2; &#125; 关于判断堆的大小及是否为空都是很简单的操作。就不在这里多说了。下面说一下最大堆中的sift up,sift down和heapify操作。 向堆中添加元素及sift up对于下面的一个堆，插入元素52时，因为我们使用的是数组存储的二叉堆，然后插入的元素需要满足二叉堆的性质，如果直接通过遍历数组来找到其位置，复杂度是O(n)的，这里采用的是sift up也就是先将元素插入堆的末尾，然后通过上浮操作来找到其位置，复杂度是O(logn)的。 sift up具体实现如下图： 具体的实现如下： 12345678910111213141516171819*** 添加元素* @param e*/public void add(E e)&#123; data.addLast(e); siftUp(data.getSize()-1);&#125;/*** 从节点index开始元素上浮* @param index*/public void siftUp(int index)&#123; while (index &gt; 0 &amp;&amp; data.get(parent(index)).compareTo(data.get(index)) &lt; 0 )&#123; data.swap(index, parent(index)); index = parent(index); &#125;&#125; 取出堆中最大元素及sift down通过性质我们可以知道对于一个最大堆来说，堆中最大的元素在堆顶。取出堆顶的元素之后谁去堆顶？这里采取的操作时将堆顶的62元素和堆底的16交换然后删除16，再将16下沉，找到其合适的位置。这样的复杂度只有O(logn). sift down 具体的实现如下： 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 取出堆中的最大元素 * @return */ public E extractMax()&#123; E ret = findMax(); data.swap(0, data.getSize()- 1); data.deleteLast(); siftDown(0); return ret; &#125; /** * 元素下沉操作 * @param index */ public void siftDown(int index)&#123; while (leftChild(index) &lt; data.getSize())&#123; if (rightChild(index) &lt; data.getSize() &amp;&amp; data.get(leftChild(index)).compareTo(data.get(rightChild(index))) &lt; 0)&#123; if (data.get(index).compareTo(data.get(rightChild(index))) &lt; 0)&#123; data.swap(index, rightChild(index)); index = rightChild(index); &#125; &#125; if (data.get(index).compareTo(data.get(leftChild(index))) &gt; 0)&#123; break; &#125; data.swap(index, leftChild(index)); index = leftChild(index); &#125; &#125; /** * 取出堆中的最大元素，并且替换成元素e * @param e 元素 * @return */ public E replace(E e)&#123; E ret = findMax(); data.set(0, e); siftDown(0); return ret; &#125; 将任意数组整理成最大堆和heapify一般随便一个数组是不符合最大堆的性质的，如何将一个数组整理成最大堆呢？寻常的想法是将数组中的n个元素不断的插入空堆中，这样操作的复杂度是O(nlogn)的，这里采用heapify的操作来实现，其实就是将不是叶子结点的元素全部采用下沉操作，找到自己的位置，时间复杂度为O(n)的。 heapify的操作具体如下： 具体的代码实现如下： 首先是数组的初始化 123456public Array(E[] arr)&#123; data = (E[])new Object[arr.length]; for(int i = 0 ; i &lt; arr.length ; i ++) data[i] = arr[i]; size = arr.length;&#125; 然后是最大堆中的实现： 1234567891011/*** heapify 操作* @param arr*/public MaxHeap(E[] arr)&#123; data = new Array&lt;&gt;(arr); int index= parent(arr.length-1); for (int i = 0; i &lt; index ; i++)&#123; siftDown(index); &#125;&#125; 替换堆中的任意元素是实现的方法比较简单，就是将堆中的最大元素由替换元素替换，然后进行下沉操作，O(logn)的时间复杂度 123456789101112 /** * 取出堆中的最大元素，并且替换成元素e * @param e 元素 * @return */public E replace(E e)&#123; E ret = findMax(); data.set(0, e); siftDown(0); return ret;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package heap;import arrary.Array;/** * 最大堆 * @author WilsonSong * @date 2018/6/11 */public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; /** * 最大堆初始化 * @param capacity */ public MaxHeap(int capacity)&#123; data = new Array&lt;&gt;(capacity); &#125; /** * heapify 操作 * @param arr */ public MaxHeap(E[] arr)&#123; data = new Array&lt;&gt;(arr); int index= parent(arr.length-1); for (int i = 0; i &lt; index ; i++)&#123; siftDown(index); &#125; &#125; public MaxHeap()&#123; data = new Array&lt;&gt;(); &#125; /** * size * @return */ public int getSize()&#123; return data.getSize(); &#125; /** * 是否为空 * @return */ public boolean isEmpty()&#123; return data.isEmpty(); &#125; /** * f返回某一节点的父节点 * @param index node * @return */ private int parent(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException("index has no parent node"); &#125; return (index-1)/2; &#125; /** * 返回当前节点的左孩子节点 * @param index node * @return */ public int leftChild(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException("index has no parent node"); &#125; return index * 2 + 1; &#125; /** * 返回当前节点的右孩子节点 * @param index * @return */ public int rightChild(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException("index has no parent node"); &#125; return index * 2 + 2; &#125; /** * 添加元素 * @param e */ public void add(E e)&#123; data.addLast(e); siftUp(data.getSize()-1); &#125; /** * 从节点index开始元素上浮 * @param index */ public void siftUp(int index)&#123; while (index &gt; 0 &amp;&amp; data.get(parent(index)).compareTo(data.get(index)) &lt; 0 )&#123; data.swap(index, parent(index)); index = parent(index); &#125; &#125; /** * 最大堆中的元素 * @return */ public E findMax()&#123; if (data.getSize() == 0)&#123; throw new IllegalArgumentException("This Heap has no elements"); &#125; return data.get(0); &#125; /** * 取出堆中的最大元素 * @return */ public E extractMax()&#123; E ret = findMax(); data.swap(0, data.getSize()- 1); data.deleteLast(); siftDown(0); return ret; &#125; /** * 元素下沉操作 * @param index */ public void siftDown(int index)&#123; while (leftChild(index) &lt; data.getSize())&#123; if (rightChild(index) &lt; data.getSize() &amp;&amp; data.get(leftChild(index)).compareTo(data.get(rightChild(index))) &lt; 0)&#123; if (data.get(index).compareTo(data.get(rightChild(index))) &lt; 0)&#123; data.swap(index, rightChild(index)); index = rightChild(index); &#125; &#125; if (data.get(index).compareTo(data.get(leftChild(index))) &gt; 0)&#123; break; &#125; data.swap(index, leftChild(index)); index = leftChild(index); &#125; &#125; /** * 取出堆中的最大元素，并且替换成元素e * @param e 元素 * @return */ public E replace(E e)&#123; E ret = findMax(); data.set(0, e); siftDown(0); return ret; &#125;&#125; 作为底层的数组的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250package arrary;/** * 数组 * @author WilsonSong * @date 2018/5/28 */public class Array&lt;E&gt; &#123; private E[] data; private int size; /** * 构造函数，传入数组容量capacity * @param capacity 数组容量 */ public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; /** * 无参数的构造函数，默认数组容量为10 */ public Array()&#123; this(10); &#125; /** * 构造函数 * @param arr */ public Array(E[] arr)&#123; data = (E[])new Object[arr.length]; for(int i = 0 ; i &lt; arr.length ; i ++) data[i] = arr[i]; size = arr.length; &#125; /** * 获取数组的元素个数 * @return */ public int getSize()&#123; return size; &#125; /** * 获取数组的容量 * @return */ public int getCapacity()&#123; return data.length; &#125; /** * 判断数组是否为空 * @return */ public boolean isEmpty()&#123; return size == 0; &#125; /** * 交换数组中的任意两个元素 * @param i * @param j */ public void swap(int i, int j)&#123; if (i &lt; 0 || j &lt; 0 || i &gt; size || j &gt; size )&#123; throw new IllegalArgumentException("i or j do not in this array"); &#125; E ret = data[i]; data[i] = data[j]; data[j] = ret; &#125; /** * 向数组中指定位置插入元素 * @param index 插入位置 * @param e 插入表元素 */ public void add(int index, E e)&#123; if(size == data.length)&#123; resize(2*data.length); &#125; if (index &lt; 0 || index &gt; size)&#123; throw new IllegalArgumentException("Add failed. Required index &gt;= 0 &amp; index &lt;= size "); &#125; for (int i = size -1; i &gt;= index; i--)&#123; data[i+1] = data[i]; &#125; data[index] = e; size ++ ; &#125; /** * 向数组的末尾插入元素 * @param e 元素 */ public void addLast(E e)&#123; add(size, e); &#125; /** *向数组第一个位置插入元素 * @param e 元素 */ public void addFirst(E e)&#123; add(0,e); &#125; /** * 查询指定位置元素 * @param index * @return */ public E get(int index)&#123; if ( index &lt; 0||index &gt; size)&#123; throw new IllegalArgumentException("Get failed. Index is illegal."); &#125; return data[index]; &#125; public E getLast()&#123; return get(size -1); &#125; public E getFirst()&#123; return get(0); &#125; /** * 重设指定位置元素 * @param index * @return */ public void set(int index, E e)&#123; if ( index &lt; 0||index &gt; size)&#123; throw new IllegalArgumentException("Set failed. Index is illegal."); &#125; data[index] = e; &#125; /** * 查询是否包含某个元素 * @param e 查询的元素 * @return */ public boolean contains(E e)&#123; for (int i =0; i&lt;size; i++)&#123; if (data[i].equals(e))&#123; return true; &#125; &#125; return false; &#125; /** * 查询某个元素的位置，如果不存在元素e，则返回-1 * @param e 元素 * @return */ public int find(E e)&#123; for (int i = 0; i&lt; size; i++)&#123; if (data [i].equals(e))&#123; return i; &#125; &#125; return -1; &#125; /** * 删除索引位置的元素 * @param index 索引 * @return */ public E delete(int index)&#123; if (index &lt; 0 || index &gt; size)&#123; throw new IllegalArgumentException("Delete failed. Index is illegal."); &#125; E ret = data[index]; for (int i = index +1 ; i&lt; size; i++)&#123; data[i-1] = data[i]; &#125; size--; data[size] = null; if (size == data.length / 2)&#123; resize(data.length/2); &#125; return ret; &#125; /** * 删除第一个位置元素 * @return */ public E deleteFirst()&#123; return delete(0); &#125; /** * 删除最后一个位置元素 * @return */ public E deleteLast()&#123; return delete(size -1); &#125; /** * 删除元素 * @param e 元素 * @return */ public void deleteElement(E e)&#123; int index = find(e); if (index != -1)&#123; delete(index); &#125;else &#123; throw new IllegalArgumentException("Delete failed. Element is not exist"); &#125; &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append(String.format("Array: size = %d, capacity = %d.\n",size,getCapacity() )); res.append("["); for (int i = 0; i &lt; size; i++)&#123; res.append(data[i]); if (i != size -1)&#123; res.append(","); &#125; &#125; res.append("]"); return res.toString(); &#125; /** * 数组扩容 * @param newCapacity 数组容量 */ private void resize(int newCapacity)&#123; E[] newData = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++)&#123; newData[i] =data[i]; &#125; data = newData; &#125;&#125; 基于最大堆实现优先队列普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。优先队列有很多的实现方式，但通常采用堆数据结构来实现。因为这两者很像。 具体的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041package heap;import queue.Queue;/** * 优先队列 * @author WilsonSong * @date 2018/6/11 */public class PriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; implements Queue&lt;E&gt; &#123; private MaxHeap&lt;E&gt; maxHeap; public PriorityQueue()&#123; maxHeap = new MaxHeap&lt;&gt;(); &#125; @Override public int getSize()&#123; return maxHeap.getSize(); &#125; @Override public boolean isEmpty()&#123; return maxHeap.isEmpty(); &#125; @Override public E getFront()&#123; return maxHeap.findMax(); &#125; @Override public void enqueue(E e)&#123; maxHeap.add(e); &#125; @Override public E dequeue()&#123; return maxHeap.extractMax(); &#125;&#125; 应用统计前k个出现频次高的数字Given a non-empty array of integers, return the k most frequent elements. Example 1: 12Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2] Example 2: 12Input: nums = [1], k = 1Output: [1] Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size 使用优先队列来解决这么问题比较方便，将前k个频次最高的元素放入队列，优先级高的元素出现的频次是这k个中最小的，然后只要有出现频次比他高的就可以替换掉。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package heap;import java.util.*;import java.util.PriorityQueue;/** * Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size. * @author WilsonSong * @date 2018/6/11 */public class heapSolution2 &#123; public static List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; /** * 定义一个频次的私有类 */ class Freq implements Comparable&lt;Freq&gt;&#123; public int e; public int freq; public Freq(int e, int freq)&#123; this.e = e; this.freq = freq; &#125; @Override public int compareTo(Freq anotherFreq)&#123; if (this.freq &lt; anotherFreq.freq) &#123; return -1; &#125; else if (this.freq &gt; anotherFreq.freq)&#123; return 1; &#125; else&#123; return 0; &#125; &#125; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums)&#123; if (!map.containsKey(num))&#123; map.put(num,1); &#125;else &#123; map.put(num, map.get(num) + 1); &#125; &#125; PriorityQueue&lt;Freq&gt; priorityQueue = new PriorityQueue&lt;&gt;(); //按照优先级排列，出现频次低的优先级高 for (int key : map.keySet())&#123; if (priorityQueue.size() &lt; k)&#123; priorityQueue.add(new Freq(key, map.get(key))); &#125;else &#123; if (map.get(key) &gt; priorityQueue.peek().freq)&#123; priorityQueue.remove(); priorityQueue.add(new Freq(key, map.get(key))); &#125; &#125; &#125; List list = new ArrayList(); while (!priorityQueue.isEmpty())&#123; list.add(priorityQueue.poll().e); &#125; return list; &#125; public static void main(String[] args)&#123; int[] array = &#123;1,2,2,3,3,3&#125;; List&lt;Integer&gt; list = topKFrequent(array,2); System.out.println(list.toString()); &#125;&#125; 然后觉得太复杂了，然后又改了改，就是存入hashmap之后，因为其出现的频次对应的是value的值，然后让hashmap根据value排序，然后输出即可。 hashmap根据value排序需要先将其视图存入list中，然后使用collections的排序方法来做，实现一个Comparator的比较器就可以了，代码化简不少。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package heap;import java.util.*;/** * Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size. * @author WilsonSong * @date 2018/6/11 */public class heapSolution &#123; public static List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums)&#123; if (!map.containsKey(num))&#123; map.put(num,1); &#125; map.put(num, map.get(num)+1); &#125; List&lt;Map.Entry&lt;Integer,Integer&gt;&gt; list1 = new ArrayList&lt;&gt;(); list1.addAll(map.entrySet()); Collections.sort(list1, new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123; @Override public int compare(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2) &#123; return o2.getValue().compareTo( o1.getValue()); &#125; &#125;); for (Map.Entry&lt;Integer, Integer&gt; mapping : list1)&#123; if (list.size() &gt;= k)&#123; break; &#125; list.add(mapping.getKey()); &#125; return list; &#125; public static void main(String[] args)&#123; int[] array = &#123;2,2,2,3,3,5,5,5,4,5,4,4,4,4,5&#125;; List&lt;Integer&gt; list = topKFrequent(array,2); System.out.println(list.toString()); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>最大堆， 优先队列， 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map及其底层简单实现]]></title>
    <url>%2F2018%2F06%2F08%2FMap%2F</url>
    <content type="text"><![CDATA[Map数据结构及其底层简单实现 其实Java中的map就是映射，叫字典也可以，其实map也是一种容器，在这里为了深入的去理解map这种数据结构，从底层自己简单的实现 一下。 使用链表作为底层基础来实现Map 其实链表这种数据结构我们知道其一般只包含next和value两个属性，但是其实你也可以多给他添加一个key的属性。这样的话就和我们的map这种数据结构很像了，具体的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class LinkedListMap &lt;K,V&gt; implements Map&lt;K,V&gt; &#123; /** * 初始化链表 * 没有泛型的 */ private class Node&#123; public Node next; public K key; public V value; public Node (K key, V value, Node next)&#123; this.key = key; this.value = value; this.next = next; &#125; public Node(K key, V value)&#123; this.key = key; this.value = value; this.next = null; &#125; public Node()&#123; this(null, null, null); &#125; @Override public String toString()&#123; return key.toString() + " : " + value.toString(); &#125; &#125; public Node dummyHead; //虚拟头结点 public int size; //链表的大小 public LinkedListMap()&#123; dummyHead = new Node(); size = 0; &#125; /** * 获取size * @return */ @Override public int getSize()&#123; return size; &#125; /** * 链表是否为空 * @return */ @Override public boolean isEmpty()&#123; return size == 0; &#125; /** * 获取key对应的节点 * @param key key * @return */ private Node getNode(K key)&#123; Node cur = dummyHead.next; while (cur.next != null)&#123; if (cur.key.equals(key))&#123; return cur; &#125; cur = cur.next; &#125; return null; &#125; /** * 查询树中包含某个key * @param key * @return */ @Override public boolean contains(K key)&#123; return getNode(key) != null; &#125; /** * 向Map中添加元素 * @param key key * @param value value */ @Override public void add(K key, V value)&#123; if (!contains(key))&#123; Node prev = new Node(key,value); prev.next = dummyHead.next; dummyHead.next = prev; size ++; &#125; &#125; @Override public V remove(K key) &#123; if (!contains(key))&#123; throw new IllegalArgumentException("Error: Map do not contain this key"); &#125; Node prev = dummyHead; while (prev.next != null)&#123; if (prev.next.key.equals(key))&#123; Node delNode = prev.next; prev.next = delNode.next; delNode.next= null; size--; return delNode.value; &#125; prev = prev.next; &#125; return null; &#125; /** * 更新key对应的value * @param key key * @param newValue newValue */ public void set(K key, V newValue)&#123; Node node = getNode(key); if (node != null)&#123; node.value = newValue; &#125; if(node == null) throw new IllegalArgumentException(key + " doesn't exist!"); &#125; /** * 获取key对应的value * @param key key * @return */ @Override public V get(K key)&#123; return contains(key)? getNode(key).value : null; &#125;&#125; 使用二分搜索树的思想来实现 其实二分搜索树和用链表的思想来实现map的道理是一样的，每个树节点除了原来的value,左孩子和右孩子，你再添加一个key的属性就可以了，具体的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210public class BSTMap&lt;K extends Comparable&lt;K&gt;, V&gt; implements Map&lt;K, V&gt; &#123; /** * 二分搜索树节点的实现 */ private class Node&#123; public K key; public V value; public Node left; private Node right; public Node(K key, V value)&#123; this.key = key; this.value = value; this.left = null; this.right = null; &#125; &#125; public Node root; //树的根节点 public int size; //树的大小 public BSTMap()&#123; size = 0; root = null; &#125; /** * 树的大小 */ @Override public int getSize()&#123; return size; &#125; /** * 是否为空 * @return */ public boolean isEmpty()&#123; return size == 0; &#125; /** * 添加元素 * @param key * @param value */ public void add(K key, V value)&#123; root = add(root, key, value); &#125; /** * 递归的向node为节点的树中添加元素 * @param node * @param key * @param value * @return */ private Node add(Node node, K key, V value)&#123; if (node == null)&#123; size ++; return node = new Node(key,value); &#125; if (key.compareTo(node.key) &gt; 0)&#123; node.right = add(node.right,key,value); &#125;else if (key.compareTo(node.key) &lt; 0)&#123; node.left = add(node.left, key, value); &#125;else &#123; node.value = value; &#125; return node; &#125; /** * 递归查询key对应的节点 * @param node * @param key * @return */ private Node getNode(Node node,K key)&#123; if (node == null)&#123; return node; &#125; if (node.key.equals(key))&#123; return node; &#125;else if (node.key.compareTo(key) &gt; 0)&#123; return getNode(node.left, key); &#125;else&#123; return getNode(node.right, key); &#125; &#125; /** * 包含某个元素 * @param key * @return */ @Override public boolean contains(K key)&#123; return getNode(root,key)!= null; &#125; /** * 获取key对应的value * @param key * @return */ @Override public V get(K key)&#123; return contains(key)? getNode(root,key).value:null; &#125; /** * 更新key 对应的value * @param key * @param newValue */ @Override public void set(K key, V newValue)&#123; Node node = getNode(root, key); if (node == null)&#123; throw new IllegalArgumentException("Key don't exist"); &#125; node.value = newValue; &#125; /** * 返回以node为根的子树最小值的节点 * @param node */ public Node minimum(Node node)&#123; if (node == null)&#123; return node; &#125; else &#123; return minimum(node.left); &#125; &#125; /** * 删除以node为根节点的树中的最小元素，并返回新的子树的根 * @param node * @return */ public Node removeMin(Node node)&#123; if (node.left == null)&#123; Node delNode = minimum(node); node.left = delNode.right; delNode.right = null; size--; return node; &#125; node.left = removeMin(node.left); return node; &#125; /** * 删除key对应的节点，并返回该key对应的值 * @param key * @return */ @Override public V remove(K key)&#123; return contains(key)?remove(root, key).value: null; &#125; /** * 删除以node为子节点的树的值，并返回新的子树的根 * @param node * @param key * @return */ private Node remove(Node node, K key)&#123; if (node == null)&#123; return null; &#125; if (key.compareTo(node.key) &gt; 0)&#123; node.right = remove(node.right, key); return node; &#125; else if (key.compareTo(node.key) &lt; 0)&#123; node.left = remove(node.left, key); return node; &#125;else &#123; if (node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; if (node.right == null)&#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; Node successor = minimum(node); successor.left = node.left; successor.right = removeMin(node.right); node.left = null; node.right = null; return successor; &#125; &#125;&#125; 复杂度分析 使用二分搜索树和使用链表来实现map他的时间复杂度是不同的，因为这两种数据结构是不一样的，对于不同具体的是怎样的？如下表： LinkListMap BSTMap BSTMap BSTMap 严格讲(h树的深度) 平均 最差 增add O(n) O(h) O(logn) O(n) 删remove O(n) O(h) O(logn) O(n) 改set O(n) O(h) O(logn) O(n) 查get O(n) O(h) O(logn) O(n) 查contains O(n) O(h) O(logn) O(n) 其实对于正常情况下，链表因为一般从头到尾需要遍历一遍，一般对应的操作的时间复杂度是O(n)的； 对于二分搜索树，其实操作一般是二分查找，时间复杂度是和树的深度是相关的，所以是O(logn)的，但是也不排除特殊情况，当一棵树退化成链表的时候如下：这时候他的时间复杂度也就和链表是一样的了。 应用在LeetCode上有这么一道题目 12345678910Given two arrays, write a function to compute their intersection.Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2]Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4] 这里使用map这种数据结构去来处理这个问题，其实就是把一个数组中的元素放入map中作为key,以为key是不可重复的，然后数组中有重复元素怎么办？就value这个属性存放元素的个数。然后不断地查询另一个数组中的元素在map中的数量，找到一个就存一个，然后map中该元素对应的数量就减一个，具体的实现就如下： 1234567891011121314151617181920212223public class MapSolution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; TreeSet&lt;Integer&gt; set = new TreeSet(); for (int num : nums1)&#123; set.add(num); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int num : nums2)&#123; if (set.contains(num))&#123; list.add(num); set.remove(num); &#125; &#125; int[] a = new int[list.size()]; for (int i = 0; i &lt; list.size(); i++)&#123; a[i] = list.get(i); &#125; return a; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结之二分搜索树]]></title>
    <url>%2F2018%2F06%2F06%2FBinarySearchTree%2F</url>
    <content type="text"><![CDATA[二分搜索树定义二分搜索树（Binary Search Tree），也称二叉查找树，有序二叉树,排序二叉树，是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树。 没有键值相等的节点（no duplicate nodes）。 如下图就是一个二分搜索树，其本质就是一个二叉树，并且不一定是满的，而且元素要可比较大小。 优势 二分搜索树在某些方面是具有优势的，比如我们从时间复杂度上来分析一下： 实现二分搜索树的实现 简单的实现一下，通过一个私有类实现包含其所需的节点，值，左节点，右节点。 1234567891011121314151617181920212223public class BinarySearchTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; /** * 定义树节点的私有类 * @param &lt;E&gt; */ private class Node&#123; public E e; public Node left, right; public Node(E e)&#123; this.e = e; left = null; right = null; &#125; &#125; private Node root; //根节点 private int size; //树的大小 public BinarySearchTree()&#123; root = null; size = 0; &#125; 向树中添加元素 其实插入元素使用递归的方式很容易，其核心思想:从根节点开始找插入的位置，满足二叉搜索树的特性，比左子节点大，比右子节点小. 具体的步骤： 从根节点开始，先比较当前节点，如果当前节点为null那么很明显就应该插入到这个节点。 如果上面的节点不是null，那么和当前节点比较，如果小于节点就往左子树放，如果大于节点就往右子树放。 然后分别对左子树或者右子树递归的递归进行如上1、2步骤的操作 此时就用到了递归，那么递归是对某一个问题，它的子问题需要是同样的模型。此处的一个小的问题就是：对某个node，然后进行操作，所以参数应该有个node才能实现循环起来。此处向以node为根的二叉搜索树中,插入节点value. 123456789101112131415161718192021222324252627282930/*** 添加元素* @param e 添加的元素*/public void add(E e)&#123; root = add(root, e);&#125;/*** 递归的添加元素* 向以node为根的二分搜索树中插入元素e，递归算法* 返回插入新节点后二分搜索树的根* @param node 树节点* @param e 元素* @return*/private Node add(Node node, E e)&#123; if (node == null)&#123; size ++; return new Node(e); &#125; if (e.compareTo(node.e) &gt; 0)&#123; node.right = add(node.right, e); &#125; if (e.compareTo(node.e) &lt; 0)&#123; node.left= add(node.left, e); &#125; return node;&#125; 注意 在这里抠一下关于递归添加元素这个函数为啥要返回插入新节点后二分搜索树的根， 比方说上面这棵树，我要添加元素12，执行递归的第一步之后，node节点其实是28这个根节点，然后执行 add(node.left, e); 其实就是像下面的树中添加元素，但是现在的节点还是28，执行完之后就是下面这棵树，返回以16为根节点的这棵树，然后赋值给node.left。其实就是相当于把这棵树连接到了28这个节点上。最后返回node也就是28这个节点，其实就是新添加元素之后的树。 查询树中包含某一个元素 其实查询包含树中是否包含某个元素与向树中添加一个元素的思路是类似的，都是通过递归的方式查询左右子树。 123456789101112131415161718192021222324252627/*** 查询是否包含元素* @param e 元素* @return*/public boolean contain(E e)&#123; return contains(root, e);&#125;/*** 递归的查询是否包含某个元素* @param node 树节点* @param e 元素* @return*/private boolean contains(Node node, E e)&#123; if (node == null)&#123; return false; &#125; if (e.compareTo(node.e) &lt; 0)&#123; return contains(node.left, e); &#125;else if (e.compareTo(node.e) &gt; 0)&#123; return contains(node.right, e); &#125;else &#123; return true; &#125;&#125; 树的遍历 其实树的遍历和图的遍历是一样的，分为两种，一种是广度优先遍历，一种是深度优先遍历。 深度优先遍历 深度优先遍历又分为三种： 前序遍历(Preorder Traversal)：先访问当前节点，再依次递归访问左右子树 中序遍历(Inorder Traversal)：先递归访问左子树，再访问自身，再递归访问右子树 后序遍历(Postorder Traversal)：先递归访问左右子树，最后再访问当前节点。 比如一棵树： 前序遍历的结果是：28–16–13–22–30–29–42 中序遍历的结果是：13–16–22–28–30–29–42 后序遍历的结果是：13–22–16–29–42–30–28 前序遍历的递归实现 递归实现的思想是非常简单的，从根节点开始，判断根节点是否有值，有则输出，然后递归的去处理器左子树，最后去处理其右子树。 1234567891011121314151617181920/*** 前序遍历*/public void preOrder()&#123; preOrder(root);&#125;/*** 递归前序遍历* @param node*/public void preOrder(Node node)&#123; if (node == null)&#123; return; &#125;else &#123; System.out.println(node.e); preOrder(node.left); preOrder(node.right); &#125;&#125; 前序遍历的非递归实现 关于前序遍历的非递归实现这里使用栈的方式，具体的思路如下： 具体的实现其实就是从根节点开始向堆栈中压入元素，然后弹出元素，然将该根节点的左右孩子按顺序压入堆栈，然后弹出栈顶元素，在将弹出的元素的左右孩子按顺序压入堆栈，不断的执行，直到树中没有元素，堆栈中就只弹出元素，直至堆栈为空。 具体的实现如下： 123456789101112131415161718/*** 非递归的实现二分搜索树的前序遍历*/public void preOrderNR()&#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; Node cur = stack.pop(); System.out.println(cur.e); if (cur.right != null)&#123; stack.push(cur.right); &#125; if (cur.left != null)&#123; stack.push(cur.left); &#125; &#125;&#125; 中序遍历的递归实现1234567891011121314151617181920/*** 中序遍历*/public void inOrder()&#123; inOrder(root);&#125;/*** 递归的实现中序遍历* @param node 节点*/public void inOrder(Node node)&#123; if(node == null) return; inOrder(node.left); System.out.println(node.e); inOrder(node.right);&#125; 后序遍历的递归实现1234567891011121314151617181920/*** 后序遍历*/public void postOrder()&#123; postOrder(root);&#125;/*** 递归的实现后序遍历* @param node 节点*/private void postOrder(Node node)&#123; if(node == null) return; postOrder(node.left); postOrder(node.right); System.out.println(node.e);&#125; 广度优先遍历（层序遍历） 层序遍历的实现从根节点开，一次安深度往下遍历，按照先左孩子然后右孩子的方式遍历，这里使用队列的方式来实现层序遍历，具体的实现方式如下： 12345678910111213141516/*** 层序遍历*/public void levelOrder()&#123; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty())&#123; Node cur= queue.remove(); if (cur.left != null)&#123; queue.add(cur.left); &#125; if (cur.right != null)&#123; queue.add(cur.right); &#125; &#125;&#125; 删除书中的节点删除树中的最大元素和最小元素 首先是先要找到最大和最小元素，根据二分搜索树的性质我们可以很容易的就找到最大最小的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 查找树中最小元素 * @return */public E minimum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST can not be empty"); &#125; return minimum(root).e;&#125;/** * 查找树中最小元素的节点 * @param node * @return */private Node minimum(Node node)&#123; if (node.left == null)&#123; return null; &#125; return minimum(node.left);&#125;/** * 查找树中最大元素 * @return */public E maximum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST can not be empty"); &#125; return maximum(root).e;&#125;/** * 查找树中最大元素的节点 * @param node * @return */private Node maximum(Node node)&#123; if (node.right == null)&#123; return node; &#125; return maximum(node.right);&#125; 找到了最大个最小元素之后要将其删除，有需要注意的地方就是当树的结构如下时： 从图上我们可以看出，要是删除的最小元素还有右孩子或者要删除的最大元素还有左孩子的时候，就需要重新把待删除元素的根节点指向其孩子节点。 具体的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 查找树中最小元素 * @return */public E minimum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST can not be empty"); &#125; return minimum(root).e;&#125;/** * 查找树中最小元素的节点 * @param node * @return */private Node minimum(Node node)&#123; if (node.left == null)&#123; return null; &#125; return minimum(node.left);&#125;/** * 查找树中最大元素 * @return */public E maximum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST can not be empty"); &#125; return maximum(root).e;&#125;/** * 查找树中最大元素的节点 * @param node * @return */private Node maximum(Node node)&#123; if (node.right == null)&#123; return node; &#125; return maximum(node.right);&#125;/** * 删除最小元素 * @return 返回最小元素的值 */public E removeMin()&#123; E ret = minimum(); root = removeMin(root); return ret;&#125;/** * 删除最小元素的节点，并返回删除该节点之后新的二分搜索树的根 * @param node 树节点 * @return */public Node removeMin(Node node)&#123; if (node.left == null &amp;&amp; node.right != null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node;&#125;/** * 删除最大元素，并返回最大元素的值 * @return */public E removeMax()&#123; E ret = maximum(); root = removeMax(root); return ret;&#125;/** * 删除最大元素节点并返回删除该节点之后新的二分搜索树的根 * @param node * @return */private Node removeMax(Node node)&#123; if (node.right == null &amp;&amp; node.left != null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; node.right = removeMax(node.right); return node;&#125; 删除树中任意节点 删除树中任意的节点需要考虑的问题就多一些了 首先删除的节点只有左孩子或者只有右孩子，这个时候其实是比较简单的，删除该节点后，其子节点有其父节点继承即可。如下： 但是当要删除的节点既有左孩子又有右孩子的时候就需要注意了，这里使用Hibbard Deletion方法来实现，具体如下： 其实核心的思想即使找到该节点中右子树中的最小节点来替代该节点成为新的节点。 具体的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 从二分搜索树中删除元素为e的节点 * @param e 删除的元素 * @return */public void remove(E e)&#123; root = remove(root, e);&#125;/** * 删除掉以node为根的二分搜索树中值为e的节点, 递归算法，返回删除节点后新的二分搜索树的根 * @param e 删除的元素 *@param node 节点 * @return */private Node remove(Node node, E e)&#123; if( node == null ) return null; if( e.compareTo(node.e) &lt; 0 )&#123; node.left = remove(node.left , e); return node; &#125; else if(e.compareTo(node.e) &gt; 0 )&#123; node.right = remove(node.right, e); return node; &#125; else&#123; // e.compareTo(node.e) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; // 待删除节点右子树为空的情况 if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125;&#125; 注意 这里删除的操作为什么需要返回删除元素之后的新的树的根节点其实和添加元素的道理是一样的，可以参照一下。一样的理解方式。 这样就完成了树的简单的实现 拓展 当然树还有很多的东西可以去设计，比方说把每个树的节点代表的含义设置的更加丰富 如：树节点除了存值，还存储以其为根节点的树的元素的个数，也就是树的size 或者是存储该节点在树中的深度 或者是把树设计成可以存储重复的元素，就是在该节点在存一个代表其元素个数的值。 总之树的拓展还有很多，待慢慢探索实现。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构， 二分搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之逻辑回归（Logistic Regression）与决策边界]]></title>
    <url>%2F2018%2F05%2F29%2FLogisticRegression%2F</url>
    <content type="text"><![CDATA[逻辑回归与决策边界what？逻辑回归其实是一个分类算法而不是回归算法。通常是利用已知的自变量来预测一个离散型因变量的值（像二进制值0/1，是/否，真/假）。简单来说，它就是通过拟合一个逻辑函数（logit fuction）来预测一个事件发生的概率。所以它预测的是一个概率值，自然，它的输出值应该在0到1之间。 Logistic回归简单分析: 优点：计算代价不高，易于理解和实现 缺点：容易欠拟合，分类精度可能不高 适用数据类型：数值型和标称型数据 基本原理按照我自己的理解，可以简单的描述为这样的过程： 找一个合适的预测函数，一般表示为h函数，该函数就是我们需要找的分类函数，它用来预测输入数据的判断结果。这个过程时非常关键的，需要对数据有一定的了解或分析，知道或者猜测预测函数的“大概”形式，比如是线性函数还是非线性函数。借助sigmoid函数构造出的预测函数形式一般为：$$h_{\theta }(x) = g(\theta ^{_{T}}x) = \frac{1}{1+e^{-\theta ^{T}x}}$$其中sigmoid函数为: 构造一个Cost函数（损失函数），该函数表示预测的输出（h）与训练数据类别（y）之间的偏差，可以是二者之间的差（h-y）或者是其他的形式。cost函数为：$$Cost(h_{\theta }x,y) = \begin{cases} -log(h_{\theta }(x))&amp; \text{ if } y=1 \ -log(1-h_{\theta }(x))&amp; \text{ if } y=0 \end{cases}$$综合考虑所有训练数据的“损失”，将Cost求和或者求平均，记为J(θ)函数，表示所有训练数据预测值与实际类别的偏差。J(θ函数一般为：$$J(\theta ) = -\frac{1}{m}[\sum_{i=1}^{m}(y_{i}logh_{\theta }(x_{i})+(1-y_{i})log(1-h_{\theta }(x_{i})))]$$ 显然，J(θ)函数的值越小表示预测函数越准确（即h函数越准确），所以这一步需要做的是找到J(θ)函数的最小值。找函数的最小值有不同的方法，Logistic Regression实现时用的是梯度下降法（Gradient Descent）。&emsp;关于详细的公式推导就不介绍了 伪代码12345678初始化线性函数参数为1构造sigmoid函数重复循环I次 计算数据集梯度 更新线性函数参数确定最终的sigmoid函数输入训练（测试）数据集运用最终sigmoid函数求解分类 代码实现逻辑回归的python代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import numpy as np from sklearn.metrics import accuracy_score class LogisticRegression: def __init__(self): """初始化Logistic Regression模型""" self.coef_ = None self.intercept_ = None self._theta = None def _sigmoid(self, t): return 1.0 / (1.0 + np.exp(-t)) def fit(self, X_train, y_train, eta=0.01, n_iters=1e4): """根据训练数据集X_train, y_train, 使用梯度下降法训练Logictic Regression模型""" assert X_train.shape[0] == y_train.shape[0], \ "the size of X_train must be equal to the size of y_train" def J(theta, X_b, y): y_hat = self._sigmoid(X_b.dot(theta)) try: return -np.sum(y*np.log(y_hat) + (1-y)*np.log(1-y_hat)) / len(y) except: return float('inf') '''逻辑回归''' def dJ(theta, X_b, y): return X_b.T.dot(self._sigmoid(X_b.dot(theta)) - y) / len(X_b) '''梯度下降法''' def gradient_descent(X_b, y, initial_theta, eta, n_iters=1e4, epsilon=1e-8): theta = initial_theta cur_iter = 0 while cur_iter &lt; n_iters: gradient = dJ(theta, X_b, y) last_theta = theta theta = theta - eta * gradient if (abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon): break cur_iter += 1 return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.zeros(X_b.shape[1]) self._theta = gradient_descent(X_b, y_train, initial_theta, eta, n_iters) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def predict_proba(self, X_predict): """给定待预测数据集X_predict，返回表示X_predict的结果概率向量""" assert self.intercept_ is not None and self.coef_ is not None, \ "must fit before predict!" assert X_predict.shape[1] == len(self.coef_), \ "the feature number of X_predict must be equal to X_train" X_b = np.hstack([np.ones((len(X_predict), 1)), X_predict]) return self._sigmoid(X_b.dot(self._theta)) def predict(self, X_predict): """给定待预测数据集X_predict，返回表示X_predict的结果向量""" assert self.intercept_ is not None and self.coef_ is not None, \ "must fit before predict!" assert X_predict.shape[1] == len(self.coef_), \ "the feature number of X_predict must be equal to X_train" proba = self.predict_proba(X_predict) return np.array(proba &gt;= 0.5, dtype='int') def score(self, X_test, y_test): """根据测试数据集 X_test 和 y_test 确定当前模型的准确度""" y_predict = self.predict(X_test) ''''分类的准确度''' return accuracy_score(y_test, y_predict) def __repr__(self): return "LogisticRegression() 上述结果为本次测试数据,可以看出来该数据集其实是三维的数据，因为逻辑回归只能解决二分类的问题，因此取数据集中的前两维数据，作为两种类别，因此使用该数据集可以用来判断逻辑回归测试结果的好坏 测试代码： 12345678from playML.model_selection import train_test_splitfrom playML.LogisticRegression import LogisticRegressionx_train, x_test, y_train, y_test = train_test_split(x, y, seed=666)log_reg = LogisticRegression()log_reg.fit(x_train, y_train)log_reg.score(x_test, y_test)log_reg.predict_proba(x_test) 输出的测试结果： 0.98664939, 0.14852024, 0.17601199, 0.0369836 ,0.0186637 , 0.04936918, 0.99669244, 0.97993941, 0.74524655,0.04473194, 0.00339285, 0.26131273, 0.0369836 , 0.84192923,0.79892262, 0.82890209, 0.32358166, 0.06535323, 0.20735334])```1234567891011121314151617 对于上述简单的测试数据，输出的array中的数据表示将某个数据分类成某一类别的概率，越接近于0就越趋近于分类成0这个类别，同理越趋近与1，就越趋近于分类成1，最后的分类的测试值输出为1.### 决策边界怎么对新输入的数据进行预测分类呢？ 每输入一个值&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;，与\theta ^&#123;T&#125;点乘，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;·$\theta ^&#123;T&#125;$&gt;0，p&gt;0.5，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;·$\theta ^&#123;T&#125;$&lt;0，p&lt;0.5,这样就能实类别的分类。当&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;·$\theta ^&#123;T&#125;$=0就称为该分类的决策边界。 然后使用上面简单的数据集，绘制决策边界，其实也就是分类的边界，当有新的数据的时候骡子坳那边就分类为该类别。```pythondef x2(x1):return (-log_reg.coef_[0] * x1 - log_reg.intercept_) / log_reg.coef_[1]x1_plot = np.linspace(4, 8, 1000)x2_plot = x2(x1_plot)plt.scatter(x[y==0,0], x[y==0,1], color=&apos;red&apos;)plt.scatter(x[y==1,0], x[y==1,1], color=&apos;blue&apos;)plt.plot(x1_plot, x2_plot)plt.show() 得到的结果如下： 上述的决策边界是一条直线，所以不严格的说还是属于线性分类，当分类数据不线性的时候就需要不规则的决策边界。 举个例子使用KNN算法来对上述数据进行分类： 123456789from sklearn.neighbors import KNeighborsClassifierknn_clf = KNeighborsClassifier()knn_clf.fit(x_train, y_train)knn_clf.score(x_test, y_test)plot_decision_boundary(knn_clf, axis=[4, 7.5, 1.5, 4.5])plt.scatter(x[y==0,0], x[y==0,1])plt.scatter(x[y==1,0], x[y==1,1])plt.show() 结果如下： 可以看出通过使用KNN方法对上述数据的决策边界就是不规则的 因为KNN是支持多类别数据的分类的，然后我们的数据集也是3中类别的，所以测试下KNN在三分类中的分类的效果。 12345678knn_clf_all = KNeighborsClassifier()knn_clf_all.fit(iris.data[:,:2], iris.target)# 欠拟合plot_decision_boundary(knn_clf_all, axis=[4, 8, 1.5, 4.5])plt.scatter(iris.data[iris.target==0,0], iris.data[iris.target==0,1])plt.scatter(iris.data[iris.target==1,0], iris.data[iris.target==1,1])plt.scatter(iris.data[iris.target==2,0], iris.data[iris.target==2,1])plt.show() 得到的结果如下： 可以看出分类的结果是非常的不规则的，其实也就是应该是发生了过拟合的问题。 对于KNeighborsClassifier()这个函数其实其中有一个参数是可以调节的,就是n_neighbors这个参数，可以直接运行 knn_clf_all = KNeighborsClassifier()查看其中的参数，n_neighbors这个参数的含义其实就是分类的复杂程度，越小的话越复杂，就容易出现过拟合的问题。这里调节下这个参数看一下效果，设置knn_clf_all = KNeighborsClassifier(n_neighbors = 50)，其余代码相同 得到的结果如下: 明显能够看出来决策边界规则了许多，但是相应的分类效果弱了一些，所以调参，调参。 上面的数据集是可以线性分类的，当数据的类别线性不可分的时候，逻辑回归的方式怎么去处理呢？举个例子： 当数据集是这样的，显然线性不可分，决策边界是不规则类似于圆。其实这个时候就需要类似于使用多项式回归的方式来处理。给逻辑回归中添加多项式。 1234567891011121314151617181920212223242526272829303132333435363738from sklearn.pipeline import Pipelinefrom sklearn.preprocessing import PolynomialFeaturesfrom sklearn.preprocessing import StandardScalerfrom playML.LogisticRegression import LogisticRegressionlog_reg = LogisticRegression()def plot_decision_boundary(model, axis):x0, x1 = np.meshgrid(np.linspace(axis[0], axis[1], int((axis[1]-axis[0])*100)).reshape(-1,1),np.linspace(axis[2], axis[3], int((axis[3]-axis[2])*100)).reshape(-1,1))X_new = np.c_[x0.ravel(), x1.ravel()]y_predict = model.predict(X_new)zz = y_predict.reshape(x0.shape)from matplotlib.colors import ListedColormapcustom_cmap = ListedColormap(['#EF9A9A','#FFF59D','#90CAF9'])plt.contourf(x0, x1, zz, linewidth=5, cmap=custom_cmap)#多项式def PolynomialLogisticRegression(degree):return Pipeline([('poly', PolynomialFeatures(degree=degree)), #多项式参数('std_scaler', StandardScaler()), #标准化（归一化）('log_reg', LogisticRegression()) #逻辑回归对象])poly_log_reg = PolynomialLogisticRegression(degree=2)poly_log_reg.fit(X, y)plot_decision_boundary(poly_log_reg, [-4, 4, -4, 4])plt.scatter(X[y==0,0], X[y==0,1])plt.scatter(X[y==1,0], X[y==1,1])plt.show()print("准确度：" + str(poly_log_reg.score(X, y))) 得到如下的结果： 可以看出添加了多项式的逻辑回归可以解决非线性可分的问题。 逻辑回归中使用正则化处理过拟合的问题因为数据线性不可分的时候，需要在逻辑回归中引入多项式，这也使得分类变得复杂，容桂产生过拟合的问题，解决方法有两个，一个是调节degree参数，另一种就是正则化。通用的正则化的方式就是在J(θ)函数中加一个正则项，使用J(θ）+aL2作为新的损失函数。a用来调节J(θ)和L2各自所占比重。这里C·J(θ）+L1作为所示函数，其实C也是用来平衡J(θ)和L1，原理是一样的。L1和L2是正则化中的一个重要的参数。 1234567891011121314151617181920from sklearn.linear_model import LogisticRegressionfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=666)def PolynomialLogisticRegression2(degree, C, penalty='l2'):return Pipeline([('poly', PolynomialFeatures(degree=degree)),('std_scaler', StandardScaler()),('log_reg', LogisticRegression(C=C, penalty=penalty))])poly_log_reg2 = PolynomialLogisticRegression2(degree=10, C=13, penalty='l1')poly_log_reg2.fit(X_train, y_train)plot_decision_boundary(poly_log_reg2, [-4, 4, -4, 4])plt.scatter(X[y==0,0], X[y==0,1])plt.scatter(X[y==1,0], X[y==1,1])plt.show() 说实话这里选取的数据集的代表性不太够，没有太突出正则化的优点，注重点在方法的实现上，但是还是能看出有一点区别的，决策边界更加清楚了。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习，逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之线性回归（Linear Regression）]]></title>
    <url>%2F2018%2F05%2F25%2FLinearRegression%2F</url>
    <content type="text"><![CDATA[线性回归概念线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。 回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。 其特点为： 解决回归问题 思想简单，实现容易 许多强大的非线性模型的基础 结果具有很好的可解释性 蕴含机器学习中的很多重要思想 简单线性回归的实现下面我们来举例何为一元线性回归分析: 首先假设有这样一组数据 从数据中我们可以看出，可以找到一条直线实现数据的拟合，这条直线设为 y=ax+b 那怎么计算a和b的参数，公式如下: jupyter notebook中具体的代码实现： 12345678910111213141516x_mean = np.mean(x)y_mean = np.mean(y)#分子num = 0.0#分母d = 0.0for x_i, y_i in zip(x, y):num += (x_i - x_mean) * (y_i - y_mean)d += (x_i - x_mean) ** 2a = num/db = y_mean - a*x_meany_hat = a*x + bplt.scatter(x,y)plt.plot(x,y_hat,color="r")plt.axis([0,6,0,6])plt.show() 得到了拟合数据的直线： 这里还可以在底层自己实现线性回归的算法，然后在jupyter notebook中调用，相应的pycharm的代码为： import numpy as np from sklearn.metrics import r2_score class LinearRegression: def __init__(self): &quot;&quot;&quot;初始化Linear Regression模型&quot;&quot;&quot; self.coef_ = None self.intercept_ = None self._theta = None def fit_normal(self, X_train, y_train): &quot;&quot;&quot;根据训练数据集X_train, y_train训练Linear Regression模型&quot;&quot;&quot; assert X_train.shape[0] == y_train.shape[0], \ &quot;the size of X_train must be equal to the size of y_train&quot; X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) self._theta = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y_train) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def fit_gd(self, X_train, y_train, eta=0.01, n_iters=1e4): &quot;&quot;&quot;根据训练数据集X_train, y_train, 使用梯度下降法训练Linear Regression模型&quot;&quot;&quot; assert X_train.shape[0] == y_train.shape[0], \ &quot;the size of X_train must be equal to the size of y_train&quot; def J(theta, X_b, y): try: return np.sum((y - X_b.dot(theta)) ** 2) / len(y) except: return float(&apos;inf&apos;) def dJ(theta, X_b, y): # res = np.empty(len(theta)) # res[0] = np.sum(X_b.dot(theta) - y) # for i in range(1, len(theta)): # res[i] = (X_b.dot(theta) - y).dot(X_b[:, i]) # return res * 2 / len(X_b) return X_b.T.dot(X_b.dot(theta) - y) * 2. / len(X_b) def gradient_descent(X_b, y, initial_theta, eta, n_iters=1e4, epsilon=1e-8): theta = initial_theta cur_iter = 0 while cur_iter &lt; n_iters: gradient = dJ(theta, X_b, y) last_theta = theta theta = theta - eta * gradient if (abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon): break cur_iter += 1 return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.zeros(X_b.shape[1]) self._theta = gradient_descent(X_b, y_train, initial_theta, eta, n_iters) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def fit_sgd(self, X_train, y_train, n_iters=5, t0=5, t1=50): &quot;&quot;&quot;根据训练数据集X_train, y_train, 使用梯度下降法训练Linear Regression模型&quot;&quot;&quot; assert X_train.shape[0] == y_train.shape[0], \ &quot;the size of X_train must be equal to the size of y_train&quot; assert n_iters &gt;= 1 def dJ_sgd(theta, X_b_i, y_i): return X_b_i * (X_b_i.dot(theta) - y_i) * 2. def sgd(X_b, y, initial_theta, n_iters, t0=5, t1=50): def learning_rate(t): return t0 / (t + t1) theta = initial_theta m = len(X_b) for cur_iter in range(n_iters): indexes = np.random.permutation(m) X_b_new = X_b[indexes] y_new = y[indexes] for i in range(m): gradient = dJ_sgd(theta, X_b_new[i], y_new[i]) theta = theta - learning_rate(cur_iter * m + i) * gradient return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.random.randn(X_b.shape[1]) self._theta = sgd(X_b, y_train, initial_theta, n_iters, t0, t1) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def predict(self, X_predict): &quot;&quot;&quot;给定待预测数据集X_predict，返回表示X_predict的结果向量&quot;&quot;&quot; assert self.intercept_ is not None and self.coef_ is not None, \ &quot;must fit before predict!&quot; assert X_predict.shape[1] == len(self.coef_), \ &quot;the feature number of X_predict must be equal to X_train&quot; X_b = np.hstack([np.ones((len(X_predict), 1)), X_predict]) return X_b.dot(self._theta) def score(self, X_test, y_test): &quot;&quot;&quot;根据测试数据集 X_test 和 y_test 确定当前模型的准确度&quot;&quot;&quot; y_predict = self.predict(X_test) return r2_score(y_test, y_predict) def __repr__(self): return &quot;LinearRegression()&quot; 这里其实就是一个简单的一元数据的一个简答线性回归算法。 线性回归评价指标那怎么去评价线性回归算法的指标的好坏呢？ 常用得三个指标：均方误差MSE、均方根误差RMSE、平均绝对误差MAE，这三类算法具体公式这些就不再赘述了，这三类指标都存在一个局限性：作用域的使用范围，对不同事物的预测缺乏统一标准，这样就引出了新的一个预测指标R Squared，其实就是R^2,关于R^2的解释如下： 从上面的图中我们到关于R^2的公式，公式中上面分子就是我们训练出的模型预测的所有误差。 下面分母就是 不管什么我们猜的结果就是y的平均数。（其实也就是我们瞎猜的误差） 那具体实现下这些评价指标，首先换一个数据集，上面是我们自己构造的的太简单了， 导入sklearn中的datasets 123456789101112131415161718192021222324252627282930313233import numpy as npimport matplotlib.pyplot as pltfrom sklearn import datasetsfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics import mean_squared_error, mean_absolute_errorboston = datasets.load_boston()x = boston.data[:,5]y = boston.targetx = x[y&lt;50.0]y = y[y&lt;50.0]plt.scatter(x, y)plt.show()# 划分训练集和测试集x_train, x_test, y_train, y_test = train_test_split(x,y,test_size=0.2)# 简单线性规划x_mean = np.mean(x_train)y_mean = np.mean(y_train)# 分子num = 0.0# 分母d = 0.0for x_i, y_i in zip(x_train, y_train):num += (x_i - x_mean) * (y_i - y_mean)d += (x_i - x_mean) ** 2a = num/db = y_mean - a*x_meany_hat = a*x_train + b # 回归函数plt.scatter(x_train, y_train)plt.plot(x_train, y_hat, color="r")plt.show() y_predict = a*x_test + b mse = mean_squared_error(y_test, y_predict) mae = mean_absolute_error(y_test, y_predict) print(&quot;均方误差为：&quot; + str(mse)) print(&quot;平均绝对误差为：&quot; + str(mae)) rs = 1 - mse/np.var(y_test) print(&quot;R Square = &quot; + str(rs)) 这样我们就得到了所有的评价指标。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习，线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之梯度下降法(GradientDescent)]]></title>
    <url>%2F2018%2F05%2F23%2FGradientDescent%2F</url>
    <content type="text"><![CDATA[梯度下降法概念梯度下降法是迭代法的一种,其实它不是一种具体的机器学习算法，是一种基于搜索的最优化方法，可以用于求解最小二乘问题(线性和非线性都可以)。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。相应的还有一个梯度上升法，它的作用是最大化一个效用函数。 用一个图来表示梯度下降法： 怎么理解呢？梯度其实是在在多维空间中的概念，在二维的平面上其实就是导数，梯度表示的就是方向，通过求某一个点的梯度，我们就可以知道J(损失函数)增大的方向，然后乘-η就可以找到J(损失函数)减小的方向，不断地求J的导数，直到其变为0，这样就找到J的最小值点。这里的η称为学习率，η的取值影响获得最优解的速度，η取值太小的时候学习速度收敛太慢，η太大有可能直接跳过最小值点然后导致不收敛。 有可能在某一次取值的过程中找到的是局部最优解，而不是全局最优解。这个时候怎么解决呢？多次运行，随机化初始点，这样的话增加了找到全局最优解的概率。 模拟实现梯度下降法jupyter notebook中实现： 123456789101112131415161718192021222324252627282930313233343536import numpy as npimport matplotlib.pyplot as plt#datasetsx = np.linspace(-1, 6 ,141)y = (x-2.5)**2-1# 求导数def dJ(theta):return 2*(theta - 2.5)# 损失函数def J(theta):return (theta - 2.5)**2-1# 梯度下降法theta = 0.0eta = 0.1#误差精度epsilon = 1e-8theta_history = [theta]while True:gradient = dJ(theta)last_theta = thetatheta = theta - eta * gradienttheta_history.append(theta)if(abs(J(theta) - J(last_theta)) &lt; epsilon):breakplt.plot(x, y)plt.plot(np.array(theta_history), J(np.array(theta_history)), color='R', marker = 'o')plt.xlabel("theta")plt.ylabel("J")plt.show()print("theta = " + str(theta))print("J(theta) = " + str(J(theta))) 得到的结果如下： 然后我们上面讨论过，η取值太小的时候学习速度收敛太慢，η太大有可能直接跳过最小值点然后导致不收敛。下面测试一下。先取η=0.01 我们可以看出梯度下降的速度变慢了 然后取η=1 当η&gt;1的时候编译器就自动报错，但是这里只是针对这里定义的这个函数，并不是意味着η=1就是极限值，针对不同的函数有不同的取值。 多元线性回归中使用批量梯度下降线性回归中使用梯度下降法，其目标是使得$$\sum_{i=1}^{m}(y^i-\hat{y}^i)^2$$尽可能小，而且线性回归算法的损失函数是具有唯一解的。 其中$$\hat{y}^{i} = \theta _{0} + \theta _{1}X_{1}^{i}+…++ \theta _{n}X_{n}^{i}$$带入因此线性回归中梯度下降的目标就成为了$$\sum_{i=1}^{m}(y^i - \theta _{0} + \theta _{1}X_{1}^{i}+…++ \theta _{n}X_{n}^{i})$$使得其尽可能小。那梯度怎么去求呢？如下： 批量梯度下降法具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as npimport matplotlib.pyplot as pltnp.random.seed(666)x = 2 * np.random.random(size = 100)y = x * 3.0 + 4.0 + np.random.normal(size = 100)X = x.reshape(-1, 1)#损失函数def J(theta, X_b, y):try:return np.sum((y - X_b.dot(theta))**2)/len(X_b)except:return float(&apos;inf&apos;)#损失函数的梯度def dJ(theta, X_b, y):res = np.empty(len(theta))res[0] = np.sum(X_b.dot(theta) - y)for i in range(1, len(theta)):res[i] = (X_b.dot(theta) - y).dot(X_b[:,i])return res *2 /len(X_b)#梯度下降法def gradient_descent(X_b, y, initial_thata, eta, n_iters = 1e4, epsilon = 1e-8):theta = initial_thetai_iter = 0while i_iter &lt; n_iters:# n_iters是最大循环次数gradient = dJ(theta, X_b, y)last_theta = thetatheta = theta - eta * gradientif(abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon):breaki_iter += 1return thetaX_b = np.hstack([np.ones((len(x), 1)), x.reshape(-1, 1)])initial_theta = np.zeros(X_b.shape[1])eta = 0.01theta = gradient_descent(X_b, y, initial_theta, eta) 12345plt.scatter(x, y)Y = X_b.dot(theta)plt.plot(x, Y, color="red")plt.show()print("theta = " + str(theta)) 得到的结果 在初始化数据的时候，斜率设为3，截距为4，然后我们训练出的结果theta与两值接近，证明训练的模型是准确的：y = x * 3.0 + 4.0 + np.random.normal(size = 100) 随机梯度下降法上面我们用的是批量梯度下降法，这种方法有一个缺点，就是每一项都需要对所有的样本点进行计算，数据量少的时候还可以，但是数据量很大的时候就显得很鸡肋了，计算非常的耗资源。能不能每一次计算的时候只对其中的一个样本进行计算呢？这就衍生出了随机梯度下降法。 即每读取一条样本，就迭代对Θ进行更新，然后判断其是否收敛，若没收敛，则继续读取样本进行处理，如果所有样本都读取完毕了，则循环重新从头开始读取样本进行处理。但是，相较于批量梯度下降算法而言，随机梯度下降算法使得J(Θ)趋近于最小值的速度更快，但是有可能造成永远不可能收敛于最小值，有可能一直会在最小值周围震荡，但是实践中，大部分值都能够接近于最小值，所以当数据量很大的时候可以用精度来换取时间。 在随机梯度下降法中为了得到更高的收敛结果，学习率是要随着循环次数的增加而逐渐的减小。这是因为在学习的过程中要是学习率是一个固定值，但是可能由于随机的过程不够好，eta有是一个固定值，那么在学习的过程中随机梯度下降法接近最优解的时候又会慢慢的跳出最优解的范围。气质学习率随着循环次数的增加而逐渐的减小这种思想是模拟退火的思想，去搜了下模拟退火，下面写下自己的理解。 模拟退火算法拟退火其实也是一种贪心算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。模拟退火算法描述： 想象一个高温物体的降温过程。其温度为T时出现能量差为dE的降温概率为P(dE) = e ^ ( -dE / (k * T) ) 。其实就是温度越高降温的概率越大，温度越低降温概率越小。而模拟退火就是利用这样一种思想去进行搜索。那么在进行搜索的时候首先定义一个初始值( 温度 ) T , 一个系数 r ( 降温速度 0 \&lt; r \&lt; 1 ) , 假设你当前状态为 f i , 你的下一个状态为 f i +1 , 对这两个状态进行评价，如果更接近你想要的结果，就更新到这个状态，否则则以 P ( dE ) 的概率去更新到 这个状态，但是其实在实际题目中，这个概率是不必要的，这一步有时是可以忽略掉的。我们可以想象，随着搜索次数的不断增多，搜索范围将越来越趋近于稳定，也就是随着时间的增长温度降低的概率越来越低，直到趋近于1。对应搜索就是随着你搜索的次数越多，你搜索到的值是你想要的值的概率就越大。 然后结合模拟退火的思想，在随机梯度下降法中设置学习率为: 然后结合模拟退火的思想，在随机梯度下降法中设置学习率为:$$\eta = \frac{a}{i_iters + b}$$其中i_iters是循环次数，a,b是两个经验参数，根据实际情况设置。 看完了梯度下降法，其优缺点如下： 第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，其实这就是批量梯度下降。 其中i_iters是循环次数，a,b是两个经验参数，根据实际情况设置。 看完了梯度下降法，其优缺点如下： 第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，其实这就是批量梯度下降。 其中i_iters是循环次数，a,b是两个经验参数，根据实际情况设置。看完了梯度下降法，其优缺点如下：第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，其实这就是批量梯度下降。 另一种，每看一个数据就算一下损失函数，然后求梯度更新参数，这个其实也就是随机梯度下降，这个方法速度比较快，但是收敛性能不太好，可能在最优点附近晃来晃去，找不到不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。 为了克服两种方法的缺点，现在一般采用的是一种折中手段，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 另一种，每看一个数据就算一下损失函数，然后求梯度更新参数，这个其实也就是随机梯度下降，这个方法速度比较快，但是收敛性能不太好，可能在最优点附近晃来晃去，找不到不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。为了克服两种方法的缺点，现在一般采用的是一种折中手段，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 为了克服两种方法的缺点，现在一般采用的是一种折中手段，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 随机梯度下降法实现1234567891011121314151617181920212223242526272829303132333435import numpy as npimport matplotlib.pyplot as pltm = 100000x = np.random.normal(size = m)X = x.reshape(-1, 1)y = 4.0 * x + 3.0 + np.random.normal(0 ,3, size = m)def J(theta, X_b, y):try:return np.sum((y - X_b.dot(theta))**2) / len(y)except:return float(&apos;inf&apos;)def dJ_sgd(theta, X_b_i, y_i):return X_b_i.T.dot(X_b_i.dot(theta) - y_i) * 2.0 def sgd(X_b, y, initial_theta, n_iters):t0 = 5t1 = 50def learning_rate(t):return t0 / (t + t1)theta = initial_thetafor cur_iter in range(n_iters):rand_i = np.random.randint(len(X_b))gradient = dJ_sgd(theta, X_b[rand_i], y[rand_i])theta = theta - learning_rate(cur_iter) * gradientreturn thetaX_b = np.hstack([np.ones((len(X), 1)), X])initial_theta = np.zeros(X_b.shape[1])theta = sgd(X_b, y, initial_theta, n_iters = len(X_b)//3)print(&quot;theta = &quot; + str(theta)) 输出的theta = [3.00887864 4.05589554]，与设置的数据相接近。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习，梯度下降，python3，jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinsterAndFilter]]></title>
    <url>%2F2018%2F05%2F21%2FLinsterAndFilter%2F</url>
    <content type="text"><![CDATA[监听器与过滤器（Listener &amp; Filter）详解Listener 监听器 能做什么事？ 监听某一个事件的发生。 状态的改变。 监听器的内部机制 其实就是接口回调. 接口回调 需求： A在执行循环，当循环到5的时候， 通知B。 事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。 Web监听器 总共有8个 划分成三种类型 定义一个类，实现接口 注册 | 配置监听器 监听三个作用域创建和销毁request —httpServletRequest session —httpSession aapplication — ServletContext 1234567891. ServletContextListener servletcontext创建： 1. 启动服务器的时候 servletContext销毁： 2. 关闭服务器. 从服务器移除项目 1234567892. ServletRequestListener request创建: 访问服务器上的任意资源都会有请求出现。 访问 html： 会 访问 jsp: 会 访问 servlet : 会 123request销毁： 服务器已经对这次请求作出了响应。 1234567891011public class MyRequestListener implements ServletRequestListener &#123; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; System.out.println("servletrequest 销毁了"); &#125; @Override public void requestInitialized(ServletRequestEvent sre) &#123; System.out.println("servletrequest 初始化了"); &#125;&#125; 123&lt;listener&gt; &lt;listener-class&gt;com.itheima.listener.MyRequestListener&lt;/listener-class&gt;&lt;/listener&gt; 123456789101112131415161718192021222324252627283. HttpSessionListener session的创建 只要调用getSession html: 不会 jsp: 会 getSession(); servlet: 会 session的销毁 超时 30分钟 非正常关闭 销毁 正常关闭服务器(序列化) public class MySessionListener implements HttpSessionListener &#123; @Override public void sessionCreated(HttpSessionEvent se) &#123; System.out.println(&quot;创建session了&quot;); &#125; @Override public void sessionDestroyed(HttpSessionEvent se) &#123; System.out.println(&quot;销毁session了&quot;); &#125; &#125; 作用： 12345678910ServletContextListener 利用它来，在servletcontext创建的时候， 1. 完成自己想要的初始化工作 2. 执行自定义任务调度。 执行某一个任务。 Timer HttpSessionListener 统计在线人数. 监听三个作用域属性状态变更 可以监听在作用域中值 添加 | 替换 | 移除的动作。 servletContext — ServletContextAttributeListener request — ServletRequestAttributeListener session — HttpSessionAttributeListener 监听httpSession里面存值的状态变更 这一类监听器不用注册。 HttpSessionBindingListener 监听对象与session 绑定和解除绑定 的动作 12345678910111. 让javaBean 实现该接口即可@Overridepublic void valueBound(HttpSessionBindingEvent event) &#123; System.out.println("对象被绑定进来了");&#125; @Overridepublic void valueUnbound(HttpSessionBindingEvent event) &#123; System.out.println("对象被解除绑定");&#125; HttpSessionActivationListener 用于监听现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作 钝化 （序列化） 把内存中的数据 存储到硬盘上 活化 （反序列化） 把硬盘中的数据读取到内存中。 session的钝化活化的用意何在 session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】 如何让session的在一定时间内钝化. 做配置即可 123456789101112131415161718192021221. 在tomcat里面 conf/context.xml 里面配置 对所有的运行在这个服务器的项目生效 2. 在conf/Catalina/localhost/context.xml 配置 对 localhost生效。 localhost:80803. 在自己的web工程项目中的 META-INF/context.xml 只对当前的工程生效。 maxIdleSwap ： 1分钟不用就钝化 directory ： 钝化后的那个文件存放的目录位置。 D:\tomcat\apache-tomcat-7.0.52\work\Catalina\localhost\ListenerDemo\itheima &lt;Context&gt; &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt; &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;itheima&quot;/&gt; &lt;/Manager&gt; &lt;/Context&gt; Filter 过滤器 ， 其实就是对客户端发出来的请求进行过滤。 浏览器发出， 然后服务器派servlet处理。 在中间就可以过滤， 其实过滤器起到的是拦截的作用。 作用 对一些敏感词汇进行过滤 统一设置编码 自动登录 … 如何使用Filter 定义一个类， 实现Filter public class FilterDemo implements Filter { 123456789101112 public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;来到过虑器了。。。&quot;); chain.doFilter(request, response); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; &#125;&#125; 注册过滤器 在web.xml里面注册，注册的手法与servlet基本一样。 123456789 &lt;filter&gt; &lt;display-name&gt;FilterDemo&lt;/display-name&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;filter-class&gt;com.itheima.filter.FilterDemo&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Filter的生命周期 创建 在服务器启动的时候就创建。 销毁 服务器停止的时候。 Filter执行顺序 客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet 如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。 Filter细节： init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。 其实这里的设计的初衷与ServletConfig是一样的。 如果想放行，那么在doFilter 方法里面操作，使用参数 chain 1chain.doFilter(request, response); 放行， 让请求到达下一个目标。 &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 写法格式与servlet一样。 全路径匹配 以 / 开始 /LoginServlet 以目录匹配 以 / 开始 以 * 结束 /demo01/* 以后缀名匹配 以 * 开始 以后缀名结束 *.jsp *.html *.do 针对 dispatcher 设置 REQUEST ： 只要是请求过来，都拦截，默认就是REQUEST FORWARD : 只要是转发都拦截。 ERROR ： 页面出错发生跳转 INCLUDE ： 包含页面的时候就拦截。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Listener</tag>
        <tag>Filter</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈哈哈，终于把博客搭建起来啦]]></title>
    <url>%2F2018%2F05%2F20%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[520，今天是个好日子，心想的事儿都能成。 嘿嘿，用来几个小时的时间，算是完成了简单的搭建，果然在学习的过程中才是最开心的。为什么要跑到这里搭建博客呢？嗯。。。。 首先csdn换了两个账号，来回倒腾自己的博客，倒腾到一个里去了，至于原因就不说了，心塞塞。然后就是csdn的排版-略略略算是嘲笑吧。 还有毕竟是要常年混迹在全球最大的同性交友社区了，把博客搭起来写写项目开发经历，记录下自己开踩过的坑，还是很重要的。还有自己的博客想怎么折腾就怎么折腾。想说什么就能说什么。 希望路能越走越顺吧。啦啦啦……..]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
